<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dungeon Crawler</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        
        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #phaser-game {
            width: 100%;
            height: 100%;
        }
        
        .hud {
            position: absolute;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 8px;
            user-select: none;
        }
        
        .player-banners {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px; /* Full width again since no scoreboard */
            display: flex;
            gap: 10px;
            z-index: 50;
            flex-wrap: wrap;
        }
        
        .player-banner {
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 12px;
            border-radius: 8px;
            border: 2px solid;
            color: white;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 120px;
        }
        
        .player-color-indicator {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.5);
        }
        
        .player-banner.current-player {
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        
        .top-hud {
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            align-items: center;
        }
        
        .gold {
            background: rgba(255, 215, 0, 0.2);
            padding: 8px 16px;
            border-radius: 20px;
            border: 2px solid #FFD700;
            font-weight: bold;
        }
        
        .phase-info {
            text-align: center;
        }
        
        .shop {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 10px;
            border-radius: 8px;
            display: none;
            max-width: 85vw;
            max-height: 25vh;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 215, 0, 0.3);
        }
        
        .shop.active {
            display: block;
        }
        
        .shop-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .shop-title {
            color: #FFD700;
            font-size: 24px;
            font-weight: bold;
        }
        
        
        .shop-units {
            display: flex;
            gap: 8px;
            flex-wrap: nowrap;
            justify-content: flex-start;
            max-width: 100%;
            overflow-x: auto;
            overflow-y: hidden;
            padding: 5px 0;
        }
        
        /* Custom scrollbar for shop units */
        .shop-units::-webkit-scrollbar {
            height: 6px;
        }
        
        .shop-units::-webkit-scrollbar-track {
            background: rgba(255, 215, 0, 0.1);
            border-radius: 3px;
        }
        
        .shop-units::-webkit-scrollbar-thumb {
            background: rgba(255, 215, 0, 0.3);
            border-radius: 3px;
        }
        
        .shop-units::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 215, 0, 0.5);
        }
        
        /* Sell Area Styles */
        .sell-area {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(139, 69, 19, 0.95);
            padding: 20px;
            border-radius: 8px;
            display: none;
            max-width: 85vw;
            z-index: 101;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 69, 0, 0.7);
            text-align: center;
        }
        
        .sell-area.active {
            display: block;
        }
        
        .sell-area-content {
            color: #FFD700;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }
        
        .sell-area-hint {
            color: #FFA500;
            font-size: 14px;
            margin-top: 10px;
            font-style: italic;
        }
        
        .unit-card {
            background: linear-gradient(145deg, rgba(45, 45, 80, 0.9), rgba(30, 30, 60, 0.9));
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 12px;
            padding: 8px;
            width: 120px;
            min-width: 120px;
            flex-shrink: 0;
            cursor: grab;
            transition: all 0.3s ease;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }
        
        .shop-unit-sprite-container {
            width: 100px;
            height: 100px;
            margin: 0 auto 8px auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
        }
        
        .shop-unit-sprite-container canvas {
            display: block;
            margin: 0;
            padding: 0;
        }
        
        .shop-unit-sprite {
            width: 48px;
            height: 48px;
            image-rendering: pixelated;
            animation: idle-bob 2s ease-in-out infinite;
        }
        
        .unit-card:hover {
            transform: translateY(-4px) scale(1.02);
            border-color: #FFD700;
            box-shadow: 0 8px 25px rgba(255, 215, 0, 0.2);
        }
        
        .unit-card.dragging {
            cursor: grabbing;
            opacity: 0.6;
            transform: scale(0.95);
        }
        
        .unit-card.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            pointer-events: none;
            filter: grayscale(0.8);
        }
        
        .unit-name {
            color: #FFD700;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 12px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            text-transform: capitalize;
        }
        
        .unit-cost {
            color: #FFD700;
            font-weight: bold;
            font-size: 18px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            background: rgba(255, 215, 0, 0.1);
            padding: 4px 8px;
            border-radius: 8px;
            margin: 8px 0;
        }
        
        .unit-stats {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-top: 12px;
            font-size: 14px;
            font-weight: bold;
            color: #fff;
        }
        
        .unit-stats span {
            background: rgba(255, 255, 255, 0.1);
            padding: 4px 6px;
            border-radius: 6px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        .ready-button {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
        }
        
        .ready-button:hover {
            background: #66BB6A;
        }
        
        .ready-button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        #connection-status {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
        }
        
        .connected {
            background: rgba(76, 175, 80, 0.3);
            color: #4CAF50;
            border: 2px solid #4CAF50;
        }
        
        .disconnected {
            background: rgba(244, 67, 54, 0.3);
            color: #F44336;
            border: 2px solid #F44336;
        }
        
        /* Unit Selection Modal */
        .unit-selection-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(4px);
        }
        
        .unit-selection-content {
            background: rgba(26, 26, 46, 0.85);
            border: 2px solid rgba(255, 215, 0, 0.8);
            border-radius: 16px;
            padding: 15px;
            width: 70vw;
            height: auto;
            max-width: 750px;
            max-height: 70vh;
            min-height: 350px;
            display: flex;
            position: relative;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        
        /* Ensure upgrade modal fits on screen with buttons */
        #upgrade-modal .unit-selection-content {
            height: auto;
            max-height: 70vh;
            width: 85vw;
            max-width: 1000px;
            padding: 20px;
            overflow-y: auto;
            background: rgba(20, 20, 35, 0.9);
        }
        
        /* Ensure confirm button is always visible on smaller screens */
        @media (max-height: 800px) {
            #upgrade-modal .unit-selection-content {
                height: calc(100vh - 160px); /* More space for buttons */
                max-height: 400px;
            }
            
            .select-upgrade-btn {
                bottom: 15px;
                right: 15px;
                padding: 12px 20px;
                font-size: 14px;
            }
        }
        
        @media (max-height: 650px) {
            #upgrade-modal .unit-selection-content {
                height: calc(100vh - 180px); /* Even more space for buttons */
                max-height: 320px;
            }
            
            .select-upgrade-btn {
                bottom: 10px;
                right: 10px;
                padding: 10px 16px;
                font-size: 12px;
            }
            
            .upgrade-modal-close-btn,
            .reroll-upgrades-btn {
                padding: 8px 16px;
                font-size: 12px;
            }
            
            .upgrade-cards-container {
                gap: 8px;
                padding: 4px;
            }
            
            .unit-sprite-selector {
                max-height: 60px;
            }
            
            .unit-selection-sprite {
                min-width: 30px;
                padding: 2px;
            }
            
            .unit-sprite-container {
                width: 20px;
                height: 20px;
            }
        }
        
        .unit-selection-title {
            color: #FFD700;
            font-size: 28px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .unit-selection-subtitle {
            color: #ddd;
            font-size: 16px;
            text-align: center;
            margin-bottom: 20px;
            opacity: 0.8;
        }
        
        .units-grid {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            padding: 0 20px;
        }
        
        .unit-selection-card {
            background: linear-gradient(145deg, rgba(45, 45, 80, 0.9), rgba(30, 30, 60, 0.9));
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 8px;
            padding: 2px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            width: 200px;
            height: 220px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            position: relative;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }
        
        .unit-selection-card:hover {
            transform: translateY(-4px) scale(1.02);
            border-color: rgba(255, 215, 0, 0.8);
            box-shadow: 0 8px 25px rgba(255, 215, 0, 0.2);
        }
        
        .unit-selection-card.selected {
            border-color: #FFD700;
            background: rgba(255, 215, 0, 0.2);
        }
        
        .unit-selection-card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .unit-selection-name {
            color: #FFD700;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 4px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            text-transform: capitalize;
        }
        
        .unit-sprite-container {
            width: 196px;
            height: 190px;
            margin: 0;
            background: transparent;
            border: none;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: visible;
            flex: 1;
        }
        
        .unit-sprite-canvas {
            width: 64px;
            height: 64px;
            image-rendering: pixelated;
        }
        
        @keyframes idle-bob {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-2px); }
        }
        
        .unit-selection-stats {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin: 15px 0;
            font-size: 14px;
            font-weight: bold;
            color: #fff;
        }
        
        .unit-selection-stats span {
            background: rgba(255, 255, 255, 0.1);
            padding: 6px 8px;
            border-radius: 8px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        .start-game-btn {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            display: block;
            margin: 0 auto;
        }
        
        .start-game-btn:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .hidden {
            display: none !important;
        }
        
        /* Tooltip Styles */
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #FFD700;
            z-index: 2000;
            max-width: 300px;
            font-size: 12px;
            line-height: 1.4;
            pointer-events: none;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.2s, transform 0.2s;
        }
        
        .tooltip.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        .tooltip-header {
            color: #FFD700;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 8px;
            text-align: center;
        }
        
        .tooltip-section {
            margin-bottom: 8px;
        }
        
        .tooltip-section:last-child {
            margin-bottom: 0;
        }
        
        .tooltip-label {
            color: #ccc;
            font-weight: bold;
        }
        
        .tooltip-value {
            color: #fff;
        }
        
        .tooltip-passive {
            color: #4CAF50;
            font-style: italic;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 215, 0, 0.3);
        }
        
        /* In-game tooltip for units on grid */
        .game-tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 12px;
            border-radius: 6px;
            border: 2px solid #FFD700;
            z-index: 2500;
            max-width: 250px;
            font-size: 11px;
            line-height: 1.4;
            pointer-events: auto;
            display: none;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }
        
        .game-tooltip.show {
            display: block;
        }
        
        .game-tooltip-header {
            color: #FFD700;
            font-size: 13px;
            font-weight: bold;
            margin-bottom: 6px;
            text-align: center;
        }
        
        .game-tooltip-owner {
            color: #4CAF50;
            font-size: 11px;
            margin-bottom: 6px;
            text-align: center;
        }
        
        .game-tooltip-stats {
            font-size: 11px;
            line-height: 1.5;
        }
        
        .game-tooltip-upgrades {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 215, 0, 0.3);
        }
        
        .game-tooltip-upgrade-item {
            display: flex;
            align-items: center;
            gap: 6px;
            margin: 4px 0;
        }
        
        .game-tooltip-upgrade-item img {
            width: 16px;
            height: 16px;
            border-radius: 3px;
        }
        
        /* Upgrade Modal Styles */
        .upgrade-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            margin-bottom: 15px;
        }
        
        .upgrade-section h3 {
            color: #FFD700;
            text-align: center;
            margin: 0 0 15px 0;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        .upgrade-cards-container {
            display: flex;
            justify-content: center;
            gap: 12px;
            flex-wrap: wrap;
            padding: 5px;
            margin-bottom: 15px;
        }
        
        /* Scrollbar styles removed - no scrolling allowed in upgrade panel */
        
        .upgrade-card {
            background: rgba(255, 255, 255, 0.08);
            border: 2px solid rgba(255, 215, 0, 0.4);
            border-radius: 8px;
            padding: 8px;
            width: 150px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            position: relative;
            display: flex;
            flex-direction: column;
            height: auto;
            min-height: 160px;
            justify-content: center;
            align-items: center;
        }
        
        /* Responsive scaling for smaller screens */
        @media (max-height: 700px) {
            #upgrade-modal .unit-selection-content {
                max-height: 65vh;
                padding: 10px;
            }
            
            .upgrade-card {
                width: 130px;
                min-height: 140px;
                padding: 6px;
            }
            
            .unit-selection-title {
                font-size: 24px;
            }
            
            .upgrade-icon {
                width: 40px;
                height: 40px;
            }
            
            .upgrade-icon img {
                width: 32px;
                height: 32px;
            }
            
            .upgrade-name {
                font-size: 14px;
            }
            
            .upgrade-description {
                font-size: 12px;
            }
        }
        
        @media (max-height: 600px) {
            #upgrade-modal .unit-selection-content {
                max-height: 65vh;
                padding: 10px;
            }
            
            .upgrade-card {
                width: 150px;
                min-height: 160px;
                padding: 10px;
            }
            
            .unit-selection-title {
                font-size: 20px;
            }
            
            .upgrade-icon {
                width: 35px;
                height: 35px;
            }
            
            .upgrade-icon img {
                width: 28px;
                height: 28px;
            }
            
            .upgrade-name {
                font-size: 13px;
            }
            
            .upgrade-description {
                font-size: 11px;
            }
            
            .select-upgrade-btn {
                padding: 10px 20px;
                font-size: 14px;
            }
        }
        
        /* Ultra-small screens (mobile phones in landscape, small windows) */
        @media (max-height: 500px) {
            #upgrade-modal .unit-selection-content {
                height: calc(100vh - 120px);
                max-height: 280px;
                padding: 2px;
            }
            
            .unit-selection-title {
                font-size: 12px;
                margin-bottom: 2px;
            }
            
            .unit-selection-subtitle {
                font-size: 8px;
                margin-bottom: 4px;
            }
            
            .upgrade-section h3 {
                font-size: 10px;
                margin-bottom: 2px;
            }
            
            .upgrade-card {
                height: clamp(80px, 15vh, 100px);
                width: clamp(80px, 12vw, 110px);
                padding: 1px;
            }
            
            .upgrade-name {
                font-size: 8px;
                margin-bottom: 1px;
            }
            
            .upgrade-description {
                font-size: 6px;
                min-height: 15px;
                margin-bottom: 2px;
            }
            
            .upgrade-target {
                font-size: 6px;
                margin-bottom: 1px;
            }
            
            .upgrade-icon {
                width: 18px;
                height: 18px;
                margin-bottom: 1px;
            }
            
            .upgrade-icon img {
                width: 14px;
                height: 14px;
            }
            
            .unit-sprite-selector {
                max-height: 45px;
            }
            
            .unit-sprite-container {
                width: 16px;
                height: 16px;
            }
            
            .unit-selection-name {
                font-size: 6px;
            }
            
            .select-upgrade-btn {
                bottom: 5px;
                right: 5px;
                padding: 8px 12px;
                font-size: 10px;
            }
            
            .upgrade-modal-close-btn,
            .reroll-upgrades-btn {
                top: 10px;
                padding: 6px 12px;
                font-size: 10px;
            }
        }
        
        .upgrade-card.high-potency {
            border-color: #FFD700;
            background: rgba(255, 215, 0, 0.1);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }
        
        .upgrade-card.high-potency::before {
            content: "√ó3 EFFECT";
            position: absolute;
            top: 8px;
            right: 8px;
            background: #FFD700;
            color: #000;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
            z-index: 1;
        }
        
        .upgrade-card:hover {
            transform: translateY(-4px) scale(1.02);
            border-color: #FFD700;
            box-shadow: 0 8px 25px rgba(255, 215, 0, 0.3);
        }
        
        .upgrade-card.selected {
            border: 3px solid #FFD700;
            background: rgba(255, 215, 0, 0.15);
            transform: translateY(-5px) scale(1.02);
            box-shadow: 0 10px 30px rgba(255, 215, 0, 0.4);
        }
        
        .upgrade-card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .upgrade-icon {
            width: 50px;
            height: 50px;
            margin: 0 auto 10px auto;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid rgba(255, 215, 0, 0.2);
        }
        
        .upgrade-icon img {
            width: 40px;
            height: 40px;
            border-radius: 4px;
            image-rendering: pixelated;
        }
        
        .upgrade-name {
            color: #FFD700;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 8px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        .upgrade-description {
            color: #ddd;
            font-size: 13px;
            margin-bottom: 10px;
            line-height: 1.4;
            opacity: 0.9;
        }
        
        .upgrade-target {
            color: #4CAF50;
            font-size: 11px;
            font-weight: bold;
            margin-top: 5px;
            font-style: italic;
        }
        
        .unit-type-selector {
            display: flex;
            gap: 8px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        
        .unit-type-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 215, 0, 0.3);
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }
        
        .unit-type-btn:hover {
            border-color: #FFD700;
            background: rgba(255, 215, 0, 0.1);
        }
        
        .unit-type-btn.selected {
            background: #4CAF50;
            border-color: #4CAF50;
        }
        
        .unit-type-option {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 5px 0;
            cursor: pointer;
            padding: 8px 12px;
            border-radius: 8px;
            transition: background-color 0.2s ease;
        }
        
        .unit-type-option:hover {
            background: rgba(255, 215, 0, 0.1);
        }
        
        .unit-type-option input[type="radio"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }
        
        .unit-type-option span {
            color: #FFD700;
            font-size: 14px;
            font-weight: bold;
        }
        
        .unit-sprite-selector {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
            margin: 10px 0;
            padding: 5px;
        }
        
        .unit-selection-sprite {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: clamp(2px, 0.4vh, 5px);
            border: 1px solid transparent;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.05);
            min-width: clamp(30px, 5vh, 50px);
        }
        
        .unit-selection-sprite:hover {
            background: rgba(255, 215, 0, 0.1);
            border-color: rgba(255, 215, 0, 0.3);
        }
        
        .unit-selection-sprite.selected {
            background: rgba(76, 175, 80, 0.2);
            border-color: #4CAF50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }
        
        .unit-sprite-container {
            width: clamp(20px, 3vh, 32px);
            height: clamp(20px, 3vh, 32px);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: clamp(1px, 0.2vh, 3px);
        }
        
        .unit-selection-name {
            color: #FFD700;
            font-size: clamp(6px, 0.8vh, 10px);
            font-weight: bold;
            text-align: center;
            line-height: 1;
        }
        
        .upgrade-actions {
            margin-top: 10px;
            border-top: 1px solid rgba(255, 215, 0, 0.2);
            padding-top: 10px;
            flex-shrink: 0;
        }
        
        .confirm-upgrade-btn {
            background: linear-gradient(145deg, #4CAF50, #45a049);
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: clamp(12px, 1.2vw, 14px);
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 10px rgba(76, 175, 80, 0.3);
            width: 100%;
        }
        
        .confirm-upgrade-btn:hover:not(:disabled) {
            background: linear-gradient(145deg, #5CBF60, #4CAF50);
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
        }
        
        .confirm-upgrade-btn:disabled {
            background: #666;
            cursor: not-allowed;
            opacity: 0.6;
            transform: none;
            box-shadow: none;
        }
        
        /* Fixed position upgrade interface buttons */
        .upgrade-modal-close-btn {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(255, 68, 68, 0.8);
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 12px;
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
            z-index: 10;
            transition: all 0.2s ease;
        }
        
        .upgrade-modal-close-btn:hover {
            background: linear-gradient(145deg, #FF6666, #FF4444);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 68, 68, 0.4);
        }
        
        .reroll-upgrades-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(255, 152, 0, 0.8);
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 12px;
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
            z-index: 10;
            transition: all 0.2s ease;
        }
        
        .reroll-upgrades-btn:hover:not(:disabled) {
            background: linear-gradient(145deg, #FF7043, #FF6B35);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 87, 34, 0.4);
        }
        
        .reroll-upgrades-btn:disabled {
            background: #666;
            cursor: not-allowed;
            opacity: 0.6;
            transform: none;
            box-shadow: none;
        }
        
        .select-upgrade-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(145deg, #4CAF50, #388E3C);
            border: none;
            color: white;
            padding: 12px 24px;
            border-radius: 16px;
            font-size: 15px;
            font-weight: bold;
            cursor: pointer;
            z-index: 10;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
            transition: all 0.2s ease;
        }
        
        .select-upgrade-btn:hover:not(:disabled) {
            background: linear-gradient(145deg, #5CBF60, #4CAF50);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }
        
        .select-upgrade-btn:disabled {
            background: #666;
            cursor: not-allowed;
            opacity: 0.6;
            transform: none;
            box-shadow: none;
        }
        
        /* Pulsing animation for upgrade button */
        .select-upgrade-btn:not(.hidden) {
            animation: upgrade-pulse 2s infinite;
        }
        
        @keyframes upgrade-pulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
            }
            50% {
                transform: scale(1.05);
                box-shadow: 0 6px 25px rgba(76, 175, 80, 0.6);
            }
        }
        
        /* Additional responsive styles for mobile */
        @media (max-width: 768px) {
            #upgrade-modal .unit-selection-content {
                width: 90vw;
                padding: 15px;
            }
            
            .upgrade-cards-container {
                gap: 10px;
            }
            
            .upgrade-card {
                width: 140px;
                min-height: 170px;
            }
            
            .select-upgrade-btn {
                bottom: 10px;
                right: 10px;
                padding: 12px 20px;
                font-size: 14px;
            }
            
            .upgrade-modal-close-btn,
            .reroll-upgrades-btn {
                top: 10px;
                padding: 10px 15px;
                font-size: 12px;
            }
            }
            
            .unit-stats {
                font-size: 10px;
            }
            
            .hud {
                padding: 8px;
            }
            
            .player-banner {
                padding: 6px 10px;
                font-size: 12px;
            }
        }
        
        /* Portrait mode adjustments */
        @media (orientation: portrait) and (max-height: 1000px) {
            .shop-panel {
                max-height: 30vh;
            }
            
            .unit-panel {
                max-height: 100px;
            }
            
            .unit-selection-content {
                height: 95vh;
                width: 95vw;
            }
        }
        
        /* High DPI screens (React Native) */
        @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
            .game-tooltip {
                font-size: 13px;
            }
            
            .tooltip {
                font-size: 14px;
            }
        }
        
        /* Electron app window size detection */
        @media (min-width: 1200px) and (min-height: 800px) {
            #game-container {
                max-width: 1920px;
                max-height: 1080px;
                margin: 0 auto;
            }
        }
        
        /* Sell Unit Tooltip */
        .sell-tooltip {
            position: fixed;
            background: linear-gradient(145deg, rgba(30, 30, 60, 0.95), rgba(20, 20, 40, 0.95));
            border: 2px solid #FFD700;
            border-radius: 12px;
            padding: 12px;
            z-index: 2500;
            min-width: 200px;
            max-width: 250px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(5px);
            pointer-events: auto;
            font-size: 12px;
        }
        
        .sell-tooltip.hidden {
            display: none;
        }
        
        .sell-tooltip-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .sell-tooltip-close {
            background: none;
            border: none;
            color: #ccc;
            font-size: 16px;
            cursor: pointer;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .sell-tooltip-close:hover {
            color: #fff;
        }
        
        .sell-tooltip-content {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .sell-unit-sprite {
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        
        .sell-tooltip-details {
            flex: 1;
        }
        
        .sell-unit-name {
            color: #FFD700;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 2px;
        }
        
        .sell-unit-price {
            color: #4CAF50;
            font-size: 13px;
            font-weight: bold;
            margin-bottom: 3px;
        }
        
        .sell-tooltip-description {
            color: #ccc;
            font-size: 10px;
            margin: 0;
            line-height: 1.2;
        }
        
        .sell-tooltip-buttons {
            display: flex;
            gap: 8px;
            justify-content: space-between;
        }
        
        .sell-confirm-btn, .sell-cancel-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 6px;
            font-size: 11px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            flex: 1;
        }
        
        .sell-confirm-btn {
            background: #4CAF50;
            color: white;
        }
        
        .sell-confirm-btn:hover {
            background: #45a049;
            transform: translateY(-1px);
        }
        
        .sell-cancel-btn {
            background: #666;
            color: white;
        }
        
        .sell-cancel-btn:hover {
            background: #555;
            transform: translateY(-1px);
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="phaser-game"></div>
        
        <!-- Player Banners -->
        <div id="player-banners" class="player-banners">
            <!-- Player banners will be dynamically added here -->
        </div>
        
        
        <div class="hud top-hud">
            <div class="gold">
                üí∞ <span id="gold-amount">50</span>
            </div>
            <div class="phase-info">
                <div id="phase-text">Preparation Phase</div>
                <div id="floor-text">Floor 1/10</div>
                <div id="timer-text" style="color: #FFD700; font-weight: bold; margin: 5px 0;">‚è±Ô∏è 60s</div>
                <button class="ready-button" id="ready-btn" onclick="setReady()">READY</button>
            </div>
        </div>
        
        <div id="connection-status" class="disconnected">
            Connecting...
        </div>
        
        
        <div class="shop" id="shop-panel">
            <div class="shop-header">
                <div class="shop-title">YOUR SELECTED UNITS</div>
            </div>
            <div class="shop-units" id="shop-units">
                <!-- Units will be populated here -->
            </div>
        </div>
        
        <div class="sell-area" id="sell-area">
            <div class="sell-area-content">
                üî• SELL UNIT üî•<br>
                <span id="sell-value">Get 0 gold</span>
            </div>
            <div class="sell-area-hint">
                Drop unit here to sell for 75% of purchase price
            </div>
        </div>
    </div>

    <!-- Lobby Modal -->
    <div id="lobby-modal" class="unit-selection-modal">
        <div class="unit-selection-content">
            <h2 class="unit-selection-title">Dungeon Crawler Lobby</h2>
            <p class="unit-selection-subtitle">Choose how to play</p>
            
            <div style="display: flex; gap: 20px; justify-content: center; margin: 30px 0;">
                <button class="start-game-btn" onclick="findMatch()">
                    Find Match (1-4 Players)
                </button>
                <button class="start-game-btn" onclick="createPrivateMatch()">
                    Create Private Match
                </button>
            </div>
            
            <div id="lobby-status" style="text-align: center; color: #ccc; margin: 20px 0;">
                Choose an option to start playing
            </div>
            
            <div id="player-list" style="display: none;">
                <h3 style="color: #FFD700; text-align: center;">Players in Match</h3>
                <div id="players-container"></div>
                <button class="start-game-btn" id="lobby-ready-btn" onclick="setLobbyReady()" style="margin-top: 20px;">
                    Ready
                </button>
            </div>
        </div>
    </div>

    <!-- Unit Selection Modal -->
    <div id="unit-selection-modal" class="unit-selection-modal hidden">
        <div class="unit-selection-content">
            <h2 class="unit-selection-title">Choose Your Starting Units</h2>
            <p class="unit-selection-subtitle">Select 5 units (<span id="selected-count">0</span>/5)</p>
            <div class="units-grid" id="unit-selection-grid">
                <!-- Units will be populated here -->
            </div>
            <button class="start-game-btn" id="start-game-btn" onclick="startGame()" disabled>
                Start Game
            </button>
        </div>
    </div>

    <!-- Tooltip Container -->
    <div id="tooltip" class="tooltip"></div>
    
    <!-- In-game tooltip for hovering units on grid -->
    <div id="game-tooltip" class="game-tooltip"></div>

    <!-- Upgrade Selection Modal -->
    <div id="upgrade-modal" class="unit-selection-modal hidden">
        <div class="unit-selection-content">
            <h2 class="unit-selection-title">Choose Your Upgrades</h2>
            <p class="unit-selection-subtitle">Floor <span id="upgrade-floor">1</span> Complete!</p>
            
            <div class="upgrade-section">
                <h3>High-Potency Upgrade (√ó3 Effect)</h3>
                <div id="high-potency-upgrade" class="upgrade-cards-container">
                    <!-- High-potency upgrade will be populated here -->
                </div>
            </div>
            
            <div class="upgrade-section">
                <h3>Normal Upgrades (Choose Unit Type)</h3>
                <div id="normal-upgrades" class="upgrade-cards-container">
                    <!-- Normal upgrades will be populated here -->
                </div>
            </div>
            
            <p style="color: #FFD700; margin-top: 20px; font-style: italic; font-size: 14px; text-align: center;">
                Click any upgrade card to select it and continue to the next floor
            </p>
            
            <!-- Buttons positioned within the modal content -->
            <button class="upgrade-modal-close-btn" onclick="closeUpgradeModal()" id="close-upgrade-btn">
                ‚úï Close
            </button>
            
            <button class="reroll-upgrades-btn" onclick="rerollUpgrades()" id="reroll-btn">
                üé≤ Reroll Upgrades (üí∞ 10)
            </button>
            
            <button class="select-upgrade-btn hidden" id="select-upgrade-btn" onclick="confirmSelectedUpgrade()">
                ‚úÖ Select This Upgrade
            </button>
        </div>
    </div>

    <!-- Sell Unit Tooltip -->
    <div id="sell-tooltip" class="sell-tooltip hidden">
        <div class="sell-tooltip-header">
            <div class="sell-unit-name" id="sell-tooltip-name">Unit Name</div>
            <button class="sell-tooltip-close" onclick="closeSellTooltip()">√ó</button>
        </div>
        <div class="sell-tooltip-content">
            <div class="sell-unit-sprite" id="sell-tooltip-sprite">
                <!-- Unit sprite will be added here -->
            </div>
            <div class="sell-tooltip-details">
                <div class="sell-unit-price" id="sell-tooltip-price">üí∞ 0</div>
                <p class="sell-tooltip-description">75% of purchase price (rounded up)</p>
            </div>
        </div>
        <div class="sell-tooltip-buttons">
            <button class="sell-confirm-btn" onclick="confirmSellUnit()">
                üí∞ Sell
            </button>
            <button class="sell-cancel-btn" onclick="closeSellTooltip()">
                Cancel
            </button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
    <script src="https://cdn.socket.io/4.8.1/socket.io.min.js"></script>
    <script>
        // Game configuration
        const SERVER_URL = 'http://localhost:3001';
        let socket = null;
        let game = null;
        let gameState = null;
        let playerId = null;
        let selectedUnits = [];
        let hasSelectedStartingUnits = false;
        let playerStartingUnits = [];
        let isInLobby = false;
        
        
        // Available units for selection (detailed stats per Game Requirements)
        const AVAILABLE_UNITS = {
            knight: { 
                cost: 20, 
                damage: 2, 
                health: 38, // Reduced by another 50% for much faster combat
                attackSpeed: 1.0,
                movementSpeed: 38, // Reduced by 50% for slower tactical movement 
                range: 8, // Increased from 3 to 8 to prevent collision circling
                priority: 1,
                attackType: 'Physical', 
                armorType: 'Heavy',
                innatePassive: 'Gains √ó2 effectiveness from heals',
                description: 'Heavily armored melee unit with high survivability'
            },
            priest: { 
                cost: 12, 
                damage: 0, // No damage - priests only heal
                health: 20, // Reduced by another 50% for much faster combat
                attackSpeed: 0.5, // Heal every 2 seconds (1/0.5 = 2 seconds)
                movementSpeed: 30, // Reduced by 50% for slower tactical movement
                range: 10, // Slightly higher than knight's 8 range
                priority: 5, // Higher priority to protect healers
                attackType: 'Healing', // Changed from Magical to Healing
                armorType: 'Unarmored',
                innatePassive: 'Cannot attack enemies - instead heals friendly units',
                description: 'Support unit that heals the lowest health ally instead of attacking enemies'
            },
            fighter: { 
                cost: 10, 
                damage: 3, 
                health: 30, // Reduced by another 50% for much faster combat
                attackSpeed: 1.0,
                movementSpeed: 40, // Reduced by 50% for slower tactical movement 
                range: 8, // Increased from 3 to 8 to prevent collision circling
                priority: 3,
                attackType: 'Physical', 
                armorType: 'Light',
                innatePassive: 'None',
                description: 'Balanced melee unit with good damage and speed'
            },
            wizard: { 
                cost: 12, 
                damage: 4, 
                health: 18, // Reduced by another 50% for much faster combat
                attackSpeed: 0.25, // Significantly reduced: 1 attack every 4 seconds instead of every second
                movementSpeed: 30, // Reduced by 50% for slower tactical movement
                range: 50,
                priority: 3,
                attackType: 'Magical', 
                armorType: 'Unarmored',
                innatePassive: 'None',
                description: 'High damage ranged caster with low survivability'
            },
            goblin: { 
                cost: 7, 
                damage: 3, 
                health: 20, // Reduced by another 50% for much faster combat
                attackSpeed: 1.0,
                movementSpeed: 35, // Reduced by 50% for slower tactical movement 
                range: 8, // Increased from 3 to 8 to prevent collision circling
                priority: 3,
                attackType: 'Physical', 
                armorType: 'Unarmored',
                innatePassive: 'None',
                description: 'Cheap, fast melee unit - good for early game'
            }
        };
        
        // Initialize socket connection
        function initSocket() {
            socket = io(SERVER_URL);
            
            socket.on('connect', () => {
                console.log('Connected to server');
                document.getElementById('connection-status').className = 'connected';
                document.getElementById('connection-status').textContent = 'Connected';
                
                // Don't auto-join match, let player choose
            });
            
            socket.on('disconnect', () => {
                console.log('Disconnected from server');
                document.getElementById('connection-status').className = 'disconnected';
                document.getElementById('connection-status').textContent = 'Disconnected';
                
                // Clear highlights when disconnected
                if (typeof highlightedCells !== 'undefined') {
                    highlightedCells.clear();
                }
            });
            
            socket.on('matchFound', (data) => {
                console.log('Match found:', data);
                playerId = data.playerId;
                
                // Show unit selection if it's floor 1 and haven't selected yet
                if (data.gameState.currentFloor === 1 && !hasSelectedStartingUnits) {
                    document.getElementById('lobby-modal').classList.add('hidden');
                    showUnitSelection();
                } else {
                    updateGameState(data.gameState);
                }
            });
            
            socket.on('lobbyUpdate', (lobbyData) => {
                console.log('Lobby update:', lobbyData);
                updateLobby(lobbyData);
                isInLobby = true;
                
                // Set playerId from lobby data
                if (!playerId && lobbyData.players) {
                    const currentPlayer = lobbyData.players.find(p => p.id === socket.id);
                    if (currentPlayer) {
                        playerId = currentPlayer.id;
                        console.log('Set playerId from lobby:', playerId);
                    }
                }
            });
            
            socket.on('lobbyReady', () => {
                console.log('All players ready, starting unit selection');
                document.getElementById('lobby-modal').classList.add('hidden');
                showUnitSelection();
            });
            
            
            socket.on('game-state', (state) => {
                console.log('üéÆ ===== RECEIVED GAME STATE =====');
                console.log('üìä State phase:', state.phase);
                console.log('‚è∞ Timer:', state.preparationTimeLeft);
                console.log('üë• Players:', state.players?.length);
                console.log('üÜî Current playerId:', playerId);
                console.log('üÜî Socket ID:', socket.id);
                
                // Ensure playerId is set if we can find ourselves in the players
                if (!playerId && state.players) {
                    const currentPlayer = state.players.find(p => p.id === socket.id);
                    if (currentPlayer) {
                        playerId = currentPlayer.id;
                        console.log('‚úÖ Set playerId from game state:', playerId);
                    }
                }
                
                const currentPlayer = state.players?.find(p => p.id === playerId);
                console.log('üë§ Current player found:', !!currentPlayer);
                if (currentPlayer) {
                    console.log('üéÅ Player upgrade cards:', currentPlayer.upgradeCards?.length || 0);
                    console.log('üéÅ Upgrade cards detail:', currentPlayer.upgradeCards);
                    console.log('‚úÖ Player hasSelectedUpgrade:', currentPlayer.hasSelectedUpgrade);
                    console.log('üè∑Ô∏è Player name:', currentPlayer.name);
                    console.log('üÜî Player ID matches:', currentPlayer.id === playerId);
                } else {
                    console.log('‚ùå Current player NOT FOUND');
                    console.log('üîç Available player IDs:', state.players?.map(p => p.id));
                    console.log('üîç Looking for playerId:', playerId);
                }
                
                updateGameState(state);
            });
            
            socket.on('timer-update', (timeLeft) => {
                console.log(`‚è∞ Received timer-update: ${timeLeft}s`);
                updateTimer(timeLeft);
            });
            
            socket.on('combat-update', (playerUnits, enemyUnits) => {
                if (window.gameScene) {
                    window.gameScene.updateCombatState(playerUnits, enemyUnits);
                }
            });
            
            socket.on('unit-healed', (data) => {
                // Show heal effect on the target unit
                if (window.gameScene) {
                    window.gameScene.showHealEffect(data.targetId, data.healAmount);
                }
            });
            
            // Note: Wizard projectiles are handled client-side in MainScene.ts
            // No need for server-side wizard-attack events
            
            socket.on('matchStarted', (matchId) => {
                console.log('Match started:', matchId);
                // Match has been created, game state updates will follow
                
                // Ensure playerId is set (fallback to socket.id)
                if (!playerId) {
                    playerId = socket.id;
                    console.log('Set playerId from socket.id:', playerId);
                }
            });
            
            socket.on('error', (error) => {
                console.error('Socket error:', error);
                alert('Error: ' + error.message);
            });
        }
        
        // Lobby Functions
        function findMatch() {
            console.log('findMatch clicked');
            document.getElementById('lobby-status').textContent = 'Finding match...';
            if (socket) {
                const playerName = 'Player' + Math.floor(Math.random() * 1000);
                console.log('Emitting findMatch with:', { playerName });
                socket.emit('findMatch', { playerName });
            } else {
                console.error('Socket not connected!');
                document.getElementById('lobby-status').textContent = 'Connection error - refresh page';
            }
        }
        
        function createPrivateMatch() {
            console.log('createPrivateMatch clicked');
            document.getElementById('lobby-status').textContent = 'Creating private match...';
            if (socket) {
                const playerName = 'Host' + Math.floor(Math.random() * 1000);
                console.log('Emitting createPrivateMatch with:', { playerName });
                socket.emit('createPrivateMatch', { playerName });
            } else {
                console.error('Socket not connected!');
                document.getElementById('lobby-status').textContent = 'Connection error - refresh page';
            }
        }
        
        function setLobbyReady() {
            console.log('setLobbyReady clicked');
            if (socket) {
                console.log('Emitting setLobbyReady');
                socket.emit('setLobbyReady');
            } else {
                console.error('Socket not connected!');
            }
        }
        
        function updateLobby(lobbyData) {
            const playerList = document.getElementById('player-list');
            const playersContainer = document.getElementById('players-container');
            const lobbyStatus = document.getElementById('lobby-status');
            
            playerList.style.display = 'block';
            playersContainer.innerHTML = '';
            
            lobbyData.players.forEach(player => {
                const playerDiv = document.createElement('div');
                playerDiv.style.cssText = 'padding: 10px; margin: 5px; background: rgba(255,255,255,0.1); border-radius: 8px; display: flex; justify-content: space-between;';
                playerDiv.innerHTML = `
                    <span style="color: white;">${player.name}</span>
                    <span style="color: ${player.isReady ? '#4CAF50' : '#ccc'};">${player.isReady ? 'READY' : 'Not Ready'}</span>
                `;
                playersContainer.appendChild(playerDiv);
            });
            
            lobbyStatus.textContent = `${lobbyData.players.length}/4 players in lobby`;
        }
        
        // Tooltip Functions
        function showTooltip(event, unitName, unitData = null) {
            // If unitData is provided (from shop), use it directly, otherwise lookup in AVAILABLE_UNITS
            let unit = unitData;
            
            if (!unit) {
                // Normalize unit name to lowercase for lookup
                const normalizedName = unitName.toLowerCase();
                unit = AVAILABLE_UNITS[normalizedName];
                if (!unit) {
                    console.warn(`Tooltip: Unit ${unitName} (${normalizedName}) not found in AVAILABLE_UNITS`);
                    return;
                }
            }
            
            const tooltip = document.getElementById('tooltip');
            tooltip.innerHTML = `
                <div class="tooltip-header">${unitName.toUpperCase()}</div>
                ${unit.owner ? `<div class="tooltip-section">
                    <span class="tooltip-label">Owner:</span> <span class="tooltip-value">üë§ ${unit.owner}</span>
                </div>` : ''}
                <div class="tooltip-section">
                    <span class="tooltip-label">Cost:</span> <span class="tooltip-value">üí∞ ${unit.cost}</span>
                </div>
                <div class="tooltip-section">
                    <span class="tooltip-label">Combat Stats:</span><br>
                    ‚öîÔ∏è Damage: <span class="tooltip-value">${unit.damage}</span><br>
                    ‚ù§Ô∏è Health: <span class="tooltip-value">${unit.health}</span><br>
                    ‚ö° Attack Speed: <span class="tooltip-value">${unit.attackSpeed}</span><br>
                    üèÉ Movement Speed: <span class="tooltip-value">${unit.movementSpeed}</span><br>
                    üéØ Range: <span class="tooltip-value">${unit.range}</span><br>
                    üìç Priority: <span class="tooltip-value">${unit.priority}</span>
                </div>
                <div class="tooltip-section">
                    <span class="tooltip-label">Type:</span> <span class="tooltip-value">${unit.attackType}</span><br>
                    <span class="tooltip-label">Armor:</span> <span class="tooltip-value">${unit.armorType}</span>
                </div>
                <div class="tooltip-section">
                    <span class="tooltip-label">Description:</span><br>
                    <span class="tooltip-value">${unit.description || 'Tactical unit for combat'}</span>
                </div>
                ${(unit.innatePassive && unit.innatePassive !== 'None' && unit.innatePassive !== null) ? `
                <div class="tooltip-passive">
                    <strong>Passive:</strong> ${unit.innatePassive}
                </div>
                ` : ''}
                ${getUpgradeTooltipSection(unit)}
            `;
            
            // Position tooltip with smart positioning
            const rect = event.currentTarget.getBoundingClientRect();
            const tooltipMargin = 10;
            
            // Temporarily show tooltip to get dimensions
            tooltip.style.visibility = 'hidden';
            tooltip.classList.add('show');
            
            const tooltipRect = tooltip.getBoundingClientRect();
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            
            // Calculate positions
            let left = rect.left + rect.width + tooltipMargin;
            let top = rect.top;
            
            // Check if tooltip would go off the right edge
            if (left + tooltipRect.width > windowWidth) {
                // Position to the left of the element
                left = rect.left - tooltipRect.width - tooltipMargin;
            }
            
            // Check if tooltip would go off the left edge
            if (left < 0) {
                // Center horizontally if no good position
                left = Math.max(tooltipMargin, (windowWidth - tooltipRect.width) / 2);
            }
            
            // Check if tooltip would go off the bottom
            if (top + tooltipRect.height > windowHeight - tooltipMargin) {
                // Position above the cursor/element
                top = Math.max(tooltipMargin, rect.bottom - tooltipRect.height - rect.height - tooltipMargin);
            }
            
            // Check if tooltip would go off the top
            if (top < tooltipMargin) {
                top = tooltipMargin;
            }
            
            // Apply final position
            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
            tooltip.style.visibility = 'visible';
        }
        
        function hideTooltip() {
            const tooltip = document.getElementById('tooltip');
            tooltip.classList.remove('show');
        }
        
        // Game tooltip functions for in-game unit hovering
        function showGameTooltip(unit, ownerName, mouseX, mouseY) {
            const tooltip = document.getElementById('game-tooltip');
            
            // Build tooltip HTML
            let tooltipHTML = `
                <div class="game-tooltip-header">${unit.name.toUpperCase()}</div>
                <div class="game-tooltip-owner">üë§ ${ownerName}</div>
                <div class="game-tooltip-stats">
                    ‚ù§Ô∏è ${unit.health}/${unit.maxHealth} | ‚öîÔ∏è ${unit.damage} | ‚ö° ${unit.attackSpeed}
                </div>
            `;
            
            // Add upgrades if any
            if (unit.buffs && unit.buffs.length > 0) {
                tooltipHTML += '<div class="game-tooltip-upgrades">';
                unit.buffs.forEach(buff => {
                    let upgradeName = '';
                    let description = '';
                    
                    switch (buff.type) {
                        case 'lifesteal':
                            upgradeName = 'vampiric_strike';
                            description = `${Math.round(buff.value * 100)}% lifesteal`;
                            break;
                        case 'poison':
                            upgradeName = 'poison_blade';
                            description = `${buff.value} poison DPS`;
                            break;
                        case 'deathHeal':
                            upgradeName = 'final_gift';
                            description = `Heals ${Math.round(buff.value * 100)}% on death`;
                            break;
                        case 'deathExplosion':
                            upgradeName = 'explosive_end';
                            description = `Explodes for ${Math.round(buff.value * 100)}%`;
                            break;
                        case 'slowAura':
                            upgradeName = 'slowing_aura';
                            description = `-${Math.round(buff.value * 100)}% enemy AS`;
                            break;
                        default:
                            upgradeName = buff.type.toLowerCase().replace(/\s+/g, '_');
                            description = `${buff.type}: ${buff.value}`;
                    }
                    
                    tooltipHTML += `
                        <div class="game-tooltip-upgrade-item">
                            <img src="assets/upgradeicons/${upgradeName}.png" 
                                 onerror="this.style.display='none'"
                                 alt="${upgradeName}">
                            <span>${description}</span>
                        </div>
                    `;
                });
                tooltipHTML += '</div>';
            }
            
            tooltip.innerHTML = tooltipHTML;
            tooltip.classList.add('show');
            
            // Position tooltip
            updateGameTooltipPosition(mouseX, mouseY);
            
            // Add hover support for the tooltip itself
            tooltip.onmouseenter = () => {
                cancelGameTooltipHide();
            };
            
            tooltip.onmouseleave = () => {
                hideGameTooltipDelayed();
            };
        }
        
        function updateGameTooltipPosition(mouseX, mouseY) {
            const tooltip = document.getElementById('game-tooltip');
            if (!tooltip.classList.contains('show')) return;
            
            const margin = 15;
            const tooltipRect = tooltip.getBoundingClientRect();
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            
            // Default position: to the right and slightly above cursor
            let left = mouseX + margin;
            let top = mouseY - tooltipRect.height / 2;
            
            // Adjust if tooltip goes off right edge
            if (left + tooltipRect.width > windowWidth - margin) {
                left = mouseX - tooltipRect.width - margin;
            }
            
            // Adjust if tooltip goes off top edge
            if (top < margin) {
                top = margin;
            }
            
            // Adjust if tooltip goes off bottom edge
            if (top + tooltipRect.height > windowHeight - margin) {
                top = windowHeight - tooltipRect.height - margin;
            }
            
            // Ensure tooltip doesn't go off left edge
            if (left < margin) {
                left = margin;
            }
            
            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
        }
        
        let gameTooltipHideTimeout;
        
        function hideGameTooltip() {
            const tooltip = document.getElementById('game-tooltip');
            tooltip.classList.remove('show');
        }
        
        function hideGameTooltipDelayed() {
            // Clear any existing timeout
            clearTimeout(gameTooltipHideTimeout);
            
            // Set a delay before hiding to allow mouse movement between units
            gameTooltipHideTimeout = setTimeout(() => {
                hideGameTooltip();
            }, 100); // 100ms delay for better desktop responsiveness
        }
        
        function cancelGameTooltipHide() {
            clearTimeout(gameTooltipHideTimeout);
        }
        
        function getUpgradeTooltipSection(unit) {
            // Check if this unit has any applied upgrades (buffs)
            if (!unit.buffs || unit.buffs.length === 0) {
                return '';
            }
            
            const upgradeItems = [];
            unit.buffs.forEach(buff => {
                let description = '';
                let upgradeName = '';
                
                switch (buff.type) {
                    case 'lifesteal':
                        description = `${Math.round(buff.value * 100)}% damage becomes health`;
                        upgradeName = 'vampiric_strike';
                        break;
                    case 'poison':
                        description = `${buff.value} poison damage per second`;
                        upgradeName = 'poison_blade';
                        break;
                    case 'deathHeal':
                        description = `Heal nearby units ${Math.round(buff.value * 100)}% on death`;
                        upgradeName = 'final_gift';
                        break;
                    case 'deathExplosion':
                        description = `Explode for ${Math.round(buff.value * 100)}% damage on death`;
                        upgradeName = 'explosive_end';
                        break;
                    case 'slowAura':
                        description = `Reduce enemy attack speed by ${Math.round(buff.value * 100)}%`;
                        upgradeName = 'slowing_aura';
                        break;
                    default:
                        description = `${buff.type}: ${buff.value}`;
                        upgradeName = buff.type.toLowerCase().replace(/\s+/g, '_');
                }
                
                if (description) {
                    const iconPath = `assets/upgradeicons/${upgradeName}.png`;
                    upgradeItems.push(`
                        <div style="display: flex; align-items: center; gap: 8px; margin: 4px 0;">
                            <img src="${iconPath}" alt="${upgradeName}" style="width: 20px; height: 20px; border-radius: 4px;" onerror="this.style.display='none'">
                            <span>${description}</span>
                        </div>
                    `);
                }
            });
            
            if (upgradeItems.length === 0) {
                return '';
            }
            
            return `
                <div class="tooltip-passive" style="border-top: 1px solid rgba(76, 175, 80, 0.3); color: #4CAF50; padding-top: 8px;">
                    <strong>Applied Upgrades:</strong><br>
                    ${upgradeItems.join('')}
                </div>
            `;
        }
        
        // Unit Selection Functions
        function showUnitSelection() {
            console.log('Showing unit selection modal');
            const modal = document.getElementById('unit-selection-modal');
            const grid = document.getElementById('unit-selection-grid');
            
            grid.innerHTML = '';
            selectedUnits = [];
            updateSelectedCount();
            
            Object.entries(AVAILABLE_UNITS).forEach(([unitName, stats]) => {
                const card = document.createElement('div');
                card.className = 'unit-selection-card';
                card.onclick = () => toggleUnitSelection(unitName, card);
                
                card.innerHTML = `
                    <div class="unit-selection-name">${unitName}</div>
                    <div class="unit-sprite-container" id="unit-select-${unitName}">
                        <!-- Animated sprite will be added here -->
                    </div>
                `;
                
                // Add animated sprite using our universal function
                setTimeout(() => {
                    const container = document.getElementById(`unit-select-${unitName}`);
                    if (container) {
                        createAnimatedUnitSprite(container, unitName, 196, 190, 400);
                    }
                }, 100);
                
                // Add tooltip event handlers
                card.addEventListener('mouseenter', (e) => showTooltip(e, unitName));
                card.addEventListener('mouseleave', hideTooltip);
                
                grid.appendChild(card);
            });
            
            modal.classList.remove('hidden');
        }
        
        function toggleUnitSelection(unitName, cardElement) {
            console.log('Toggling unit selection for:', unitName);
            const index = selectedUnits.indexOf(unitName);
            
            if (index > -1) {
                // Deselect
                selectedUnits.splice(index, 1);
                cardElement.classList.remove('selected');
                console.log('Deselected:', unitName);
            } else {
                // Select (if under limit)
                if (selectedUnits.length < 5) {
                    selectedUnits.push(unitName);
                    cardElement.classList.add('selected');
                    console.log('Selected:', unitName);
                } else {
                    console.log('Cannot select more units, limit reached');
                }
            }
            
            console.log('Currently selected units:', selectedUnits);
            updateSelectedCount();
            updateStartButton();
        }
        
        function updateSelectedCount() {
            document.getElementById('selected-count').textContent = selectedUnits.length;
        }
        
        function updateStartButton() {
            const startBtn = document.getElementById('start-game-btn');
            startBtn.disabled = selectedUnits.length !== 5;
        }
        
        function startGame() {
            if (selectedUnits.length === 5) {
                hasSelectedStartingUnits = true;
                playerStartingUnits = [...selectedUnits]; // Store selected units
                document.getElementById('unit-selection-modal').classList.add('hidden');
                
                console.log('Player selected starting units:', playerStartingUnits);
                
                // Send selected units to server
                if (socket && socket.connected) {
                    socket.emit('selectStartingUnits', selectedUnits);
                }
                
                // Show the game with shop containing selected units
                showGameWithStartingUnits();
            }
        }
        
        function showGameWithStartingUnits() {
            // Only create mock game state if we don't have a real server connection
            // or if we haven't received a real game state yet
            if (!socket || !socket.connected || !gameState) {
                console.log('Creating mock game state for unit selection preview');
                
                // Create mock game state to show shop with starting units
                const mockGameState = {
                    matchId: 'preview-match',
                    phase: 'preparation',
                    currentFloor: 1,
                    preparationTimeLeft: 60,
                    shopUnits: playerStartingUnits.map(unitName => ({
                        name: unitName,
                        ...AVAILABLE_UNITS[unitName]
                    })),
                    players: [{
                        id: playerId || 'preview-player',
                        name: 'Player',
                        gold: 50,
                        units: [],
                        isReady: false
                    }],
                    enemyUnits: [],
                    grid: createEmptyGrid(12, 12)
                };
                
                // Store as the current game state
                gameState = mockGameState;
                
                const mockPlayer = {
                    id: playerId || 'preview-player',
                    gold: 50,
                    units: [],
                    isReady: false
                };
                
                // Manually show the game UI
                updateGameStateUI(mockGameState, mockPlayer);
            } else {
                console.log('Server connected, waiting for real game state...');
            }
        }
        
        function createEmptyGrid(width, height) {
            const grid = [];
            for (let y = 0; y < height; y++) {
                grid[y] = [];
                for (let x = 0; x < width; x++) {
                    grid[y][x] = {
                        x,
                        y,
                        occupied: false,
                        unitId: null
                    };
                }
            }
            return grid;
        }
        
        // Update game state
        function updateGameState(state) {
            console.log('=== updateGameState called ===');
            console.log('New state received:', state);
            console.log('Current playerId:', playerId);
            console.log('Phase:', state.phase);
            console.log('Players in state:', state.players);
            
            gameState = state;
            window.gameState = state; // Make accessible to Phaser scene
            window.updateGameState = updateGameState; // Make function globally accessible
            
            // Update HUD
            const player = state.players.find(p => p.id === playerId);
            console.log('Found current player:', player);
            updateGameStateUI(state, player);
            
            // Force Phaser scene update
            if (window.gameScene && window.gameScene.updateGameState) {
                console.log('Calling Phaser scene updateGameState...');
                window.gameScene.updateGameState(state);
            } else {
                console.error('Phaser scene or updateGameState method not available!');
            }
        }
        
        function updateGameStateUI(state, player) {
            console.log('üñ•Ô∏è ===== updateGameStateUI called =====');
            console.log('üéÆ State phase:', state.phase);
            console.log('üë§ Player passed to updateGameStateUI:', !!player);
            if (player) {
                console.log('üë§ Player details:', {
                    name: player.name,
                    id: player.id,
                    gold: player.gold,
                    upgradeCards: player.upgradeCards?.length || 0,
                    hasSelectedUpgrade: player.hasSelectedUpgrade
                });
            }
            
            if (player) {
                document.getElementById('gold-amount').textContent = player.gold;
                
                // Update ready button
                const readyBtn = document.getElementById('ready-btn');
                if (player.isReady) {
                    readyBtn.textContent = 'READY!';
                    readyBtn.disabled = true;
                } else {
                    readyBtn.textContent = 'READY';
                    readyBtn.disabled = false;
                }
            }
            
            // Update phase info
            document.getElementById('phase-text').textContent = 
                state.phase === 'preparation' ? 'Preparation Phase' :
                state.phase === 'combat' ? 'Combat Phase' : 
                state.phase === 'post-combat' ? 'Victory! Choose Upgrades' :
                'Game Over';
            document.getElementById('floor-text').textContent = `Floor ${state.currentFloor}/10`;
            
            // Update player banners
            if (state.players) {
                updatePlayerBanners(state.players);
            }
            
            // Update timer (show during preparation phase)
            console.log(`üñ•Ô∏è Client received game state - Phase: ${state.phase}, Timer: ${state.preparationTimeLeft}`);
            if (state.phase === 'preparation' && state.preparationTimeLeft !== undefined) {
                console.log(`‚è∞ Showing timer: ${state.preparationTimeLeft}s`);
                updateTimer(state.preparationTimeLeft);
                document.getElementById('timer-text').style.display = 'block';
            } else {
                // Hide timer during combat
                console.log(`‚ùå Hiding timer - phase: ${state.phase}`);
                document.getElementById('timer-text').style.display = 'none';
            }
            
            // Show/hide ready button based on phase
            const readyBtn = document.getElementById('ready-btn');
            if (state.phase === 'preparation') {
                readyBtn.style.display = 'block';
                // Show battle background preview during preparation
                if (window.gameScene && window.gameScene.showPreparationBackground) {
                    window.gameScene.showPreparationBackground(state.currentFloor || 1);
                }
            } else {
                readyBtn.style.display = 'none';
                // Hide background preview during combat
                if (window.gameScene && window.gameScene.hidePreparationBackground) {
                    window.gameScene.hidePreparationBackground();
                }
            }
            
            // Show/hide shop
            const shopPanel = document.getElementById('shop-panel');
            if (state.phase === 'preparation') {
                shopPanel.classList.add('active');
                // Use shopUnits from state, or fallback to default units for testing
                const shopUnits = state.shopUnits || Object.entries(AVAILABLE_UNITS).slice(0, 4).map(([name, stats]) => ({
                    name,
                    ...stats
                }));
                // Get current player's gold from state
                const currentPlayer = state.players?.find(p => p.id === playerId);
                const playerGold = currentPlayer?.gold ?? 0;
                console.log('Current player gold:', playerGold, 'for player:', playerId);
                updateShop(shopUnits, playerGold);
            } else {
                shopPanel.classList.remove('active');
            }
            
            // Show/hide upgrade modal - DISABLED auto-show, let player manually open
            const upgradeModal = document.getElementById('upgrade-modal');
            const currentPlayer = state.players.find(p => p.id === playerId);
            
            // DISABLED: Don't automatically show upgrade panel after battle
            // Only hide modal if player has already selected an upgrade (to prevent forced closure during selection)
            if (currentPlayer && currentPlayer.hasSelectedUpgrade) {
                upgradeModal.classList.add('hidden');
            }
            
            // Show/hide bottom-right upgrade button
            const upgradeButton = document.getElementById('select-upgrade-btn');
            console.log(`üéÅ ===== UPGRADE BUTTON CHECK =====`);
            console.log(`üìã Phase: ${state.phase}`);
            console.log(`üë§ Current Player: ${currentPlayer ? 'FOUND' : 'NOT FOUND'}`);
            console.log(`üéÅ Upgrade Cards: ${currentPlayer?.upgradeCards?.length || 0}`);
            console.log(`‚úÖ Has Selected: ${currentPlayer?.hasSelectedUpgrade}`);
            console.log(`üîò Button Element: ${upgradeButton ? 'FOUND' : 'NOT FOUND'}`);
            
            // Show upgrade button during preparation phase if player has upgrade cards
            if ((state.phase === 'preparation' || state.phase === 'post-combat') && currentPlayer && currentPlayer.upgradeCards && currentPlayer.upgradeCards.length > 0) {
                console.log(`‚úÖ ===== SHOWING UPGRADE BUTTON =====`);
                console.log(`üìù Button text: Select Upgrade`);
                upgradeButton.classList.remove('hidden');
                upgradeButton.textContent = `Select Upgrade`;
                upgradeButton.style.animation = 'upgrade-pulse 2s infinite'; // Make it flash
                upgradeButton.onclick = () => {
                    console.log(`üñ±Ô∏è Upgrade button clicked!`);
                    upgradeModal.classList.remove('hidden');
                    showUpgradeSelection(currentPlayer.upgradeCards, state.currentFloor, currentPlayer.gold);
                };
            } else {
                console.log(`‚ùå ===== HIDING UPGRADE BUTTON =====`);
                console.log(`üîç Reason analysis:`);
                console.log(`   Phase check: ${(state.phase === 'preparation' || state.phase === 'post-combat') ? 'PASS' : 'FAIL'} (${state.phase})`);
                console.log(`   Player check: ${currentPlayer ? 'PASS' : 'FAIL'}`);
                console.log(`   Cards check: ${currentPlayer?.upgradeCards && currentPlayer.upgradeCards.length > 0 ? 'PASS' : 'FAIL'} (${currentPlayer?.upgradeCards?.length || 0})`);
                upgradeButton.classList.add('hidden');
                upgradeButton.style.animation = 'none'; // Stop flashing when hidden
            }
                
            // Show waiting message if player has selected but others haven't
            if (state.phase === 'post-combat' && currentPlayer && currentPlayer.hasSelectedUpgrade) {
                const waitingCount = state.players.filter(p => !p.hasSelectedUpgrade).length;
                if (waitingCount > 0) {
                    console.log(`Waiting for ${waitingCount} other player(s) to select upgrades...`);
                    // Could show a waiting overlay here
                }
            }
            
            // Update Phaser game - try multiple ways to get the scene
            if (window.gameScene && window.gameScene.updateGameState) {
                console.log('Updating Phaser scene via window.gameScene');
                window.gameScene.updateGameState(state);
            } else if (game && game.scene.getScene('MainScene')) {
                console.log('Updating Phaser scene via game.scene.getScene');
                game.scene.getScene('MainScene').updateGameState(state);
            } else {
                console.error('No Phaser scene available for update!');
                console.log('window.gameScene:', !!window.gameScene);
                console.log('game:', !!game);
                console.log('game.scene:', game?.scene);
            }
        }
        
        // Player color management
        const PLAYER_COLORS = [
            { primary: '#4CAF50', rgb: [76, 175, 80] },   // Green
            { primary: '#2196F3', rgb: [33, 150, 243] },  // Blue  
            { primary: '#FF9800', rgb: [255, 152, 0] },   // Orange
            { primary: '#9C27B0', rgb: [156, 39, 176] }   // Purple
        ];
        
        let playerColorMap = new Map(); // playerId -> colorIndex
        let usedColors = new Set(); // Track which colors are in use
        
        function getPlayerColor(playerId, allPlayers) {
            if (!playerColorMap.has(playerId)) {
                // Deterministic color assignment: sort all players by ID and assign colors in order
                // This ensures all clients assign the same colors to the same players
                const sortedPlayerIds = allPlayers.map(p => p.id).sort();
                const playerIndex = sortedPlayerIds.indexOf(playerId);
                const colorIndex = playerIndex % PLAYER_COLORS.length;
                
                playerColorMap.set(playerId, colorIndex);
                usedColors.add(colorIndex);
            }
            return PLAYER_COLORS[playerColorMap.get(playerId)];
        }
        
        function cleanupPlayerColors(currentPlayers) {
            // For deterministic color assignment, we need to rebuild the color mappings
            // to ensure consistency when players leave and rejoin
            const currentPlayerIds = new Set(currentPlayers.map(p => p.id));
            
            // Clean up mappings for departed players
            for (const [playerId, colorIndex] of playerColorMap) {
                if (!currentPlayerIds.has(playerId)) {
                    playerColorMap.delete(playerId);
                    usedColors.delete(colorIndex);
                }
            }
            
            // Rebuild mappings for consistency
            const sortedPlayerIds = currentPlayers.map(p => p.id).sort();
            playerColorMap.clear();
            usedColors.clear();
            
            sortedPlayerIds.forEach((playerId, index) => {
                const colorIndex = index % PLAYER_COLORS.length;
                playerColorMap.set(playerId, colorIndex);
                usedColors.add(colorIndex);
            });
        }
        

        function updatePlayerBanners(players) {
            const bannerContainer = document.getElementById('player-banners');
            if (!bannerContainer) return;
            
            // Clean up departed players and maintain unique colors
            cleanupPlayerColors(players);
            
            bannerContainer.innerHTML = '';
            
            // Sort players to show current player first
            const sortedPlayers = [...players].sort((a, b) => {
                if (a.id === playerId) return -1;
                if (b.id === playerId) return 1;
                return 0;
            });
            
            sortedPlayers.forEach((player, index) => {
                const color = getPlayerColor(player.id, players);
                const isCurrentPlayer = player.id === playerId;
                
                const banner = document.createElement('div');
                banner.className = `player-banner ${isCurrentPlayer ? 'current-player' : ''}`;
                banner.style.borderColor = color.primary;
                
                // Count alive units for this player
                const aliveUnits = player.units ? player.units.filter(unit => unit.status !== 'dead').length : 0;
                const totalUnits = player.units ? player.units.length : 0;
                
                banner.innerHTML = `
                    <div class="player-color-indicator" style="background-color: ${color.primary}"></div>
                    <span>${player.name}</span>
                    <span style="color: #FFD700;">üí∞${player.gold}</span>
                    ${gameState && gameState.phase === 'combat' ? `<span style="color: #4CAF50;">‚öîÔ∏è${aliveUnits}/${totalUnits}</span>` : ''}
                    ${player.isReady ? '<span style="color: #4CAF50;">‚úì</span>' : ''}
                `;
                
                bannerContainer.appendChild(banner);
            });
        }
        
        // Update timer display
        function updateTimer(timeLeft) {
            const timerElement = document.getElementById('timer-text');
            if (timerElement) {
                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                timerElement.textContent = `‚è±Ô∏è ${timeString}`;
                
                // Change color based on time remaining
                if (timeLeft <= 10) {
                    timerElement.style.color = '#FF4444'; // Red for urgency
                } else if (timeLeft <= 30) {
                    timerElement.style.color = '#FFA500'; // Orange for warning
                } else {
                    timerElement.style.color = '#FFD700'; // Gold for normal
                }
            }
        }

        // Update shop display
        function updateShop(units, playerGold) {
            console.log('Updating shop with units:', units, 'Gold:', playerGold);
            const shopUnitsDiv = document.getElementById('shop-units');
            shopUnitsDiv.innerHTML = '';
            
            units.forEach((unit, index) => {
                // Ensure proper number comparison for 0 gold edge case
                const playerGoldNum = Number(playerGold) || 0;
                const unitCostNum = Number(unit.cost) || 0;
                const canAfford = playerGoldNum >= unitCostNum;
                const unitCard = document.createElement('div');
                unitCard.className = `unit-card ${!canAfford ? 'disabled' : ''}`;
                
                unitCard.innerHTML = `
                    <div class="unit-name">${unit.name}</div>
                    <div class="unit-cost">üí∞ ${unit.cost}</div>
                    <div class="shop-unit-sprite-container" id="shop-sprite-${unit.name.toLowerCase()}-${index}">
                        <!-- Animated sprite will be added here -->
                    </div>
                `;
                
                // Add tooltip event handlers with unit data
                unitCard.addEventListener('mouseenter', (e) => {
                    console.log('Tooltip hover on unit:', unit.name, 'Full unit object:', unit);
                    showTooltip(e, unit.name, unit);
                });
                unitCard.addEventListener('mouseleave', hideTooltip);
                
                if (canAfford) {
                    // Universal drag system for desktop and mobile
                    setupUniversalDrag(unitCard, unit.name.toLowerCase());
                }
                
                shopUnitsDiv.appendChild(unitCard);
            });
            
            // Create animated sprites for shop units with proper delay for Phaser to be ready
            setTimeout(() => {
                units.forEach((unit, index) => {
                    // Use index to prevent ID conflicts for duplicate units
                    const containerId = `shop-sprite-${unit.name.toLowerCase()}-${index}`;
                    const container = document.getElementById(containerId);
                    if (container) {
                        // Match the container size for proper centering
                        createAnimatedUnitSprite(container, unit.name.toLowerCase(), 100, 100, 400);
                    }
                });
            }, 200); // Increased delay to ensure Phaser is ready
        }
        
        // Universal drag system for desktop and mobile
        function setupUniversalDrag(element, unitName) {
            let isDragging = false;
            let isMouseDown = false;
            let dragClone = null;
            let startX, startY;
            
            // Mouse events for desktop
            element.addEventListener('mousedown', startDrag);
            
            // Touch events for mobile
            element.addEventListener('touchstart', startDrag, { passive: false });
            
            function startDrag(e) {
                e.preventDefault();
                console.log(`üñ±Ô∏è Mouse down on shop unit: ${unitName}`);
                isMouseDown = true;
                isDragging = false; // Don't start dragging immediately
                
                const touch = e.touches ? e.touches[0] : e;
                startX = touch.clientX;
                startY = touch.clientY;
                
                // Add move and end listeners immediately
                document.addEventListener('mousemove', handleDrag);
                document.addEventListener('mouseup', endDrag);
                document.addEventListener('touchmove', handleDrag, { passive: false });
                document.addEventListener('touchend', endDrag);
            }
            
            function createDragClone(currentX, currentY) {
                console.log(`üé® Creating drag clone for ${unitName} at (${currentX}, ${currentY})`);
                
                // Create a sprite-only visual for dragging
                dragClone = document.createElement('div');
                dragClone.style.position = 'fixed';
                dragClone.style.pointerEvents = 'none';
                dragClone.style.zIndex = '9999';
                dragClone.style.opacity = '0.8';
                dragClone.style.width = '48px';
                dragClone.style.height = '48px';
                dragClone.style.borderRadius = '8px';
                dragClone.style.left = (currentX - 24) + 'px';
                dragClone.style.top = (currentY - 24) + 'px';
                
                // Create canvas for the drag sprite
                const dragCanvas = document.createElement('canvas');
                dragCanvas.width = 48;
                dragCanvas.height = 48;
                dragCanvas.setAttribute('data-unit', unitName.toLowerCase());
                dragCanvas.style.width = '100%';
                dragCanvas.style.height = '100%';
                dragCanvas.style.imageRendering = 'pixelated';
                
                dragClone.appendChild(dragCanvas);
                document.body.appendChild(dragClone);
                
                // Update the drag canvas immediately
                if (window.gameScene && window.gameScene.updateUnitCanvases) {
                    setTimeout(() => window.gameScene.updateUnitCanvases(), 10);
                }
                
                element.classList.add('dragging');
            }
            
            function handleDrag(e) {
                if (!isMouseDown) return;
                e.preventDefault();
                
                const touch = e.touches ? e.touches[0] : e;
                
                // Check if we should start dragging (minimum distance threshold)
                if (!isDragging) {
                    const deltaX = Math.abs(touch.clientX - startX);
                    const deltaY = Math.abs(touch.clientY - startY);
                    
                    // Start dragging if moved more than 5 pixels
                    if (deltaX > 5 || deltaY > 5) {
                        console.log(`üîÑ Starting drag for ${unitName} (moved ${deltaX}, ${deltaY})`);
                        isDragging = true;
                        createDragClone(touch.clientX, touch.clientY);
                    } else {
                        // Still within click threshold, don't do anything
                        return;
                    }
                }
                
                // Update drag clone position if we're dragging
                if (!isDragging || !dragClone) return;
                
                dragClone.style.left = (touch.clientX - 24) + 'px';
                dragClone.style.top = (touch.clientY - 24) + 'px';
                
                // Check if mouse is over game canvas and show/hide grid highlights
                const gameCanvas = document.querySelector('#phaser-game canvas');
                if (gameCanvas && window.gameScene) {
                    const rect = gameCanvas.getBoundingClientRect();
                    const isOverCanvas = touch.clientX >= rect.left && touch.clientX <= rect.right && 
                                        touch.clientY >= rect.top && touch.clientY <= rect.bottom;
                    
                    if (isOverCanvas) {
                        // Show grid preview when over canvas
                        const localX = touch.clientX - rect.left;
                        const localY = touch.clientY - rect.top;
                        if (window.gameScene.showDropZonePreview) {
                            window.gameScene.showDropZonePreview(localX, localY, window.gameScene.currentPlayerId);
                        }
                    } else {
                        // Clear grid preview when off canvas
                        if (window.gameScene.clearDropZonePreview) {
                            window.gameScene.clearDropZonePreview();
                        }
                    }
                }
            }
            
            function endDrag(e) {
                console.log(`üîª End drag/click for ${unitName}. isDragging: ${isDragging}, isMouseDown: ${isMouseDown}`);
                
                // Always clean up event listeners
                document.removeEventListener('mousemove', handleDrag);
                document.removeEventListener('mouseup', endDrag);
                document.removeEventListener('touchmove', handleDrag);
                document.removeEventListener('touchend', endDrag);
                
                // Handle simple click case (no drag occurred)
                if (isMouseDown && !isDragging) {
                    console.log(`üëÜ Simple click detected on ${unitName} - no purchase will occur`);
                    isMouseDown = false;
                    return; // Exit early - no purchase for clicks
                }
                
                // Only proceed if we were actually dragging
                if (!isDragging) {
                    isMouseDown = false;
                    return;
                }
                
                const touch = e.changedTouches ? e.changedTouches[0] : e;
                const dropX = touch.clientX;
                const dropY = touch.clientY;
                
                
                // Check if dropped on the Phaser game canvas
                const gameCanvas = document.querySelector('#phaser-game canvas');
                if (gameCanvas) {
                    const rect = gameCanvas.getBoundingClientRect();
                    console.log(`Drop coordinates: (${dropX}, ${dropY}), Canvas rect:`, rect);
                    
                    // More strict bounds checking - ensure drop is well within the canvas
                    const margin = 5; // 5px margin to ensure we're actually over the canvas
                    if (dropX >= (rect.left + margin) && dropX <= (rect.right - margin) && 
                        dropY >= (rect.top + margin) && dropY <= (rect.bottom - margin)) {
                        
                        // Calculate grid position
                        const localX = dropX - rect.left;
                        const localY = dropY - rect.top;
                        console.log(`Local coordinates: (${localX}, ${localY})`);
                        
                        if (window.gameScene && window.gameScene.worldToGrid) {
                            const gridPos = window.gameScene.worldToGrid(localX, localY);
                            const gridWidth = window.gameScene.gridWidth || 20;
                            const gridHeight = window.gameScene.gridHeight || 8;
                            
                            console.log(`Grid position: (${gridPos.x}, ${gridPos.y}), Grid size: ${gridWidth}x${gridHeight}`);
                            
                            // Ensure we have valid, integer grid coordinates
                            if (Number.isInteger(gridPos.x) && Number.isInteger(gridPos.y) &&
                                gridPos.x >= 0 && gridPos.x < gridWidth && 
                                gridPos.y >= 0 && gridPos.y < gridHeight) {
                                
                                // Additional check: make sure we're actually over the grid area
                                const gridBounds = window.gameScene.getGridBounds ? window.gameScene.getGridBounds() : null;
                                if (!gridBounds || (localX >= gridBounds.left && localX <= gridBounds.right && 
                                                   localY >= gridBounds.top && localY <= gridBounds.bottom)) {
                                    console.log(`Valid position! Placing ${unitName} at grid position:`, gridPos);
                                    purchaseAndPlaceUnit(unitName, gridPos);
                                } else {
                                    console.log(`Drop outside grid area bounds`);
                                }
                            } else {
                                console.log(`Invalid grid position: (${gridPos.x}, ${gridPos.y})`);
                            }
                        } else {
                            console.error('gameScene or worldToGrid not available');
                        }
                    } else {
                        console.log('Drop outside canvas bounds (with margin)');
                    }
                } else {
                    console.error('Game canvas not found!');
                }
                
                // Clear any remaining grid highlights
                if (window.gameScene && window.gameScene.clearDropZonePreview) {
                    window.gameScene.clearDropZonePreview();
                }
                
                // Cleanup
                if (dragClone) {
                    document.body.removeChild(dragClone);
                    dragClone = null;
                }
                
                element.classList.remove('dragging');
                isDragging = false;
                isMouseDown = false;
                
                // Event listeners already removed at start of function
            }
        }
        
        // Game actions
        function setReady() {
            console.log('setReady clicked, socket:', !!socket);
            if (socket && socket.connected) {
                socket.emit('setReady');
                console.log('Emitted setReady event');
            } else {
                console.error('No socket connection!');
            }
        }
        
        
        function purchaseAndPlaceUnit(unitType, position) {
            console.log(`Purchasing and placing ${unitType} at`, position);
            console.log('Current playerId:', playerId);
            console.log('Current socket.id:', socket?.id);
            
            // Ensure unitType is lowercase
            unitType = unitType.toLowerCase();
            
            // Check if we have a valid playerId
            if (!playerId) {
                console.error('No player ID! Not in a match yet.');
                // Try to set it from socket.id as fallback
                if (socket && socket.id) {
                    playerId = socket.id;
                    console.log('Emergency fallback: set playerId to socket.id:', playerId);
                } else {
                    alert('You must join a match first!');
                    return;
                }
            }
            
            // Check if socket is connected
            if (!socket || !socket.connected) {
                console.error('Socket not connected! Cannot purchase unit.');
                alert('Connection lost! Please refresh the page.');
                return;
            }
            
            // Try to find unit data from game state first (has server costs), then fall back to local data
            let unitData = null;
            let unitCost = 0;
            
            if (gameState && gameState.shopUnits) {
                const shopUnit = gameState.shopUnits.find(u => u.name.toLowerCase() === unitType);
                if (shopUnit) {
                    unitData = shopUnit;
                    unitCost = shopUnit.cost;
                    console.log(`Found unit in shop with cost ${unitCost}`);
                }
            }
            
            // Fallback to local unit data
            if (!unitData) {
                unitData = AVAILABLE_UNITS[unitType];
                if (unitData) {
                    unitCost = unitData.cost;
                    console.log(`Using local unit data with cost ${unitCost}`);
                }
            }
            
            if (!unitData) {
                console.error(`Unit data not found for ${unitType}`);
                return;
            }
            
            const currentGold = parseInt(document.getElementById('gold-amount').textContent);
            if (currentGold < unitCost) {
                console.warn(`Not enough gold! Need ${unitCost}, have ${currentGold}`);
                return;
            }
            
            // Send to server - the server will handle validation, gold deduction, and unit placement
            console.log('Sending to server: purchaseAndPlaceUnit', { unitType, position });
            socket.emit('purchaseAndPlaceUnit', { unitType, position });
            console.log('Purchase request sent to server, waiting for game state update...');
        }
        
        // Initialize Phaser game
        function initPhaser() {
            const config = {
                type: Phaser.AUTO,
                parent: 'phaser-game',
                width: window.innerWidth,
                height: window.innerHeight,
                scale: {
                    mode: Phaser.Scale.RESIZE,
                    autoCenter: Phaser.Scale.CENTER_BOTH,
                },
                backgroundColor: '#1a1a2e',
                scene: {
                    preload: preload,
                    create: create,
                    update: update
                }
            };
            
            game = new Phaser.Game(config);
        }
        
        // Store animations for each unit
        const animationsStore = {};

        // Unit list from our game
        const unitList = ["knight", "priest", "fighter", "wizard", "goblin"];

        function preload() {
            console.log('Preloading assets...');
            
            // Load assets
            this.load.setBaseURL('/assets/');
            
            // Load backgrounds
            this.load.image('battle1', 'backgrounds/battle1.png');
            this.load.image('battle2', 'backgrounds/battle2.png');
            this.load.image('battle3', 'backgrounds/battle3.png');
            this.load.image('battle4', 'backgrounds/battle4.png');
            
            // Load unit atlases with simplified approach
            unitList.forEach(unit => {
                console.log(`Loading atlas for ${unit}`);
                this.load.atlas(
                    unit,
                    `units/${unit}/${unit}.png`,
                    `units/${unit}/${unit}.json`
                );
                
                // Load sound (optional)
                this.load.audio(`${unit}Sound`, `units/${unit}/${unit}Sound.mp3`);
            });
        }
        
        function create() {
            console.log('Create function called');
            
            // Store scene reference for resize handling
            window.gameScene = this;
            
            // Set up the game scene
            this.cameras.main.setBackgroundColor('#1a1a2e');
            
            // Add mouse leave event to clear drop zone previews
            this.game.canvas.addEventListener('mouseleave', () => {
                console.log('üñ±Ô∏è Mouse left game canvas, clearing drop zone previews');
                if (this.clearDropZonePreview) {
                    this.clearDropZonePreview();
                    console.log('‚úÖ Drop zone preview cleared on mouse leave');
                } else {
                    console.log('‚ùå clearDropZonePreview method not available');
                }
            });
            
            // Also add mouseleave to the entire phaser game container to catch UI overlays
            const phaserGameDiv = document.getElementById('phaser-game');
            if (phaserGameDiv) {
                phaserGameDiv.addEventListener('mouseleave', () => {
                    console.log('üñ±Ô∏è Mouse left entire game area, clearing drop zone previews');
                    if (this.clearDropZonePreview) {
                        this.clearDropZonePreview();
                        console.log('‚úÖ Drop zone preview cleared on game area leave');
                    }
                });
            }
            
            // Create grid first - wider and shorter to avoid UI overlap
            this.gridGraphics = this.add.graphics();
            this.gridWidth = 20;
            this.gridHeight = 8;
            this.gridSize = 12; // Keep for backwards compatibility
            this.drawGrid();
            this.gridGraphics.setVisible(true);
            
            // Initialize containers for tracking sprites
            this.unitSprites = [];
            this.combatUnits = {};
            this.unitPreviews = {};
            this.battleBackground = null;
            this.preparationBackground = null;
            
            // Fix TexturePacker atlases before creating animations
            console.log('Fixing texture atlases...');
            unitList.forEach(unit => {
                fixTextureAtlas(this, unit);
            });
            
            // Create animations for all loaded units
            console.log('Creating animations for all units...');
            unitList.forEach(unit => {
                if (this.textures.exists(unit)) {
                    console.log(`Creating animations for ${unit}`);
                    createAnimationsForUnit(this, unit);
                } else {
                    console.error(`Texture ${unit} not found!`);
                }
            });
            
            // Debug: Test creating a unit sprite to verify assets are working
            this.testUnitRendering();
            
            // Create unit previews after animations are set up
            setTimeout(() => {
                console.log('Creating unit previews...');
                this.createUnitPreviews();
            }, 500);
        }
        
        Phaser.Scene.prototype.testUnitRendering = function() {
            console.log('Testing unit rendering...');
            
            // Try to create a test sprite for debugging
            if (this.textures.exists('knight')) {
                console.log('Knight texture exists, creating test sprite');
                const testSprite = this.add.sprite(200, 200, 'knight');
                testSprite.setScale(0.5);
                
                // Try to play animation
                const idleAnimKey = 'knight_idle';
                if (this.anims.exists(idleAnimKey)) {
                    testSprite.play(idleAnimKey);
                    console.log('Playing knight idle animation');
                } else {
                    console.log('Knight idle animation not found, using first frame');
                    const frames = this.textures.get('knight').getFrameNames();
                    console.log('Available knight frames:', frames.slice(0, 5));
                    if (frames.length > 0) {
                        testSprite.setFrame(frames[0]);
                    }
                }
                
                // Remove test sprite after 3 seconds
                setTimeout(() => {
                    if (testSprite && testSprite.scene) {
                        testSprite.destroy();
                        console.log('Test sprite removed');
                    }
                }, 3000);
            } else {
                console.error('Knight texture not found! Available textures:', Object.keys(this.textures.list));
            }
        };
        
        /**
         * Fix TexturePacker format atlases
         */
        function fixTextureAtlas(scene, atlasKey) {
            const texture = scene.textures.get(atlasKey);
            if (!texture) return;
            
            // Check if we need to fix the frame names
            const frames = texture.getFrameNames();
            console.log(`Checking ${atlasKey} atlas, found ${frames.length} frames`);
            
            // If we have frames with .png extension, we might need to fix them
            if (frames.length > 0 && frames[0].includes('.png')) {
                console.log(`Fixing frame names for ${atlasKey}`);
                
                // Get the atlas data
                const atlasData = texture.customData;
                if (atlasData && atlasData.textures) {
                    // This is TexturePacker format, already handled by Phaser
                    console.log(`${atlasKey} is already in correct format`);
                }
            }
        }
        
        /**
         * Helper function to create animations for a specific unit.
         * @param {Phaser.Scene} scene - The Phaser scene.
         * @param {string} atlasKey - The unit's atlas key.
         */
        function createAnimationsForUnit(scene, atlasKey) {
            try {
                const textureFrames = scene.textures.get(atlasKey).getFrameNames();
                console.log(`Creating animations for ${atlasKey}, found ${textureFrames.length} frames:`, textureFrames.slice(0, 5));

                // Find different animation frames
                const idleFrames = textureFrames.filter(frame => {
                    return frame.startsWith("Idle_") || frame.toLowerCase().includes("idle");
                });
                
                const walkFrames = textureFrames.filter(frame => {
                    return frame.startsWith("Run_") || //frame.startsWith("Run_") || 
                           frame.toLowerCase().includes("run") //|| frame.toLowerCase().includes("run");
                });
                
                const attackFrames = textureFrames.filter(frame => {
                    return frame.startsWith("Attack_") || frame.toLowerCase().includes("attack");
                });
                
                const deathFrames = textureFrames.filter(frame => {
                    return frame.startsWith("Death_") || frame.startsWith("Die_") || frame.startsWith("Dead_") ||
                           frame.toLowerCase().includes("death") || frame.toLowerCase().includes("die") || frame.toLowerCase().includes("dead_");
                });
                
                console.log(`Found frames for ${atlasKey}: ${idleFrames.length} idle, ${walkFrames.length} walk, ${attackFrames.length} attack, ${deathFrames.length} death`);

                // Create idle animation
                if (idleFrames.length > 0) {
                    const animKey = `${atlasKey}_idle`;
                    if (!scene.anims.exists(animKey)) {
                        scene.anims.create({
                            key: animKey,
                            frames: idleFrames.map(frame => ({ key: atlasKey, frame: frame })),
                            frameRate: 4, // Reduced from 6 to 4 for slower animations
                            repeat: -1,
                        });
                        console.log(`‚úì Created idle animation: ${animKey}`);
                    }
                }
                
                // Create walk animation
                if (walkFrames.length > 0) {
                    const animKey = `${atlasKey}_walk`;
                    if (!scene.anims.exists(animKey)) {
                        scene.anims.create({
                            key: animKey,
                            frames: walkFrames.map(frame => ({ key: atlasKey, frame: frame })),
                            frameRate: 7.5, // Increased from 6 to 7.5 (25% faster)
                            repeat: -1,
                        });
                        console.log(`‚úì Created walk animation: ${animKey}`);
                    }
                } else if (idleFrames.length > 0) {
                    // Fallback: use idle frames for walking if no walk frames
                    const animKey = `${atlasKey}_walk`;
                    if (!scene.anims.exists(animKey)) {
                        scene.anims.create({
                            key: animKey,
                            frames: idleFrames.map(frame => ({ key: atlasKey, frame: frame })),
                            frameRate: 7.5, // Increased from 6 to 7.5 (25% faster)
                            repeat: -1,
                        });
                        console.log(`‚úì Created walk animation (using idle frames): ${animKey}`);
                    }
                }
                
                // Create attack animation
                if (attackFrames.length > 0) {
                    const animKey = `${atlasKey}_attack`;
                    if (!scene.anims.exists(animKey)) {
                        scene.anims.create({
                            key: animKey,
                            frames: attackFrames.map(frame => ({ key: atlasKey, frame: frame })),
                            frameRate: 8, // Reduced from 10 to 8 for slower animations
                            repeat: 0, // Play once
                        });
                        console.log(`‚úì Created attack animation: ${animKey}`);
                    }
                } else if (idleFrames.length > 0) {
                    // Fallback: use idle frames for attacking if no attack frames
                    const animKey = `${atlasKey}_attack`;
                    if (!scene.anims.exists(animKey)) {
                        scene.anims.create({
                            key: animKey,
                            frames: idleFrames.map(frame => ({ key: atlasKey, frame: frame })),
                            frameRate: 8, // Reduced from 12 to 8 for slower animations
                            repeat: 0,
                        });
                        console.log(`‚úì Created attack animation (using idle frames): ${animKey}`);
                    }
                }
                
                // Create death animation
                if (deathFrames.length > 0) {
                    const animKey = `${atlasKey}_death`;
                    if (!scene.anims.exists(animKey)) {
                        scene.anims.create({
                            key: animKey,
                            frames: deathFrames.map(frame => ({ key: atlasKey, frame: frame })),
                            frameRate: 6, // Reduced from 8 to 6 for slower animations
                            repeat: 0, // Play once and stop on last frame
                        });
                        console.log(`‚úì Created death animation: ${animKey}`);
                    }
                } else if (idleFrames.length > 0) {
                    // Fallback: use idle frames for death if no death frames
                    const animKey = `${atlasKey}_death`;
                    if (!scene.anims.exists(animKey)) {
                        scene.anims.create({
                            key: animKey,
                            frames: [idleFrames[idleFrames.length - 1]].map(frame => ({ key: atlasKey, frame: frame })),
                            frameRate: 1,
                            repeat: 0,
                        });
                        console.log(`‚úì Created death animation (using last idle frame): ${animKey}`);
                    }
                }

                // Store the animation references
                animationsStore[atlasKey] = {
                    idle: `${atlasKey}_idle`,
                    walk: `${atlasKey}_walk`,
                    attack: `${atlasKey}_attack`,
                    death: `${atlasKey}_death`
                };

                console.log(`Stored animations for ${atlasKey}:`, animationsStore[atlasKey]);
                
            } catch (error) {
                console.error(`Error creating animations for ${atlasKey}:`, error);
            }
        }

        /**
         * Helper function to add a unit to the scene.
         * @param {Phaser.Scene} scene - The Phaser scene.
         * @param {string} unitName - The unit's name (atlas key).
         * @param {number} x - X position.
         * @param {number} y - Y position.
         */
        function addUnitToScene(scene, unitName, x, y) {
            console.log(`Adding ${unitName} to scene at (${x}, ${y})`);
            
            try {
                // Check if texture exists
                if (!scene.textures.exists(unitName)) {
                    console.error(`Texture ${unitName} does not exist!`);
                    // Create a colored placeholder sprite
                    const graphics = scene.add.graphics();
                    const colors = {
                        knight: 0x4CAF50, priest: 0x2196F3, fighter: 0xFF5722, 
                        wizard: 0x9C27B0, goblin: 0x8BC34A
                    };
                    graphics.fillStyle(colors[unitName] || 0xFF0000);
                    graphics.fillRect(-20, -20, 40, 40);
                    graphics.setPosition(x, y);
                    console.log(`Created placeholder for ${unitName}`);
                    return graphics;
                }
                
                const sprite = scene.add.sprite(x, y, unitName);
                sprite.setScale(0.75);
                
                // Try to play idle animation
                const idleAnimKey = `${unitName}_idle`;
                if (scene.anims.exists(idleAnimKey)) {
                    sprite.play(idleAnimKey);
                    console.log(`‚úì Playing ${idleAnimKey} animation`);
                } else {
                    console.warn(`Animation ${idleAnimKey} not found, trying first frame`);
                    const texture = scene.textures.get(unitName);
                    const frames = texture.getFrameNames();
                    console.log(`Available frames for ${unitName}:`, frames.slice(0, 3));
                    
                    if (frames.length > 0) {
                        sprite.setFrame(frames[0]);
                        console.log(`Set ${unitName} to frame: ${frames[0]}`);
                    }
                }
                
                // Make sprite more visible for debugging
                sprite.setDepth(10);
                console.log(`‚úì Successfully created sprite for ${unitName} at (${x}, ${y})`);
                
                return sprite;
                
            } catch (error) {
                console.error(`Error adding ${unitName} to scene:`, error);
                
                // Create emergency fallback sprite
                const graphics = scene.add.graphics();
                graphics.fillStyle(0xFF0000);
                graphics.fillRect(-15, -15, 30, 30);
                graphics.setPosition(x, y);
                console.log(`Created emergency fallback for ${unitName}`);
                return graphics;
            }
        }
        
        Phaser.Scene.prototype.createUnitPreviews = function() {
            console.log('Creating unit previews...');
            
            // Store sprites globally for HTML access
            window.unitPreviewSprites = window.unitPreviewSprites || {};
            
            unitList.forEach((unit, index) => {
                if (this.textures.exists(unit)) {
                    console.log(`Creating preview sprite for ${unit}`);
                    
                    // Create sprite off-screen for canvas rendering only
                    const sprite = addUnitToScene(this, unit, -1000, -1000); // Position off-screen
                    if (sprite) {
                        sprite.setScale(0.75); // Normal scale
                        sprite.setVisible(false); // Keep invisible - only for canvas rendering
                        
                        // Store sprite globally for HTML canvas rendering
                        window.unitPreviewSprites[unit] = sprite;
                        this.unitPreviews[unit] = sprite;
                        
                        console.log(`‚úì Created off-screen preview for ${unit}`);
                    }
                } else {
                    console.error(`‚ùå Texture ${unit} does not exist!`);
                }
            });
            
            // Force canvas updates with multiple attempts
            for (let i = 1; i <= 3; i++) {
                setTimeout(() => {
                    this.updateUnitCanvases();
                    console.log(`Canvas update attempt ${i}`);
                }, i * 200);
            }
        };
        
        Phaser.Scene.prototype.updateUnitCanvases = function() {
            if (!window.unitPreviewSprites) return;
            
            Object.entries(window.unitPreviewSprites).forEach(([unitName, sprite]) => {
                // Find all canvas elements for this unit
                const canvases = document.querySelectorAll(`[data-unit="${unitName}"]`);
                canvases.forEach(canvas => {
                    if (canvas.tagName === 'CANVAS') {
                        const ctx = canvas.getContext('2d');
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        // Get current frame from Phaser sprite
                        if (sprite && sprite.texture && sprite.frame) {
                            const frame = sprite.frame;
                            const texture = sprite.texture.getSourceImage();
                            
                            try {
                                // Draw the current frame with proper scaling
                                const sourceX = frame.cutX || frame.x || 0;
                                const sourceY = frame.cutY || frame.y || 0;
                                const sourceWidth = frame.cutWidth || frame.width || frame.realWidth || 50;
                                const sourceHeight = frame.cutHeight || frame.height || frame.realHeight || 50;
                                
                                ctx.drawImage(
                                    texture,
                                    sourceX, sourceY, sourceWidth, sourceHeight,
                                    0, 0, canvas.width, canvas.height
                                );
                                
                                // Debug: add a border to show canvas is working
                                ctx.strokeStyle = '#00ff00';
                                ctx.lineWidth = 1;
                                ctx.strokeRect(0, 0, canvas.width, canvas.height);
                                
                            } catch (e) {
                                console.warn(`Failed to draw ${unitName}:`, e);
                                // Fallback: draw colored rectangle with unit name
                                const colors = {
                                    knight: '#4CAF50', priest: '#2196F3', fighter: '#FF5722', 
                                    wizard: '#9C27B0', goblin: '#8BC34A'
                                };
                                ctx.fillStyle = colors[unitName] || '#666';
                                ctx.fillRect(0, 0, canvas.width, canvas.height);
                                ctx.fillStyle = '#fff';
                                ctx.font = '10px Arial';
                                ctx.textAlign = 'center';
                                ctx.fillText(unitName.toUpperCase(), canvas.width/2, canvas.height/2);
                            }
                        } else {
                            // No sprite/frame available, draw colored placeholder
                            const colors = {
                                knight: '#4CAF50', priest: '#2196F3', fighter: '#FF5722', 
                                wizard: '#9C27B0', goblin: '#8BC34A'
                            };
                            ctx.fillStyle = colors[unitName] || '#444';
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                            ctx.fillStyle = '#fff';
                            ctx.font = '10px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText(unitName.toUpperCase(), canvas.width/2, canvas.height/2);
                        }
                    }
                });
            });
        };
        
        Phaser.Scene.prototype.setupGridUnitDrag = function(sprite, unit) {
            console.log(`üîß Setting up DOM-based drag for unit ${unit.name} (ID: ${unit.id})`);
            
            // Store reference to unit data on sprite for easy access
            sprite.unitData = unit;
            
            // Make sprite interactive for click detection only
            sprite.setInteractive();
            
            let dragData = {
                startGridPos: { x: unit.position.x, y: unit.position.y },
                isDragging: false,
                dragClone: null,
                startMouseX: 0,
                startMouseY: 0
            };
            
            // DOM-based drag system similar to shop
            sprite.on('pointerdown', (pointer) => {
                console.log(`üñ±Ô∏è Pointer down on unit ${unit.name}`);
                
                dragData.startMouseX = pointer.x;
                dragData.startMouseY = pointer.y;
                
                // Visual feedback - scale effect
                sprite.setScale(sprite.scaleX * 1.1, sprite.scaleY * 1.1);
                sprite.setDepth(500);
                
                // Convert to DOM coordinates
                const canvasRect = this.game.canvas.getBoundingClientRect();
                const startX = canvasRect.left + pointer.x;
                const startY = canvasRect.top + pointer.y;
                
                // Set up DOM drag handlers
                const handleMouseMove = (e) => {
                    const deltaX = Math.abs(e.clientX - startX);
                    const deltaY = Math.abs(e.clientY - startY);
                    
                    // Start dragging if moved more than 5 pixels
                    if (!dragData.isDragging && (deltaX > 5 || deltaY > 5)) {
                        startDragVisual(e.clientX, e.clientY);
                    }
                    
                    if (dragData.isDragging) {
                        updateDragVisual(e.clientX, e.clientY);
                    }
                };
                
                const handleMouseUp = (e) => {
                    document.removeEventListener('mousemove', handleMouseMove);
                    document.removeEventListener('mouseup', handleMouseUp);
                    
                    if (dragData.isDragging) {
                        endDragVisual(e.clientX, e.clientY);
                    } else {
                        // Simple click - reset scale and handle sell
                        sprite.setScale(sprite.scaleX / 1.1, sprite.scaleY / 1.1);
                        sprite.setDepth(10);
                        console.log(`Simple click on ${unit.name}`);
                    }
                };
                
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
            });
            
            const startDragVisual = (clientX, clientY) => {
                console.log(`üîÑ Starting drag visual for unit ${unit.name}`);
                dragData.isDragging = true;
                
                // Reset sprite scale
                sprite.setScale(sprite.scaleX / 1.1, sprite.scaleY / 1.1);
                
                // Show sell area when dragging placed units
                const sellArea = document.getElementById('sell-area');
                const shopPanel = document.getElementById('shop-panel');
                if (sellArea && shopPanel) {
                    // Calculate sell value (75% of unit cost)
                    const unitStats = window.AVAILABLE_UNITS[unit.name.toLowerCase()];
                    const sellValue = unitStats ? Math.ceil(unitStats.cost * 0.75) : 0;
                    document.getElementById('sell-value').textContent = `Get ${sellValue} gold`;
                    
                    // Hide shop and show sell area
                    shopPanel.classList.remove('active');
                    sellArea.classList.add('active');
                }
                
                // Create drag clone with animated sprite
                console.log(`üì¶ Creating drag clone DOM element at position (${clientX - 40}, ${clientY - 40})`);
                dragData.dragClone = document.createElement('div');
                dragData.dragClone.style.position = 'fixed';
                dragData.dragClone.style.pointerEvents = 'none';
                dragData.dragClone.style.zIndex = '10000';
                dragData.dragClone.style.opacity = '0.9';
                dragData.dragClone.style.width = '80px';
                dragData.dragClone.style.height = '80px';
                dragData.dragClone.style.borderRadius = '12px';
                dragData.dragClone.style.border = '3px solid #FFD700';
                dragData.dragClone.style.background = 'linear-gradient(145deg, rgba(255, 215, 0, 0.3), rgba(255, 215, 0, 0.1))';
                dragData.dragClone.style.backdropFilter = 'blur(4px)';
                dragData.dragClone.style.boxShadow = '0 8px 25px rgba(255, 215, 0, 0.4)';
                dragData.dragClone.style.left = (clientX - 40) + 'px';
                dragData.dragClone.style.top = (clientY - 40) + 'px';
                dragData.dragClone.style.display = 'flex';
                dragData.dragClone.style.alignItems = 'center';
                dragData.dragClone.style.justifyContent = 'center';
                
                // Add a data attribute to help debug
                dragData.dragClone.setAttribute('data-debug', `drag-clone-${unit.name}`);
                console.log(`‚úÖ Drag clone created with all styles applied`);
                
                // Create sprite container for the drag clone
                const spriteContainer = document.createElement('div');
                spriteContainer.style.width = '64px';
                spriteContainer.style.height = '64px';
                spriteContainer.style.position = 'relative';
                spriteContainer.style.overflow = 'visible';
                
                dragData.dragClone.appendChild(spriteContainer);
                document.body.appendChild(dragData.dragClone);
                console.log(`üèóÔ∏è Drag clone added to document body. Total children: ${document.body.children.length}`);
                
                // Draw animated sprite to the drag clone
                console.log(`üé® Creating animated sprite for drag clone: ${unit.name.toLowerCase()}`);
                if (window.gameScene) {
                    console.log(`‚úÖ GameScene available, creating sprite with createAnimatedUnitSprite`);
                    setTimeout(() => {
                        console.log(`üî• Actually calling createAnimatedUnitSprite for ${unit.name.toLowerCase()}`);
                        createAnimatedUnitSprite(spriteContainer, unit.name.toLowerCase(), 64, 64, 300);
                    }, 10);
                } else {
                    console.log(`‚ùå GameScene not available for animated sprite creation`);
                    // Fallback: create a simple colored div to show the drag is working
                    spriteContainer.innerHTML = `<div style="width: 64px; height: 64px; background: #FF6B6B; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 12px;">${unit.name}</div>`;
                }
                
                // Add visual effects to original sprite
                sprite.setTint(0xffff00);
                sprite.setAlpha(0.5);
                
                // Show drop zone preview - convert DOM to canvas coords
                const gameCanvas = document.querySelector('#phaser-game canvas');
                if (gameCanvas) {
                    const canvasRect = gameCanvas.getBoundingClientRect();
                    const canvasX = clientX - canvasRect.left;
                    const canvasY = clientY - canvasRect.top;
                    this.showDropZonePreview(canvasX, canvasY, unit.playerId);
                }
            };
            
            const updateDragVisual = (clientX, clientY) => {
                if (dragData.dragClone) {
                    const newLeft = clientX - 40;
                    const newTop = clientY - 40;
                    dragData.dragClone.style.left = newLeft + 'px';
                    dragData.dragClone.style.top = newTop + 'px';
                    console.log(`üñ±Ô∏è Updating drag position to (${newLeft}, ${newTop})`);
                    
                    // Update drop zone preview - convert DOM to canvas coords
                    const gameCanvas = document.querySelector('#phaser-game canvas');
                    if (gameCanvas) {
                        const canvasRect = gameCanvas.getBoundingClientRect();
                        const canvasX = clientX - canvasRect.left;
                        const canvasY = clientY - canvasRect.top;
                        this.showDropZonePreview(canvasX, canvasY, unit.playerId);
                    }
                }
            };
            
            const endDragVisual = (clientX, clientY) => {
                console.log(`üîª Ending drag for unit ${unit.name}`);
                
                // Clean up drag clone
                if (dragData.dragClone) {
                    console.log(`üßπ Cleaning up drag clone for ${unit.name}`);
                    dragData.dragClone.remove();
                    dragData.dragClone = null;
                } else {
                    console.log(`‚ö†Ô∏è No drag clone to clean up for ${unit.name}`);
                }
                
                // Reset sprite visual
                sprite.clearTint();
                sprite.setAlpha(1);
                sprite.setDepth(10);
                
                // Clear drop zone preview
                this.clearDropZonePreview();
                
                // Hide sell area and restore shop
                const sellArea = document.getElementById('sell-area');
                const shopPanel = document.getElementById('shop-panel');
                if (sellArea && shopPanel) {
                    sellArea.classList.remove('active');
                    shopPanel.classList.add('active');
                }
                
                // Check if dropped on sell area
                const sellAreaElement = document.getElementById('sell-area');
                if (sellAreaElement) {
                    const sellRect = sellAreaElement.getBoundingClientRect();
                    const isOverSellArea = clientX >= sellRect.left && clientX <= sellRect.right &&
                                         clientY >= sellRect.top && clientY <= sellRect.bottom;
                    
                    if (isOverSellArea) {
                        console.log(`üí∞ Selling unit ${unit.name}`);
                        // Send sell request to server
                        if (socket && socket.connected) {
                            socket.emit('sellUnit', unit.id);
                        }
                        dragData.isDragging = false;
                        return;
                    }
                }
                
                // Check if dropped on game canvas
                const gameCanvas = document.querySelector('#phaser-game canvas');
                if (gameCanvas) {
                    const canvasRect = gameCanvas.getBoundingClientRect();
                    const canvasX = clientX - canvasRect.left;
                    const canvasY = clientY - canvasRect.top;
                    
                    // Convert to grid coordinates
                    const gridX = Math.floor((canvasX - this.gridX) / this.cellSize);
                    const gridY = Math.floor((canvasY - this.gridY) / this.cellSize);
                    
                    console.log(`üìç Drop at grid position: (${gridX}, ${gridY})`);
                    
                    // Validate drop
                    if (gridX >= 0 && gridX < this.gridWidth && gridY >= 0 && gridY < this.gridHeight) {
                        const targetCell = gameState?.grid?.[gridY]?.[gridX];
                        const isValidDrop = !targetCell?.occupied || targetCell?.playerId === unit.playerId;
                        
                        if (isValidDrop && (gridX !== unit.position.x || gridY !== unit.position.y)) {
                            console.log(`‚úÖ Valid drop at grid (${gridX}, ${gridY}), sending move request`);
                            if (socket && socket.connected) {
                                socket.emit('moveUnit', unit.id, { x: gridX, y: gridY });
                            }
                        } else {
                            console.log(`‚ùå Invalid drop or same position`);
                        }
                    } else {
                        console.log(`‚ùå Drop outside grid bounds`);
                    }
                }
                
                dragData.isDragging = false;
            };
            
            console.log(`‚úÖ DOM-based drag setup complete for unit ${unit.name}`);
        };
        
        Phaser.Scene.prototype.showSellConfirmation = function(sprite, unit) {
            console.log(`üí∞ Showing sell confirmation for unit ${unit.name}`);
            
            // Check if we're in preparation phase
            if (!gameState || gameState.phase !== 'preparation') {
                console.log(`‚ùå Cannot sell unit - wrong phase: ${gameState?.phase}`);
                return;
            }
            
            // Calculate sell price (75% of purchase price, rounded up)
            const unitCost = AVAILABLE_UNITS[unit.name.toLowerCase()]?.cost || 20;
            const sellPrice = Math.ceil(unitCost * 0.75);
            
            // Store unit reference for confirmation
            window.currentSellUnit = { sprite, unit, sellPrice };
            
            // Update tooltip content
            document.getElementById('sell-tooltip-name').textContent = unit.name.toUpperCase();
            document.getElementById('sell-tooltip-price').textContent = `üí∞ ${sellPrice}`;
            
            // Add sprite to tooltip
            const spriteContainer = document.getElementById('sell-tooltip-sprite');
            spriteContainer.innerHTML = '';
            createAnimatedUnitSprite(spriteContainer, unit.name.toLowerCase(), 60, 60);
            
            // Position tooltip near the clicked unit
            const tooltip = document.getElementById('sell-tooltip');
            const gameCanvas = document.getElementById('game-canvas');
            const canvasRect = gameCanvas.getBoundingClientRect();
            
            // Calculate tooltip position relative to sprite
            const tooltipX = Math.min(canvasRect.left + sprite.x + 50, window.innerWidth - 250);
            const tooltipY = Math.max(canvasRect.top + sprite.y - 100, 10);
            
            tooltip.style.left = `${tooltipX}px`;
            tooltip.style.top = `${tooltipY}px`;
            
            // Show tooltip
            tooltip.classList.remove('hidden');
        };
        
        Phaser.Scene.prototype.snapUnitBack = function(sprite, unit, dragData) {
            // Snap back to original position
            const originalWorldX = this.gridX + (dragData.startGridPos.x * this.cellSize) + (this.cellSize / 2);
            const originalWorldY = this.gridY + (dragData.startGridPos.y * this.cellSize) + (this.cellSize / 2);
            
            sprite.x = originalWorldX;
            sprite.y = originalWorldY;
            
            // Update ownership indicators
            if (sprite.ownershipIndicators) {
                sprite.ownershipIndicators.forEach(indicator => {
                    if (indicator && indicator.setPosition) {
                        indicator.setPosition(originalWorldX, originalWorldY);
                    }
                });
            }
        };
        
        Phaser.Scene.prototype.showDropZonePreview = function(worldX, worldY, playerId) {
            // Calculate grid position
            const gridX = Math.floor((worldX - this.gridX) / this.cellSize);
            const gridY = Math.floor((worldY - this.gridY) / this.cellSize);
            
            // Clear previous preview
            this.clearDropZonePreview();
            
            // Check if position is valid
            if (gridX >= 0 && gridX < this.gridWidth && gridY >= 0 && gridY < this.gridHeight) {
                const targetCell = gameState?.grid?.[gridY]?.[gridX];
                const isValidDrop = !targetCell?.occupied || targetCell?.playerId === playerId;
                
                // Create preview graphics
                if (!this.dropZonePreview) {
                    this.dropZonePreview = this.add.graphics();
                }
                
                this.dropZonePreview.clear();
                this.dropZonePreview.setDepth(5); // Above grid, below units
                
                // Draw preview cell
                const cellWorldX = this.gridX + (gridX * this.cellSize);
                const cellWorldY = this.gridY + (gridY * this.cellSize);
                
                if (isValidDrop) {
                    // Green for valid drop
                    this.dropZonePreview.fillStyle(0x4CAF50, 0.5);
                    this.dropZonePreview.fillRect(cellWorldX, cellWorldY, this.cellSize, this.cellSize);
                    this.dropZonePreview.lineStyle(3, 0x4CAF50, 1);
                    this.dropZonePreview.strokeRect(cellWorldX, cellWorldY, this.cellSize, this.cellSize);
                } else {
                    // Red for invalid drop
                    this.dropZonePreview.fillStyle(0xF44336, 0.5);
                    this.dropZonePreview.fillRect(cellWorldX, cellWorldY, this.cellSize, this.cellSize);
                    this.dropZonePreview.lineStyle(3, 0xF44336, 1);
                    this.dropZonePreview.strokeRect(cellWorldX, cellWorldY, this.cellSize, this.cellSize);
                }
            }
        };
        
        Phaser.Scene.prototype.clearDropZonePreview = function() {
            if (this.dropZonePreview) {
                this.dropZonePreview.clear();
            }
        };
        
        Phaser.Scene.prototype.showPreparationBackground = function(floor) {
            // Remove existing preparation background
            if (this.preparationBackground) {
                this.preparationBackground.destroy();
                this.preparationBackground = null;
            }
            
            // Determine which background to show for next battle
            let backgroundKey = 'battle1';
            if (floor <= 3) {
                backgroundKey = 'battle1';
            } else if (floor <= 6) {
                backgroundKey = 'battle2';
            } else if (floor <= 8) {
                backgroundKey = 'battle3';
            } else {
                backgroundKey = 'battle4';
            }
            
            // Add transparent background preview
            this.preparationBackground = this.add.image(this.cameras.main.centerX, this.cameras.main.centerY, backgroundKey);
            this.preparationBackground.setOrigin(0.5, 0.5);
            this.preparationBackground.setDisplaySize(this.cameras.main.width, this.cameras.main.height);
            this.preparationBackground.setAlpha(0.3); // Make it transparent
            this.preparationBackground.setDepth(-1); // Behind everything except grid
            
            console.log(`Showing preparation background: ${backgroundKey} for floor ${floor}`);
        };
        
        Phaser.Scene.prototype.hidePreparationBackground = function() {
            if (this.preparationBackground) {
                this.preparationBackground.destroy();
                this.preparationBackground = null;
            }
        };
        
        Phaser.Scene.prototype.drawGrid = function() {
            if (!this.gridGraphics) return;
            
            this.gridGraphics.clear();
            
            // Draw grid cell highlights first (behind grid lines)
            this.drawGridHighlights();
            
            this.gridGraphics.lineStyle(2, 0x888888, 0.8); // Make grid more visible
            
            // Use actual grid dimensions
            const gridWidth = this.gridWidth || 20;
            const gridHeight = this.gridHeight || 8;
            
            // Get screen dimensions
            const screenWidth = this.cameras.main.width;
            const screenHeight = this.cameras.main.height;
            
            // Detect if we're in a small screen (mobile/small electron window)
            const isSmallScreen = screenWidth < 768 || screenHeight < 600;
            const isPortrait = screenHeight > screenWidth;
            
            // Calculate responsive grid size with better spacing for UI
            let widthMultiplier = 0.95;
            let heightMultiplier = 0.65;
            let gridOffsetY = 80;
            
            if (isSmallScreen) {
                widthMultiplier = 0.98;
                heightMultiplier = 0.55;
                gridOffsetY = 60;
            }
            
            if (isPortrait) {
                widthMultiplier = 0.98;
                heightMultiplier = 0.45;
                gridOffsetY = 40;
            }
            
            const availableWidth = screenWidth * widthMultiplier;
            const availableHeight = screenHeight * heightMultiplier;
            
            this.cellSize = Math.min(
                availableWidth / gridWidth,
                availableHeight / gridHeight,
                60 // Maximum cell size to prevent grid from being too large
            );
            
            // Minimum cell size for usability
            this.cellSize = Math.max(this.cellSize, 20);
            
            this.gridX = this.cameras.main.centerX - (gridWidth * this.cellSize) / 2;
            // Position grid higher up to avoid shop panel overlap
            this.gridY = this.cameras.main.centerY - (gridHeight * this.cellSize) / 2 - gridOffsetY;
            
            // Ensure grid doesn't go off screen
            const minMargin = 10;
            if (this.gridX < minMargin) {
                this.gridX = minMargin;
            }
            if (this.gridY < minMargin) {
                this.gridY = minMargin;
            }
            
            // Draw grid lines with adaptive thickness
            const lineThickness = isSmallScreen ? 1 : 2;
            this.gridGraphics.lineStyle(lineThickness, 0x888888, 0.8);
            
            for (let i = 0; i <= gridWidth; i++) {
                // Vertical lines
                this.gridGraphics.moveTo(this.gridX + i * this.cellSize, this.gridY);
                this.gridGraphics.lineTo(this.gridX + i * this.cellSize, this.gridY + gridHeight * this.cellSize);
            }
            for (let i = 0; i <= gridHeight; i++) {
                // Horizontal lines
                this.gridGraphics.moveTo(this.gridX, this.gridY + i * this.cellSize);
                this.gridGraphics.lineTo(this.gridX + gridWidth * this.cellSize, this.gridY + i * this.cellSize);
            }
            this.gridGraphics.strokePath();
            
            // Clear any existing highlights before setting up interaction
            highlightedCells.clear();
            
            // Setup grid cell interaction for highlighting
            this.setupGridCellInteraction();
        };
        
        // Track highlighted cells
        let highlightedCells = new Map(); // playerId -> {x, y}
        
        Phaser.Scene.prototype.drawGridHighlights = function() {
            // Draw highlights for each player's hovered cell
            highlightedCells.forEach((cellPos, playerId) => {
                if (cellPos && cellPos.x >= 0 && cellPos.y >= 0) {
                    const playerColor = this.getPlayerColor(playerId);
                    this.gridGraphics.fillStyle(playerColor, 0.3); // Semi-transparent
                    this.gridGraphics.fillRect(
                        this.gridX + (cellPos.x * this.cellSize),
                        this.gridY + (cellPos.y * this.cellSize),
                        this.cellSize,
                        this.cellSize
                    );
                }
            });
        };
        
        Phaser.Scene.prototype.getPlayerColor = function(targetPlayerId) {
            // Always show green for the current player's highlights
            const currentPlayerId = playerId || (socket && socket.id);
            if (targetPlayerId === currentPlayerId) {
                return 0x00ff00; // Always green for current player
            }
            
            // For other players, use distinct colors
            if (gameState && gameState.players) {
                const playerIndex = gameState.players.findIndex(p => p.id === targetPlayerId);
                const colorValues = [0x00ff00, 0xff0000, 0x0000ff, 0xffff00]; // Green, Red, Blue, Yellow
                return colorValues[playerIndex] || 0xff0000; // Default to red for others
            }
            
            return 0xff0000; // Default red for other players
        };
        
        Phaser.Scene.prototype.setupGridCellInteraction = function() {
            // Remove existing interaction zones
            if (this.gridInteractionZones) {
                this.gridInteractionZones.forEach(zone => zone.destroy());
            }
            this.gridInteractionZones = [];
            
            const gridWidth = this.gridWidth || 20;
            const gridHeight = this.gridHeight || 8;
            
            // Create invisible interaction zones for each grid cell
            for (let x = 0; x < gridWidth; x++) {
                for (let y = 0; y < gridHeight; y++) {
                    const zone = this.add.zone(
                        this.gridX + (x * this.cellSize) + (this.cellSize / 2),
                        this.gridY + (y * this.cellSize) + (this.cellSize / 2),
                        this.cellSize,
                        this.cellSize
                    );
                    
                    zone.setInteractive();
                    zone.gridX = x;
                    zone.gridY = y;
                    
                    // Mouse enter - highlight cell
                    zone.on('pointerover', () => {
                        // Use current player ID, not the potentially stale global variable
                        const currentPlayerId = playerId || (socket && socket.id);
                        if (currentPlayerId) {
                            highlightedCells.set(currentPlayerId, { x: x, y: y });
                            this.drawGrid(); // Redraw to show highlight
                        }
                    });
                    
                    // Mouse leave - remove highlight
                    zone.on('pointerout', () => {
                        // Use current player ID, not the potentially stale global variable
                        const currentPlayerId = playerId || (socket && socket.id);
                        if (currentPlayerId) {
                            highlightedCells.delete(currentPlayerId);
                            this.drawGrid(); // Redraw to remove highlight
                        }
                    });
                    
                    this.gridInteractionZones.push(zone);
                }
            }
        };
        
        Phaser.Scene.prototype.worldToGrid = function(x, y) {
            const gridWidth = this.gridWidth || 20;
            const gridHeight = this.gridHeight || 8;
            
            const gridX = Math.floor((x - this.gridX) / this.cellSize);
            const gridY = Math.floor((y - this.gridY) / this.cellSize);
            
            return {
                x: Math.max(0, Math.min(gridX, gridWidth - 1)),
                y: Math.max(0, Math.min(gridY, gridHeight - 1))
            };
        };
        
        Phaser.Scene.prototype.updateGameState = function(state) {
            // Handle game state updates in Phaser
            console.log(`üéØ Phaser updateGameState called - Phase: ${state.phase}`);
            
            if (state.phase === 'combat') {
                console.log(`‚öîÔ∏è Starting combat phase`);
                this.startCombatPhase(state);
            } else if (state.phase === 'preparation') {
                console.log(`üõ†Ô∏è Starting preparation phase and updating UI directly`);
                this.startPreparationPhase(state);
                
                // Handle upgrade button logic directly without calling main updateGameState (avoid infinite loop)
                this.updateUpgradeButton(state);
            } else if (state.phase === 'post-combat') {
                console.log(`üèÜ Post-combat phase - updating visuals and calling main updateGameState for UI`);
                // For post-combat, update the visual state first
                this.updateVisualState(state);
                
                // Then ensure the main updateGameState is called for UI updates (upgrade buttons, timer, etc.)
                console.log(`üìû Calling main updateGameState function for post-combat UI updates`);
                if (window.updateGameState) {
                    window.updateGameState(state);
                } else {
                    console.error(`‚ùå window.updateGameState not available!`);
                }
            } else {
                console.log(`‚ùì Unknown phase: ${state.phase}, defaulting to preparation`);
                this.startPreparationPhase(state);
            }
        };
        
        Phaser.Scene.prototype.updateUpgradeButton = function(state) {
            console.log('üéÅ ===== updateUpgradeButton called =====');
            console.log('üìã Phase:', state.phase);
            console.log('üÜî Current playerId:', playerId);
            
            const currentPlayer = state.players?.find(p => p.id === playerId);
            console.log('üë§ Current player found:', !!currentPlayer);
            if (currentPlayer) {
                console.log('üéÅ Player upgrade cards:', currentPlayer.upgradeCards?.length || 0);
                console.log('üéÅ Upgrade cards detail:', currentPlayer.upgradeCards);
            }
            
            // Remove any existing custom upgrade button
            const existingButton = document.getElementById('custom-upgrade-btn');
            if (existingButton) {
                existingButton.remove();
            }
            
            if ((state.phase === 'preparation' || state.phase === 'post-combat') && currentPlayer && currentPlayer.upgradeCards && currentPlayer.upgradeCards.length > 0) {
                console.log(`‚úÖ ===== CREATING NEW UPGRADE BUTTON =====`);
                
                // Create a completely new button element
                const newButton = document.createElement('button');
                newButton.id = 'custom-upgrade-btn';
                // Count unique upgrade opportunities (not individual cards)
                const upgradeOpportunities = Math.ceil(currentPlayer.upgradeCards.length / 4); // 4 cards = 1 opportunity
                newButton.textContent = `Select Upgrade`;
                
                // Style the button directly with inline styles
                newButton.style.cssText = `
                    position: fixed !important;
                    top: 100px !important;
                    right: 20px !important;
                    background: #FF0000 !important;
                    border: 5px solid #FFFF00 !important;
                    color: white !important;
                    font-size: 18px !important;
                    font-weight: bold !important;
                    padding: 15px 20px !important;
                    border-radius: 10px !important;
                    cursor: pointer !important;
                    z-index: 99999 !important;
                    display: block !important;
                    visibility: visible !important;
                    opacity: 1 !important;
                    box-shadow: 0 0 20px rgba(255, 0, 0, 0.8) !important;
                    animation: upgrade-flash 1s infinite alternate !important;
                `;
                
                // Add click handler
                newButton.onclick = () => {
                    console.log(`üñ±Ô∏è Custom upgrade button clicked!`);
                    const upgradeModal = document.getElementById('upgrade-modal');
                    if (upgradeModal) {
                        upgradeModal.classList.remove('hidden');
                        showUpgradeSelection(currentPlayer.upgradeCards, state.currentFloor, currentPlayer.gold);
                    }
                };
                
                // Add the button to the document body
                document.body.appendChild(newButton);
                
                console.log(`‚úÖ NEW UPGRADE BUTTON CREATED AND ADDED TO DOM`);
                console.log(`üìç Button position: top: 100px, right: 20px`);
                console.log(`üé® Button style: Red background, yellow border, large text`);
                
            } else {
                console.log(`‚ùå ===== NOT SHOWING UPGRADE BUTTON =====`);
                console.log(`üîç Reason analysis:`);
                console.log(`   Phase check: ${(state.phase === 'preparation' || state.phase === 'post-combat') ? 'PASS' : 'FAIL'} (${state.phase})`);
                console.log(`   Player check: ${currentPlayer ? 'PASS' : 'FAIL'}`);
                console.log(`   Cards check: ${currentPlayer?.upgradeCards && currentPlayer.upgradeCards.length > 0 ? 'PASS' : 'FAIL'} (${currentPlayer?.upgradeCards?.length || 0})`);
            }
        };
        
        Phaser.Scene.prototype.updateVisualState = function(state) {
            console.log('=== Updating Visual State ===');
            console.log('Game state:', state);
            console.log('Player ID:', playerId);
            
            // Hide battle background if any
            if (this.battleBackground) {
                this.battleBackground.destroy();
                this.battleBackground = null;
                console.log('Destroyed battle background');
            }
            
            // Show grid during post-combat
            this.gridGraphics.setVisible(true);
            console.log('Grid made visible');
            
            // Clear existing unit sprites
            if (this.unitSprites) {
                console.log(`Destroying ${this.unitSprites.length} existing unit sprites`);
                this.unitSprites.forEach(sprite => {
                    if (sprite) {
                        // Clean up ownership indicators
                        if (sprite.ownershipIndicators) {
                            sprite.ownershipIndicators.forEach(indicator => {
                                if (indicator && indicator.destroy) indicator.destroy();
                            });
                        }
                        if (sprite.destroy) sprite.destroy();
                    }
                });
            }
            this.unitSprites = [];
            
            // Clear existing combat units
            if (this.combatUnits) {
                console.log(`Destroying ${this.combatUnits.length} existing combat units`);
                this.combatUnits.forEach(sprite => {
                    if (sprite && sprite.destroy) sprite.destroy();
                });
            }
            this.combatUnits = [];
            
            // Clear any remaining sprites
            this.children.list.forEach(child => {
                if (child.texture && (child.texture.key.includes('goblin') || child.texture.key.includes('knight') || child.texture.key.includes('wizard'))) {
                    console.log(`Destroying lingering sprite: ${child.texture.key}`);
                    child.destroy();
                }
            });
            
            console.log('Looking for ALL player units...');
            const allUnits = [];
            if (state.players) {
                state.players.forEach(player => {
                    if (player.units) {
                        allUnits.push(...player.units);
                    }
                });
            }
            
            console.log(`Found ${allUnits.length} total units from all players`);
            
            // Render all units for post-combat phase
            const unitsToRender = allUnits.filter(unit => unit.position);
            console.log(`Rendering ${unitsToRender.length} units from all players:`, unitsToRender);
            
            unitsToRender.forEach((unit, index) => {
                console.log(`Processing unit ${index + 1}/${unitsToRender.length}:`, unit);
                const worldPos = this.gridToWorld(unit.position.x, unit.position.y);
                console.log(`Calculated world position: (${worldPos.x}, ${worldPos.y}) from grid (${unit.position.x}, ${unit.position.y})`);
                console.log(`Grid bounds: X=${this.gridOffsetX}, Y=${this.gridOffsetY}, CellSize=${this.cellSize}`);
                
                this.createUnitSprite(unit, worldPos.x, worldPos.y, state.phase);
            });
            
            console.log(`Visual state update complete. Total sprites created: ${unitsToRender.length}`);
        };
        
        Phaser.Scene.prototype.startPreparationPhase = function(state) {
            console.log('=== Starting Preparation Phase ===');
            console.log('Game state:', state);
            console.log('Player ID:', playerId);
            
            // Hide and destroy background during preparation
            if (this.battleBackground) {
                this.battleBackground.destroy();
                this.battleBackground = null;
                console.log('Destroyed battle background');
            }
            
            // Show grid during preparation
            this.gridGraphics.setVisible(true);
            console.log('Grid made visible');
            
            // Clear existing unit sprites
            if (this.unitSprites) {
                console.log(`Destroying ${this.unitSprites.length} existing unit sprites`);
                this.unitSprites.forEach(sprite => {
                    if (sprite) {
                        // Clean up ownership indicators
                        if (sprite.ownershipIndicators) {
                            sprite.ownershipIndicators.forEach(indicator => {
                                if (indicator && indicator.destroy) indicator.destroy();
                            });
                        }
                        if (sprite.destroy) sprite.destroy();
                    }
                });
                this.unitSprites = [];
            }
            
            if (this.combatUnits) {
                const combatCount = Object.keys(this.combatUnits).length;
                console.log(`Destroying ${combatCount} existing combat units`);
                Object.values(this.combatUnits).forEach(unitData => {
                    if (unitData.sprite) {
                        // Clean up ownership indicators
                        if (unitData.sprite.ownershipIndicators) {
                            unitData.sprite.ownershipIndicators.forEach(indicator => {
                                if (indicator && indicator.destroy) indicator.destroy();
                            });
                        }
                        if (unitData.sprite.destroy) unitData.sprite.destroy();
                    }
                    if (unitData.healthBar && unitData.healthBar.container && unitData.healthBar.container.destroy) {
                        unitData.healthBar.container.destroy();
                    }
                });
                this.combatUnits = {};
            }
            
            // Additional cleanup: destroy any remaining sprites that might be lingering
            if (this.children) {
                this.children.list.forEach(child => {
                    // Don't destroy the grid graphics or permanent UI elements
                    if (child !== this.gridGraphics && child.texture && 
                        (child.texture.key.includes('knight') || child.texture.key.includes('priest') || 
                         child.texture.key.includes('fighter') || child.texture.key.includes('wizard') || 
                         child.texture.key.includes('goblin'))) {
                        console.log('Destroying lingering sprite:', child.texture.key);
                        child.destroy();
                    }
                });
            }
            
            // Add ALL player units to the grid during preparation and post-combat
            if (state.players && (state.phase === 'preparation' || state.phase === 'post-combat')) {
                console.log('Looking for ALL player units...');
                
                // Render units from ALL players, not just current player
                const allPlayerUnits = [];
                state.players.forEach(player => {
                    if (player.units && player.units.length > 0) {
                        allPlayerUnits.push(...player.units);
                    }
                });
                
                console.log(`Found ${allPlayerUnits.length} total units from all players`);
                
                if (allPlayerUnits.length > 0) {
                    console.log(`Rendering ${allPlayerUnits.length} units from all players:`, allPlayerUnits);
                    
                    // Ensure grid is properly drawn before positioning units
                    if (!this.gridX || !this.gridY || !this.cellSize) {
                        console.log('Grid not properly initialized, redrawing...');
                        this.drawGrid();
                    }
                    
                    allPlayerUnits.forEach((unit, index) => {
                        console.log(`Processing unit ${index + 1}/${allPlayerUnits.length}:`, unit);
                        
                        if (unit.position) {
                            const worldX = this.gridX + (unit.position.x * this.cellSize) + (this.cellSize / 2);
                            const worldY = this.gridY + (unit.position.y * this.cellSize) + (this.cellSize / 2);
                            
                            console.log(`Calculated world position: (${worldX}, ${worldY}) from grid (${unit.position.x}, ${unit.position.y})`);
                            console.log(`Grid bounds: X=${this.gridX}, Y=${this.gridY}, CellSize=${this.cellSize}`);
                            
                            const unitName = unit.name.toLowerCase();
                            const sprite = addUnitToScene(this, unitName, worldX, worldY);
                            
                            if (sprite) {
                                const scale = Math.min(this.cellSize / 80, 0.8);
                                sprite.setScale(scale);
                                
                                // Add colored border to indicate ownership
                                const color = getPlayerColor(unit.playerId, state.players);
                                
                                // Create border circle around unit
                                const borderGraphics = this.add.graphics();
                                borderGraphics.lineStyle(3, parseInt(color.primary.replace('#', '0x')), 1);
                                borderGraphics.strokeCircle(worldX, worldY, this.cellSize * 0.4);
                                borderGraphics.setDepth(worldY - 1); // Behind unit but visible
                                
                                // Store unit data for tooltip
                                sprite.unitData = unit;
                                sprite.ownerData = state.players.find(p => p.id === unit.playerId);
                                
                                // Make sprite interactive for tooltips with a slightly larger hit area for better responsiveness
                                sprite.setInteractive({ 
                                    useHandCursor: true,
                                    hitArea: new Phaser.Geom.Rectangle(-this.cellSize * 0.6, -this.cellSize * 0.6, this.cellSize * 1.2, this.cellSize * 1.2),
                                    hitAreaCallback: Phaser.Geom.Rectangle.Contains
                                });
                                
                                // Add tooltip handling - use full tooltip during preparation, game tooltip during combat
                                if (state.phase === 'preparation' || state.phase === 'post-combat') {
                                    // Use full detailed tooltip during preparation/post-combat
                                    sprite.on('pointerover', (pointer) => {
                                        const ownerName = sprite.ownerData?.name || 'Unknown';
                                        const tooltipData = {
                                            ...unit,
                                            owner: isOwnUnit ? 'You' : ownerName
                                        };
                                        
                                        // Create fake event for tooltip positioning
                                        const fakeEvent = {
                                            currentTarget: { getBoundingClientRect: () => ({ 
                                                left: worldX, 
                                                top: worldY, 
                                                width: this.cellSize, 
                                                height: this.cellSize,
                                                right: worldX + this.cellSize,
                                                bottom: worldY + this.cellSize
                                            }) },
                                            clientX: this.input.x,
                                            clientY: this.input.y
                                        };
                                        
                                        showTooltip(fakeEvent, unit.name, tooltipData);
                                    });
                                    
                                    sprite.on('pointerout', () => {
                                        hideTooltip();
                                    });
                                } else {
                                    // Use simplified game tooltip during combat
                                    sprite.on('pointerover', () => {
                                        cancelGameTooltipHide(); // Cancel any pending hide
                                        showGameTooltip(unit, sprite.ownerData?.name || 'Unknown', this.input.x, this.input.y);
                                    });
                                    
                                    sprite.on('pointermove', () => {
                                        updateGameTooltipPosition(this.input.x, this.input.y);
                                    });
                                    
                                    sprite.on('pointerout', () => {
                                        hideGameTooltipDelayed(); // Use delayed hide
                                    });
                                }
                                
                                // Store border reference for cleanup
                                if (!sprite.ownershipIndicators) {
                                    sprite.ownershipIndicators = [];
                                }
                                sprite.ownershipIndicators.push(borderGraphics);
                                
                                const isOwnUnit = unit.playerId === playerId;
                                console.log(`${isOwnUnit ? 'üë§ OWN' : 'üë• OTHER'} UNIT: ${unitName} (Player: ${unit.playerId}, Color: ${color.primary})`);
                                
                                // Add drag functionality for own units only
                                console.log(`Unit ${unitName}: isOwnUnit=${isOwnUnit}, phase=${state.phase}, playerId=${unit.playerId}, currentPlayer=${playerId}`);
                                if (isOwnUnit) {
                                    // Allow drag in preparation phase and post-combat phase
                                    if (state.phase === 'preparation' || state.phase === 'post-combat') {
                                        console.log(`‚úÖ Setting up drag for unit ${unitName} (ID: ${unit.id}) in phase: ${state.phase}`);
                                        this.setupGridUnitDrag(sprite, unit);
                                    } else {
                                        console.log(`‚è∏Ô∏è Unit ${unitName} owned but cannot drag - wrong phase: ${state.phase}`);
                                        // Still make it clickable for future features (like selling)
                                        sprite.setInteractive();
                                        sprite.on('pointerdown', () => {
                                            console.log(`üñ±Ô∏è Click on unit ${unitName} in phase ${state.phase}`);
                                        });
                                    }
                                } else {
                                    console.log(`‚ùå Cannot drag unit ${unitName} - not owned by player (owner: ${unit.playerId})`);
                                }
                                
                                // Tooltip functionality is already handled above
                                
                                this.unitSprites.push(sprite);
                                console.log(`‚úì SUCCESS: Placed ${unitName} at grid (${unit.position.x}, ${unit.position.y}) world (${worldX}, ${worldY})`);
                            } else {
                                console.error(`‚ùå FAILED: Could not create sprite for ${unitName}`);
                            }
                        } else {
                            console.warn(`Unit ${unit.name} has no position:`, unit);
                        }
                    });
                    
                    console.log(`Preparation phase complete. Total sprites created: ${this.unitSprites.length}`);
                } else {
                    console.log('No units to render - player has no units or units array is empty');
                }
            } else {
                console.log('No players found in state or not in preparation phase');
            }
        };
        
        Phaser.Scene.prototype.startCombatPhase = function(state) {
            console.log('=== Starting Combat Phase ===');
            console.log('Game state:', state);
            console.log('Current floor:', state.currentFloor);
            
            // Hide grid during combat
            this.gridGraphics.setVisible(false);
            console.log('Grid hidden for combat');
            
            // Show battle background based on floor
            this.setBattleBackground(state.currentFloor);
            
            // Clear existing unit sprites from preparation
            if (this.unitSprites && this.unitSprites.length > 0) {
                console.log(`Clearing ${this.unitSprites.length} preparation sprites`);
                this.unitSprites.forEach(sprite => {
                    if (sprite) {
                        // Clean up ownership indicators before destroying sprite
                        if (sprite.ownershipIndicators) {
                            sprite.ownershipIndicators.forEach(indicator => {
                                if (indicator && indicator.destroy) indicator.destroy();
                            });
                        }
                        if (sprite.destroy) sprite.destroy();
                    }
                });
                this.unitSprites = [];
            }
            
            // Initialize combat units container
            if (!this.combatUnits) {
                this.combatUnits = {};
            }
            
            let totalPlayerUnits = 0;
            let totalEnemyUnits = 0;
            
            // Add all player units to combat scene
            if (state.players) {
                console.log(`Processing ${state.players.length} players for combat`);
                state.players.forEach((player, playerIndex) => {
                    console.log(`Player ${playerIndex + 1}:`, player);
                    if (player.units && player.units.length > 0) {
                        console.log(`Adding ${player.units.length} units for player ${player.name}`);
                        player.units.forEach((unit, unitIndex) => {
                            console.log(`  Unit ${unitIndex + 1}: ${unit.name} at position`, unit.position, 'status:', unit.status);
                            if (unit.position) { // Add all units with position, including dead ones
                                this.addUnitToCombat(unit, false); // false = not enemy
                                if (unit.status !== 'dead') totalPlayerUnits++;
                            }
                        });
                    }
                });
            }
            
            // Add enemy units to combat scene
            if (state.enemyUnits && state.enemyUnits.length > 0) {
                console.log(`Adding ${state.enemyUnits.length} enemy units to combat`);
                state.enemyUnits.forEach((unit, index) => {
                    console.log(`  Enemy ${index + 1}: ${unit.name} at position`, unit.position, 'status:', unit.status);
                    if (unit.position) { // Add all units with position, including dead ones
                        this.addUnitToCombat(unit, true); // true = enemy
                        if (unit.status !== 'dead') totalEnemyUnits++;
                    }
                });
            } else {
                console.log('No enemy units found in game state');
            }
            
            console.log(`Combat phase setup complete: ${totalPlayerUnits} player units, ${totalEnemyUnits} enemy units`);
            console.log('Total combat sprites:', Object.keys(this.combatUnits).length);
        };
        
        Phaser.Scene.prototype.setBattleBackground = function(floor) {
            // Determine which background to use based on floor
            let backgroundKey;
            if (floor <= 3) {
                backgroundKey = 'battle1';
            } else if (floor <= 6) {
                backgroundKey = 'battle2';
            } else if (floor <= 8) {
                backgroundKey = 'battle3';
            } else {
                backgroundKey = 'battle4';
            }
            
            // Remove existing background
            if (this.battleBackground) {
                this.battleBackground.destroy();
            }
            
            // Add new background
            this.battleBackground = this.add.image(this.cameras.main.centerX, this.cameras.main.centerY, backgroundKey);
            this.battleBackground.setDisplaySize(this.cameras.main.width, this.cameras.main.height);
            this.battleBackground.setDepth(-1); // Behind everything else
            console.log(`Set battle background: ${backgroundKey} for floor ${floor}`);
        };
        
        Phaser.Scene.prototype.addUnitToCombat = function(unit, isEnemy) {
            if (this.combatUnits[unit.id]) {
                // Unit already exists, just update position and health bar
                const unitData = this.combatUnits[unit.id];
                const worldPos = this.getBattlePosition(unit.position);
                unitData.sprite.setPosition(worldPos.x, worldPos.y);
                
                // No ownership circles in combat - using health bar colors instead
                
                this.updateHealthBar(unitData, unit);
                return;
            }
            
            // Create new unit sprite
            const worldPos = this.getBattlePosition(unit.position);
            
            const unitName = unit.name.toLowerCase();
            const sprite = addUnitToScene(this, unitName, worldPos.x, worldPos.y);
            
            if (sprite) {
                const scale = Math.min(this.cellSize / 80, 0.8); // Slightly larger in combat
                sprite.setScale(scale);
                
                // Handle coloring for enemies vs players
                if (isEnemy) {
                    // Tint enemies red
                    sprite.setTint(0xff8888);
                } else {
                    // During combat, we don't show ownership circles
                    // Player ownership will be indicated by health bar colors instead
                }
                
                // Create health bar with enemy/friendly distinction and player color
                const healthBar = this.createHealthBar(worldPos.x, worldPos.y - 25, isEnemy, unit.playerId);
                
                // Store unit data
                this.combatUnits[unit.id] = {
                    sprite: sprite,
                    healthBar: healthBar,
                    maxHealth: unit.maxHealth
                };
                
                // Update health bar
                this.updateHealthBar(this.combatUnits[unit.id], unit);
                
                console.log(`Added ${isEnemy ? 'enemy' : 'player'} unit ${unitName} to combat at (${unit.position.x}, ${unit.position.y})`);
            } else {
                console.error(`Failed to create combat sprite for ${unitName}`);
            }
        };
        
        Phaser.Scene.prototype.getBattlePosition = function(gridPosition) {
            // Shift the battle area down so the bottom row aligns with screen bottom
            const gridBottom = this.cameras.main.height - 50; // Leave 50px margin
            const battleGridHeight = this.gridHeight * this.cellSize;
            const battleGridY = gridBottom - battleGridHeight;
            
            const worldX = this.gridX + (gridPosition.x * this.cellSize) + (this.cellSize / 2);
            const worldY = battleGridY + (gridPosition.y * this.cellSize) + (this.cellSize / 2);
            
            return { x: worldX, y: worldY };
        };
        
        Phaser.Scene.prototype.createHealthBar = function(x, y, isEnemy = false, playerId = null) {
            const barWidth = 50;
            const barHeight = 8;
            
            // Create container for the health bar
            const container = this.add.container(x, y);
            
            // Semi-transparent black background for visibility
            const background = this.add.graphics();
            background.fillStyle(0x000000, 0.6); // Semi-transparent black
            background.fillRoundedRect(-barWidth/2 - 2, -barHeight/2 - 2, barWidth + 4, barHeight + 4, 2);
            container.add(background);
            
            // Health bar border
            const border = this.add.graphics();
            border.lineStyle(1, 0xffffff, 0.8);
            border.strokeRoundedRect(-barWidth/2, -barHeight/2, barWidth, barHeight, 2);
            container.add(border);
            
            // Health bar fill
            const fill = this.add.graphics();
            container.add(fill);
            
            return {
                container: container,
                background: background,
                border: border,
                fill: fill,
                width: barWidth,
                height: barHeight,
                isEnemy: isEnemy,
                playerId: playerId
            };
        };
        
        Phaser.Scene.prototype.updateHealthBar = function(unitData, unit) {
            if (!unitData.healthBar || unit.health == null || !unit.maxHealth) return;
            
            const healthPercent = Math.max(0, Math.min(1, unit.health / unit.maxHealth));
            const fillWidth = unitData.healthBar.width * healthPercent;
            
            // Update health bar position to follow sprite
            const spritePos = { x: unitData.sprite.x, y: unitData.sprite.y - 30 };
            unitData.healthBar.container.setPosition(spritePos.x, spritePos.y);
            
            // Clear and redraw health bar fill with gradient effect
            unitData.healthBar.fill.clear();
            
            if (healthPercent > 0) {
                // Choose colors based on enemy/friendly and health percentage
                let fillColor;
                if (unitData.healthBar.isEnemy) {
                    // Red gradient for enemies
                    if (healthPercent > 0.6) {
                        fillColor = 0xff6666; // Light red
                    } else if (healthPercent > 0.3) {
                        fillColor = 0xff3333; // Medium red
                    } else {
                        fillColor = 0xff0000; // Dark red
                    }
                } else {
                    // Use player color for friendlies
                    let players = [];
                    if (window.gameState && window.gameState.players) {
                        players = window.gameState.players;
                    }
                    const playerColor = getPlayerColor(unitData.healthBar.playerId, players);
                    const baseColor = parseInt(playerColor.primary.replace('#', '0x'));
                    
                    // Create health-based variations of the player color
                    if (healthPercent > 0.6) {
                        fillColor = baseColor; // Full player color
                    } else if (healthPercent > 0.3) {
                        // Darker version for medium health
                        const r = Math.floor(((baseColor >> 16) & 0xFF) * 0.7);
                        const g = Math.floor(((baseColor >> 8) & 0xFF) * 0.7);
                        const b = Math.floor((baseColor & 0xFF) * 0.7);
                        fillColor = (r << 16) | (g << 8) | b;
                    } else {
                        // Even darker for low health
                        const r = Math.floor(((baseColor >> 16) & 0xFF) * 0.5);
                        const g = Math.floor(((baseColor >> 8) & 0xFF) * 0.5);
                        const b = Math.floor((baseColor & 0xFF) * 0.5);
                        fillColor = (r << 16) | (g << 8) | b;
                    }
                }
                
                // Draw the health bar fill with rounded corners
                unitData.healthBar.fill.fillStyle(fillColor);
                unitData.healthBar.fill.fillRoundedRect(
                    -unitData.healthBar.width/2, 
                    -unitData.healthBar.height/2, 
                    fillWidth, 
                    unitData.healthBar.height, 
                    2
                );
            }
        };
        
        Phaser.Scene.prototype.showHealEffect = function(targetUnitId, healAmount) {
            if (!this.combatUnits || !this.combatUnits[targetUnitId]) return;
            
            const unitData = this.combatUnits[targetUnitId];
            if (!unitData.sprite || !unitData.sprite.scene) return;
            
            // Create yellow flash effect
            const flash = this.add.circle(unitData.sprite.x, unitData.sprite.y - 10, 20, 0xFFFF00, 0.8);
            flash.setDepth(unitData.sprite.y + 50);
            
            // Create healing text
            const healText = this.add.text(unitData.sprite.x, unitData.sprite.y - 30, `+${Math.round(healAmount)}`, {
                fontSize: '14px',
                color: '#00FF00',
                stroke: '#000000',
                strokeThickness: 2
            });
            healText.setOrigin(0.5);
            healText.setDepth(unitData.sprite.y + 51);
            
            // Animate the flash and text
            this.tweens.add({
                targets: flash,
                scaleX: 2,
                scaleY: 2,
                alpha: 0,
                duration: 300,
                onComplete: () => {
                    flash.destroy();
                }
            });
            
            this.tweens.add({
                targets: healText,
                y: healText.y - 20,
                alpha: 0,
                duration: 800,
                onComplete: () => {
                    healText.destroy();
                }
            });
            
            // Flash the unit sprite yellow briefly
            const originalTint = unitData.sprite.tint;
            unitData.sprite.setTint(0xFFFF88);
            this.time.delayedCall(200, () => {
                if (unitData.sprite && unitData.sprite.scene) {
                    unitData.sprite.setTint(originalTint);
                }
            });
        };
        
        Phaser.Scene.prototype.createWizardProjectile = function(attackerId, targetId) {
            if (!this.combatUnits || !this.combatUnits[attackerId] || !this.combatUnits[targetId]) return;
            
            const attackerData = this.combatUnits[attackerId];
            const targetData = this.combatUnits[targetId];
            
            if (!attackerData.sprite || !targetData.sprite || !attackerData.sprite.scene) return;
            
            // Check if wizard texture exists and has Magic_arrow_2 frame
            if (!this.textures.exists('wizard')) return;
            
            const wizardTexture = this.textures.get('wizard');
            const frameNames = wizardTexture.getFrameNames();
            const magicArrowFrame = frameNames.find(frame => frame === 'Charge_2_1 #11.png');
            
            if (!magicArrowFrame) return;
            
            // Create projectile sprite
            const projectile = this.add.sprite(attackerData.sprite.x, attackerData.sprite.y - 10, 'wizard', magicArrowFrame);
            projectile.setScale(0.4);
            projectile.setDepth(attackerData.sprite.y + 25);
            
            // Calculate angle to target
            const angle = Phaser.Math.Angle.Between(
                attackerData.sprite.x, attackerData.sprite.y,
                targetData.sprite.x, targetData.sprite.y
            );
            projectile.setRotation(angle);
            
            // Animate projectile to target
            this.tweens.add({
                targets: projectile,
                x: targetData.sprite.x,
                y: targetData.sprite.y - 10,
                duration: 400,
                ease: 'Power2',
                onComplete: () => {
                    // Create impact effect
                    const impact = this.add.circle(targetData.sprite.x, targetData.sprite.y - 10, 15, 0x4488FF, 0.7);
                    impact.setDepth(targetData.sprite.y + 30);
                    
                    this.tweens.add({
                        targets: impact,
                        scaleX: 2,
                        scaleY: 2,
                        alpha: 0,
                        duration: 200,
                        onComplete: () => {
                            impact.destroy();
                        }
                    });
                    
                    projectile.destroy();
                }
            });
        };
        
        Phaser.Scene.prototype.updateCombatState = function(playerUnits, enemyUnits) {
            // Update unit positions during combat
            [...playerUnits, ...enemyUnits].forEach(unit => {
                if (unit.position && this.combatUnits && this.combatUnits[unit.id]) {
                    const unitData = this.combatUnits[unit.id];
                    
                    // Convert grid position to battle world position
                    const worldPos = this.getBattlePosition(unit.position);
                    unitData.sprite.setPosition(worldPos.x, worldPos.y);
                    
                    // Update health bar
                    this.updateHealthBar(unitData, unit);
                    
                    // Update sprite based on unit status
                    if (unit.status === 'dead') {
                        unitData.sprite.setTint(0x666666);
                        unitData.sprite.setAlpha(0.5);
                        // Hide health bar for dead units
                        unitData.healthBar.container.setVisible(false);
                        
                        // Play death animation for dead units
                        const unitName = unit.name.toLowerCase();
                        const deathAnimKey = `${unitName}_death`;
                        
                        if (!unitData.hasPlayedDeath && !unitData.deathAnimationComplete) {
                            // Mark that we've started the death animation
                            unitData.hasPlayedDeath = true;
                            
                            if (this.anims.exists(deathAnimKey)) {
                                console.log(`Playing death animation: ${deathAnimKey} for unit ${unit.id}`);
                                unitData.sprite.play(deathAnimKey);
                                
                                // After death animation completes, remove unit from battlefield immediately
                                unitData.sprite.once('animationcomplete', () => {
                                    console.log(`Death animation complete for unit ${unit.id}, removing from battlefield immediately`);
                                    // Remove the sprite immediately after death animation
                                    if (unitData.sprite && unitData.sprite.scene) {
                                        unitData.sprite.setVisible(false);
                                        unitData.sprite.destroy();
                                    }
                                    if (unitData.healthBar && unitData.healthBar.container && unitData.healthBar.container.scene) {
                                        unitData.healthBar.container.destroy();
                                    }
                                    // Remove from tracking
                                    this.unitSprites = this.unitSprites.filter(s => s !== unitData.sprite);
                                    if (unit && unit.id && this.unitSpriteMap) {
                                        delete this.unitSpriteMap[unit.id];
                                    }
                                });
                            } else {
                                // Fallback: immediately remove if no death animation
                                console.log(`No death animation for ${unitName}, removing immediately`);
                                if (unitData.sprite && unitData.sprite.scene) {
                                    unitData.sprite.setVisible(false);
                                    unitData.sprite.destroy();
                                }
                                if (unitData.healthBar && unitData.healthBar.container && unitData.healthBar.container.scene) {
                                    unitData.healthBar.container.destroy();
                                }
                                this.unitSprites = this.unitSprites.filter(s => s !== unitData.sprite);
                                if (unit && unit.id && this.unitSpriteMap) {
                                    delete this.unitSpriteMap[unit.id];
                                }
                            }
                        }
                    } else {
                        // Show health bar for living units
                        unitData.healthBar.container.setVisible(true);
                        
                        // Determine if enemy or player for coloring
                        const isEnemy = unit.id.startsWith('enemy-');
                        const unitName = unit.name.toLowerCase();
                        
                        // Handle facing direction based on movement
                        if (unit.movementDirection && (unit.movementDirection.x !== 0 || unit.movementDirection.y !== 0)) {
                            // Face the direction of movement
                            if (unit.movementDirection.x > 0) {
                                unitData.sprite.setFlipX(false); // Face right
                            } else if (unit.movementDirection.x < 0) {
                                unitData.sprite.setFlipX(true); // Face left
                            }
                        }
                        
                        // Handle animations and tinting based on status
                        if (unit.status === 'attacking') {
                            // Remove tints from all units - health bar colors are sufficient
                            unitData.sprite.setTint(0xffffff);
                            
                            // Handle facing direction for attacks
                            if (unit.targetId) {
                                // Find the target unit to determine facing direction
                                const allUnits = [...playerUnits, ...enemyUnits];
                                const target = allUnits.find(u => u.id === unit.targetId);
                                if (target && target.position) {
                                    // Calculate direction to target
                                    const dx = target.position.x - unit.position.x;
                                    // Face the target: flip sprite if target is to the left
                                    if (dx < 0) {
                                        unitData.sprite.setFlipX(true); // Face left
                                    } else if (dx > 0) {
                                        unitData.sprite.setFlipX(false); // Face right
                                    }
                                    // If dx === 0 (same x position), keep current facing
                                }
                            }
                            
                            // Play attack animation
                            const attackAnimKey = `${unitName}_attack`;
                            if (this.anims.exists(attackAnimKey)) {
                                if (!unitData.sprite.anims.isPlaying || unitData.sprite.anims.currentAnim.key !== attackAnimKey) {
                                    console.log(`Playing attack animation: ${attackAnimKey} for unit ${unit.id}`);
                                    unitData.sprite.play(attackAnimKey);
                                    
                                    // Chain back to idle after attack
                                    unitData.sprite.once('animationcomplete', () => {
                                        const idleAnimKey = `${unitName}_idle`;
                                        if (this.anims.exists(idleAnimKey)) {
                                            console.log(`Attack complete, playing idle: ${idleAnimKey} for unit ${unit.id}`);
                                            unitData.sprite.play(idleAnimKey);
                                        }
                                    });
                                }
                            } else {
                                console.log(`No attack animation found for ${unitName}, using idle`);
                                // Fallback to idle if no attack animation
                                const idleAnimKey = `${unitName}_idle`;
                                if (this.anims.exists(idleAnimKey)) {
                                    if (!unitData.sprite.anims.isPlaying || unitData.sprite.anims.currentAnim.key !== idleAnimKey) {
                                        unitData.sprite.play(idleAnimKey, true);
                                    }
                                }
                            }
                        } else if (unit.status === 'moving') {
                            unitData.sprite.setTint(0xffffff); // Remove red tint from enemies
                            
                            // Play walk animation
                            const walkAnimKey = `${unitName}_walk`;
                            if (this.anims.exists(walkAnimKey)) {
                                if (!unitData.sprite.anims.isPlaying || unitData.sprite.anims.currentAnim.key !== walkAnimKey) {
                                    unitData.sprite.play(walkAnimKey, true);
                                }
                            } else {
                                // Fallback to idle if no walk animation
                                const idleAnimKey = `${unitName}_idle`;
                                if (this.anims.exists(idleAnimKey)) {
                                    if (!unitData.sprite.anims.isPlaying || unitData.sprite.anims.currentAnim.key !== idleAnimKey) {
                                        unitData.sprite.play(idleAnimKey, true);
                                    }
                                }
                            }
                        } else {
                            unitData.sprite.setTint(0xffffff); // Remove red tint from enemies
                            
                            // Play idle animation
                            const idleAnimKey = `${unitName}_idle`;
                            if (this.anims.exists(idleAnimKey)) {
                                if (!unitData.sprite.anims.isPlaying || unitData.sprite.anims.currentAnim.key !== idleAnimKey) {
                                    unitData.sprite.play(idleAnimKey, true);
                                }
                            }
                        }
                        
                        unitData.sprite.setAlpha(1);
                    }
                }
            });
        };
        
        
        function update() {
            // Update game logic - canvas rendering now handled by individual animated sprites
            // No longer need to update canvas manually since each sprite manages its own animation
        }
        
        // Upgrade system functions
        let selectedUpgrades = new Map(); // Map of upgradeId -> targetUnitType
        
        function closeUpgradeModal() {
            const upgradeModal = document.getElementById('upgrade-modal');
            upgradeModal.classList.add('hidden');
            console.log('üîí Upgrade modal closed');
        }
        
        function showUpgradeUnitTooltip(element, unitType) {
            // Find unit stats from current game state
            let unitStats = null;
            if (gameState && gameState.players) {
                const currentPlayer = gameState.players.find(p => p.id === playerId);
                if (currentPlayer && currentPlayer.units) {
                    const unit = currentPlayer.units.find(u => u.name === unitType && u.status !== 'dead');
                    if (unit) {
                        unitStats = unit;
                    }
                }
            }
            
            // Fallback to default stats if not found
            if (!unitStats && AVAILABLE_UNITS[unitType.toLowerCase()]) {
                unitStats = AVAILABLE_UNITS[unitType.toLowerCase()];
            }
            
            if (!unitStats) return;
            
            const tooltip = document.getElementById('game-tooltip');
            tooltip.innerHTML = `
                <div class="game-tooltip-header">${unitStats.name}</div>
                <div class="game-tooltip-stats">
                    <div>üíö Health: ${unitStats.health}/${unitStats.maxHealth || unitStats.health}</div>
                    <div>‚öîÔ∏è Damage: ${unitStats.damage}</div>
                    <div>üèπ Range: ${unitStats.range}</div>
                    <div>‚ö° Attack Speed: ${unitStats.attackSpeed.toFixed(1)}</div>
                    <div>üèÉ Movement Speed: ${unitStats.movementSpeed}</div>
                    <div>üéØ Priority: ${unitStats.priority}</div>
                    <div>üõ°Ô∏è Armor: ${unitStats.armorType}</div>
                    <div>üí• Attack Type: ${unitStats.attackType}</div>
                    ${unitStats.innatePassive ? `<div class="game-tooltip-passive">üåü ${unitStats.innatePassive}</div>` : ''}
                </div>
            `;
            
            // Position tooltip
            const rect = element.getBoundingClientRect();
            tooltip.style.left = (rect.left + rect.width / 2 - 125) + 'px';
            tooltip.style.top = (rect.top - 10) + 'px';
            tooltip.style.transform = 'translateY(-100%)';
            tooltip.classList.add('show');
        }
        
        function hideUpgradeUnitTooltip() {
            const tooltip = document.getElementById('game-tooltip');
            tooltip.classList.remove('show');
        }
        
        function showUpgradeSelection(upgradeCards, currentFloor, playerGold) {
            console.log('Showing upgrade selection:', upgradeCards);
            
            // Check viewport size and adjust modal if needed for extreme cases only
            const modal = document.getElementById('upgrade-modal');
            const modalContent = modal.querySelector('.unit-selection-content');
            
            // Reset any previously set inline styles to let CSS handle scaling
            modalContent.style.height = '';
            modalContent.style.maxHeight = '';
            
            // Only force sizing for extremely small screens where CSS can't handle it
            if (window.innerHeight < 400) {
                modalContent.style.height = `${Math.max(window.innerHeight - 100, 150)}px`;
                modalContent.style.maxHeight = `${Math.max(window.innerHeight - 100, 150)}px`;
            }
            
            // Clear upgrade selections when showing new upgrades
            upgradeSelections.clear();
            selectedUpgrade = null;
            
            // Hide the global select button initially
            const selectBtn = document.getElementById('select-upgrade-btn');
            selectBtn.classList.add('hidden');
            selectBtn.disabled = true;
            
            // Update floor display
            document.getElementById('upgrade-floor').textContent = currentFloor;
            
            // Clear previous selections
            selectedUpgrades.clear();
            
            // Separate high-potency and normal upgrades
            const highPotencyUpgrades = upgradeCards.filter(u => u.isHighPotency);
            const normalUpgrades = upgradeCards.filter(u => !u.isHighPotency);
            
            // Display high-potency upgrade
            const highPotencyContainer = document.getElementById('high-potency-upgrade');
            highPotencyContainer.innerHTML = '';
            
            if (highPotencyUpgrades.length > 0) {
                const upgrade = highPotencyUpgrades[0];
                const upgradeCard = createUpgradeCard(upgrade, true);
                highPotencyContainer.appendChild(upgradeCard);
            }
            
            // Display normal upgrades
            const normalContainer = document.getElementById('normal-upgrades');
            normalContainer.innerHTML = '';
            
            normalUpgrades.forEach(upgrade => {
                const upgradeCard = createUpgradeCard(upgrade, false);
                normalContainer.appendChild(upgradeCard);
            });
            
            // Initialize unit sprites for all upgrade cards
            setTimeout(() => {
                initializeUpgradeSprites();
            }, 100);
            
            // Update reroll button
            const rerollBtn = document.getElementById('reroll-btn');
            rerollBtn.disabled = playerGold < 10;
            rerollBtn.textContent = `Reroll Upgrades (üí∞ 10)${playerGold < 10 ? ' - Not enough gold' : ''}`;
        }
        
        function createUpgradeCard(upgrade, isHighPotency) {
            const card = document.createElement('div');
            card.className = `upgrade-card ${isHighPotency ? 'high-potency' : ''}`;
            card.setAttribute('data-upgrade-id', upgrade.id);
            
            const effectValue = isHighPotency ? (upgrade.value * 3) : upgrade.value;
            const displayValue = upgrade.effect === 'priority' ? 
                (effectValue > 0 ? `+${effectValue}` : effectValue.toString()) :
                `${Math.round(effectValue * 100)}%`;
            
            let description = upgrade.description;
            if (isHighPotency) {
                // Replace percentages with 3x values
                description = description.replace(/(\d+)%/g, (match, num) => `${parseInt(num) * 3}%`);
                // Replace flat values (like HP/sec) with 3x values  
                description = description.replace(/(\d+)\s*(HP\/sec|damage)/g, (match, num, unit) => `${parseInt(num) * 3} ${unit}`);
                // Replace +/- priority values
                description = description.replace(/([+-])(\d+)\s*Priority/g, (match, sign, num) => `${sign}${parseInt(num) * 3} Priority`);
            }
            
            // Create icon filename from upgrade name
            const iconName = upgrade.name.toLowerCase().replace(/\s+/g, '_');
            const iconPath = `assets/upgradeicons/${iconName}.png`;
            
            card.innerHTML = `
                <div class="upgrade-icon">
                    <img src="${iconPath}" alt="${upgrade.name}" onerror="this.style.display='none'">
                </div>
                <div class="upgrade-name">${upgrade.name}</div>
                <div class="upgrade-description">${description}</div>
                ${isHighPotency ? 
                    `<div class="upgrade-target">Applied to: ${upgrade.targetUnitType}</div>` :
                    '<div class="upgrade-target">Select units to upgrade:</div>'
                }
                ${createUnitTypeSelector(upgrade.id, isHighPotency, upgrade.targetUnitType)}
                <div class="upgrade-actions">
                    <!-- Individual card buttons removed - using global fixed position button -->
                </div>
            `;
            
            // Add click handler to select this upgrade card
            card.addEventListener('click', () => {
                selectUpgradeCard(upgrade, isHighPotency);
            });
            
            return card;
        }
        
        function createUnitTypeSelector(upgradeId, isHighPotency, targetUnitType = null) {
            // Get owned unit types from current game state
            const ownedUnitTypes = new Set();
            if (gameState && gameState.players) {
                const currentPlayer = gameState.players.find(p => p.id === playerId);
                if (currentPlayer && currentPlayer.units) {
                    currentPlayer.units.forEach(unit => {
                        if (unit.status !== 'dead') {
                            ownedUnitTypes.add(unit.name);
                        }
                    });
                }
            }
            
            // Fallback to common unit types if no game state
            if (ownedUnitTypes.size === 0) {
                ['Knight', 'Priest', 'Fighter', 'Wizard', 'Goblin'].forEach(type => ownedUnitTypes.add(type));
            }
            
            const unitTypes = Array.from(ownedUnitTypes);
            
            if (isHighPotency && targetUnitType) {
                // For high potency upgrades, show the target unit sprite
                const unitKey = targetUnitType.toLowerCase();
                return `
                    <div class="unit-type-selector high-potency-target">
                        <div class="unit-selection-sprite selected" 
                             data-unit-type="${targetUnitType}"
                             onmouseenter="showUpgradeUnitTooltip(this, '${targetUnitType}')"
                             onmouseleave="hideUpgradeUnitTooltip()">
                            <div class="unit-sprite-container" id="sprite-${upgradeId}-${unitKey}">
                                <!-- Target unit sprite will be added here -->
                            </div>
                            <div class="unit-selection-name">${targetUnitType}</div>
                        </div>
                    </div>
                `;
            } else {
                // For normal upgrades, show all available unit types as animated sprites
                const unitSprites = unitTypes.map(unitType => {
                    const unitKey = unitType.toLowerCase();
                    return `
                        <div class="unit-selection-sprite" 
                             data-unit-type="${unitType}" 
                             data-upgrade-id="${upgradeId}"
                             onclick="selectUnitForUpgrade('${upgradeId}', '${unitType}')"
                             onmouseenter="showUpgradeUnitTooltip(this, '${unitType}')"
                             onmouseleave="hideUpgradeUnitTooltip()">
                            <div class="unit-sprite-container" id="sprite-${upgradeId}-${unitKey}">
                                <!-- Sprite will be added here by JavaScript -->
                            </div>
                            <div class="unit-selection-name">${unitType}</div>
                        </div>
                    `;
                }).join('');
                
                return `<div class="unit-type-selector unit-sprite-selector">${unitSprites}</div>`;
            }
        }
        
        // Track selected units for each upgrade
        let upgradeSelections = new Map(); // upgradeId -> selectedUnitType
        
        // Track currently selected upgrade for global button
        let selectedUpgrade = null;
        
        function selectUpgradeCard(upgrade, isHighPotency) {
            // Clear previous selection
            document.querySelectorAll('.upgrade-card').forEach(card => {
                card.classList.remove('selected');
            });
            
            // Mark this card as selected
            const card = document.querySelector(`[data-upgrade-id="${upgrade.id}"]`);
            if (card) {
                card.classList.add('selected');
            }
            
            // Store the selected upgrade
            selectedUpgrade = { upgrade, isHighPotency };
            
            // Show the global select button only during preparation phase
            const selectBtn = document.getElementById('select-upgrade-btn');
            if (gameState && gameState.phase === 'preparation') {
                selectBtn.classList.remove('hidden');
                
                // For normal upgrades, check if a unit type is selected
                if (!isHighPotency) {
                    const hasUnitSelection = upgradeSelections.has(upgrade.id);
                    selectBtn.disabled = !hasUnitSelection;
                } else {
                    selectBtn.disabled = false;
                }
            } else {
                selectBtn.classList.add('hidden');
            }
        }
        
        function confirmSelectedUpgrade() {
            console.log('confirmSelectedUpgrade called, selectedUpgrade:', selectedUpgrade);
            if (!selectedUpgrade) {
                console.error('No upgrade selected');
                return;
            }
            
            const { upgrade, isHighPotency } = selectedUpgrade;
            console.log('Processing upgrade:', upgrade.id, 'isHighPotency:', isHighPotency);
            
            if (isHighPotency) {
                confirmUpgrade(upgrade.id, upgrade.targetUnitType);
            } else {
                confirmUpgradeWithSelection(upgrade.id);
            }
        }
        
        function selectUnitForUpgrade(upgradeId, unitType) {
            // Clear selections on all other upgrade cards
            upgradeSelections.forEach((selectedUnit, otherUpgradeId) => {
                if (otherUpgradeId !== upgradeId) {
                    // Clear visual selection
                    document.querySelectorAll(`[data-upgrade-id="${otherUpgradeId}"] .unit-selection-sprite`).forEach(sprite => {
                        sprite.classList.remove('selected');
                    });
                    // Disable confirm button
                    const otherConfirmBtn = document.querySelector(`[data-upgrade-id="${otherUpgradeId}"] .confirm-upgrade-btn`);
                    if (otherConfirmBtn) {
                        otherConfirmBtn.disabled = true;
                    }
                }
            });
            
            // Clear all selections except this one
            upgradeSelections.clear();
            upgradeSelections.set(upgradeId, unitType);
            
            // Update visual selection for this upgrade
            document.querySelectorAll(`[data-upgrade-id="${upgradeId}"] .unit-selection-sprite`).forEach(sprite => {
                sprite.classList.remove('selected');
            });
            
            const selectedSprite = document.querySelector(`[data-upgrade-id="${upgradeId}"][data-unit-type="${unitType}"]`);
            if (selectedSprite) {
                selectedSprite.classList.add('selected');
            }
            
            // Update the global select button if this upgrade is currently selected
            if (selectedUpgrade && selectedUpgrade.upgrade.id === upgradeId) {
                const selectBtn = document.getElementById('select-upgrade-btn');
                selectBtn.disabled = false;
            }
        }
        
        function updateUpgradeSelection(upgradeId) {
            // Legacy function - still needed for radio button compatibility
            const selectedRadio = document.querySelector(`input[name="unit-${upgradeId}"]:checked`);
            const confirmBtn = document.querySelector(`[data-upgrade-id="${upgradeId}"] .confirm-upgrade-btn`);
            
            if (confirmBtn) {
                confirmBtn.disabled = !selectedRadio;
            }
        }
        
        function confirmUpgrade(upgradeId, targetUnitType) {
            console.log(`Confirming high potency upgrade ${upgradeId} for ${targetUnitType}`);
            
            if (socket && socket.connected) {
                console.log('Sending selectUpgrade to server:', { upgradeId, targetUnitType });
                socket.emit('selectUpgrade', upgradeId, targetUnitType);
                // Close the modal after confirming
                console.log('Closing upgrade modal after high potency upgrade');
                closeUpgradeModal();
            } else {
                console.error('Socket not connected, cannot send upgrade selection');
                // Still close modal to prevent stuck interface
                closeUpgradeModal();
            }
        }
        
        function confirmUpgradeWithSelection(upgradeId) {
            // Get the selected unit type from our tracking system
            const selectedType = upgradeSelections.get(upgradeId);
            
            if (!selectedType) {
                console.error('No unit type selected for upgrade:', upgradeId);
                console.log('Available selections:', upgradeSelections);
                // Close modal since user needs to select a unit type first
                return;
            }
            
            console.log(`Confirming upgrade ${upgradeId} for unit type: ${selectedType}`);
            
            // Apply upgrade to the selected unit type
            if (socket && socket.connected) {
                console.log('Sending selectUpgrade to server:', { upgradeId, selectedType });
                socket.emit('selectUpgrade', upgradeId, selectedType);
                // Close the modal after confirming
                console.log('Closing upgrade modal after normal upgrade');
                closeUpgradeModal();
            } else {
                console.error('Socket not connected, cannot send upgrade selection');
                // Still close modal to prevent stuck interface
                closeUpgradeModal();
            }
        }
        
        function initializeUpgradeSprites() {
            // Find all unit sprite containers in upgrade cards
            document.querySelectorAll('.unit-sprite-container').forEach(container => {
                const id = container.id;
                const match = id.match(/sprite-(.+)-(.+)/);
                if (match) {
                    const upgradeId = match[1];
                    const unitKey = match[2];
                    
                    // Create a mini canvas for this unit
                    createUpgradeUnitSprite(container, unitKey);
                }
            });
        }
        
        // Track active animations to prevent duplicates
        const activeAnimations = new Map();
        
        // Universal animated sprite creator - EXACTLY matches grid sprite behavior
        function createAnimatedUnitSprite(container, unitKey, width = 48, height = 48, animSpeed = 100) {
            // Clear any existing animation for this container
            const containerId = container.id || Math.random().toString();
            if (activeAnimations.has(containerId)) {
                const existingAnimation = activeAnimations.get(containerId);
                if (typeof existingAnimation === 'number') {
                    cancelAnimationFrame(existingAnimation);
                } else {
                    clearTimeout(existingAnimation);
                }
                activeAnimations.delete(containerId);
            }
            
            // Clear any existing content
            container.innerHTML = '';
            
            // Create canvas for unit animation
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            canvas.style.imageRendering = 'pixelated';
            canvas.setAttribute('data-unit', unitKey);
            container.appendChild(canvas);
            
            const ctx = canvas.getContext('2d');
            
            // Try to create a Phaser sprite exactly like grid sprites if scene is available
            if (window.gameScene && window.gameScene.textures && window.gameScene.textures.exists(unitKey)) {
                // Create an off-screen Phaser sprite EXACTLY like grid sprites
                const offScreenSprite = window.gameScene.add.sprite(-2000, -2000, unitKey);
                
                // Use EXACT same scaling as grid sprites - no complex calculations
                // Grid sprites use 0.75 base scale, then cellSize scaling
                offScreenSprite.setScale(0.75);
                
                // Apply grid cell scaling like grid sprites do
                if (window.gameScene.cellSize) {
                    const gridScale = Math.min(window.gameScene.cellSize / 80, 0.8);
                    offScreenSprite.setScale(gridScale);
                }
                
                offScreenSprite.setVisible(false);
                
                // Try to play idle animation exactly like grid sprites
                const idleAnimKey = `${unitKey}_idle`;
                if (window.gameScene.anims.exists(idleAnimKey)) {
                    offScreenSprite.play(idleAnimKey);
                    console.log(`UI Sprite: Playing ${idleAnimKey} animation`);
                } else {
                    // Fallback: try different animation naming patterns
                    const altAnimKeys = [`${unitKey}-idle`, `idle_${unitKey}`, `${unitKey}_walk`];
                    let animFound = false;
                    
                    for (const altKey of altAnimKeys) {
                        if (window.gameScene.anims.exists(altKey)) {
                            offScreenSprite.play(altKey);
                            console.log(`UI Sprite: Playing alternative animation ${altKey}`);
                            animFound = true;
                            break;
                        }
                    }
                    
                    if (!animFound) {
                        // Use first frame like grid sprites
                        const texture = window.gameScene.textures.get(unitKey);
                        const frames = texture.getFrameNames();
                        if (frames.length > 0) {
                            // Try to find a good frame (not just first)
                            let bestFrame = frames[0];
                            const preferredFrames = frames.filter(f => 
                                f.includes('idle') || f.includes('001') || f.includes('_1')
                            );
                            if (preferredFrames.length > 0) {
                                bestFrame = preferredFrames[0];
                            }
                            offScreenSprite.setFrame(bestFrame);
                            console.log(`UI Sprite: Set ${unitKey} to frame: ${bestFrame}`);
                        }
                    }
                }
                
                // Set depth like grid sprites
                offScreenSprite.setDepth(10);
                
                // Use requestAnimationFrame for smooth 60fps rendering like Phaser
                const renderSprite = () => {
                    if (!container.parentNode) {
                        // Clean up sprite when container is removed
                        if (offScreenSprite) {
                            offScreenSprite.destroy();
                        }
                        if (activeAnimations.has(containerId)) {
                            cancelAnimationFrame(activeAnimations.get(containerId));
                            activeAnimations.delete(containerId);
                        }
                        return;
                    }
                    
                    ctx.clearRect(0, 0, width, height);
                    
                    // Get the current frame from the Phaser sprite
                    const frame = offScreenSprite.frame;
                    if (frame && frame.source && frame.source.image) {
                        // Calculate positioning to center the sprite in canvas - EXACT same as grid
                        const spriteWidth = frame.width * offScreenSprite.scaleX;
                        const spriteHeight = frame.height * offScreenSprite.scaleY;
                        const x = (width - spriteWidth) / 2;
                        const y = (height - spriteHeight) / 2;
                        
                        // Draw the sprite frame exactly as Phaser would
                        ctx.save();
                        ctx.translate(x + spriteWidth / 2, y + spriteHeight / 2);
                        if (offScreenSprite.flipX) ctx.scale(-1, 1);
                        if (offScreenSprite.flipY) ctx.scale(1, -1);
                        ctx.globalAlpha = offScreenSprite.alpha;
                        
                        try {
                            ctx.drawImage(
                                frame.source.image,
                                frame.cutX || frame.x, frame.cutY || frame.y, 
                                frame.cutWidth || frame.width, frame.cutHeight || frame.height,
                                -spriteWidth / 2, -spriteHeight / 2, spriteWidth, spriteHeight
                            );
                        } catch (e) {
                            console.warn(`Failed to draw ${unitKey}:`, e);
                        }
                        ctx.restore();
                    }
                    
                    // Continue animation loop with requestAnimationFrame for smooth 60fps
                    const animationId = requestAnimationFrame(renderSprite);
                    activeAnimations.set(containerId, animationId);
                };
                
                renderSprite();
            } else {
                // Fallback to text sprite if Phaser not available
                drawTextSprite(ctx, unitKey.toUpperCase(), width, height);
            }
        }
        
        // Maintain backward compatibility
        function createUpgradeUnitSprite(container, unitKey) {
            createAnimatedUnitSprite(container, unitKey, 80, 80, 300);
        }
        
        function drawTextSprite(ctx, text, width, height) {
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(0, 0, width, height);
            
            ctx.fillStyle = '#FFD700';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(text, width/2, height/2 + 3);
        }
        
        function selectUnitType(upgradeId, unitType) {
            console.log(`Selected unit type ${unitType} for upgrade ${upgradeId}`);
            
            // This function is kept for backward compatibility but no longer used
            // The new UI uses sprite selection
        }
        
        function rerollUpgrades() {
            console.log('Rerolling upgrades');
            if (socket && socket.connected) {
                socket.emit('rerollUpgrades');
            }
        }
        
        // Sell Unit Functions
        function confirmSellUnit() {
            console.log('Confirming unit sale');
            
            if (!window.currentSellUnit) {
                console.error('No unit selected for sale');
                return;
            }
            
            const { unit, sellPrice } = window.currentSellUnit;
            
            if (socket && socket.connected) {
                console.log(`üí∞ Selling unit ${unit.name} for ${sellPrice} gold`);
                socket.emit('sellUnit', unit.id);
            } else {
                console.error('Socket not connected, cannot sell unit');
            }
            
            // Close tooltip
            closeSellTooltip();
        }
        
        function closeSellTooltip() {
            console.log('Closing sell tooltip');
            document.getElementById('sell-tooltip').classList.add('hidden');
            window.currentSellUnit = null;
        }
        
        // Add click-outside functionality for sell tooltip
        document.addEventListener('click', function(event) {
            const tooltip = document.getElementById('sell-tooltip');
            if (!tooltip.classList.contains('hidden') && !tooltip.contains(event.target)) {
                closeSellTooltip();
            }
        });
        
        // Initialize everything when page loads
        window.addEventListener('load', () => {
            initSocket();
            initPhaser();
            
            // Show lobby on start
            document.getElementById('lobby-modal').classList.remove('hidden');
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            handleResize();
        });
        
        // Debounced resize handler for better performance
        let resizeTimeout;
        function handleResize() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (game) {
                    game.scale.resize(window.innerWidth, window.innerHeight);
                    
                    // Redraw grid after resize
                    if (window.gameScene && window.gameScene.drawGrid) {
                        window.gameScene.drawGrid();
                        
                        // Update unit positions if in preparation phase
                        if (gameState && (gameState.phase === 'preparation' || gameState.phase === 'post-combat')) {
                            window.gameScene.updateGameState(gameState);
                        }
                    }
                }
                
                // Update HUD positions for mobile/electron
                updateHUDPositions();
            }, 150);
        }
        
        // Update HUD positions based on screen size
        function updateHUDPositions() {
            const isSmallScreen = window.innerWidth < 768 || window.innerHeight < 600;
            const shopPanel = document.getElementById('shop-panel');
            const unitPanel = document.getElementById('unit-panel');
            
            if (isSmallScreen) {
                // Compact mode for small screens
                if (shopPanel) {
                    shopPanel.style.padding = '10px';
                    shopPanel.style.gap = '8px';
                }
                if (unitPanel) {
                    unitPanel.style.maxHeight = '120px';
                }
            } else {
                // Normal mode
                if (shopPanel) {
                    shopPanel.style.padding = '15px';
                    shopPanel.style.gap = '10px';
                }
                if (unitPanel) {
                    unitPanel.style.maxHeight = '150px';
                }
            }
        }
        
        // Handle orientation change for mobile
        window.addEventListener('orientationchange', () => {
            setTimeout(handleResize, 100);
        });
        
        // React Native WebView message handling
        if (window.ReactNativeWebView) {
            window.addEventListener('message', (event) => {
                if (event.data && event.data.type === 'resize') {
                    handleResize();
                }
            });
        }
        
        // Electron IPC handling
        if (window.electron && window.electron.ipcRenderer) {
            window.electron.ipcRenderer.on('window-resize', handleResize);
        }
    </script>
</body>
</html>