<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dungeon Crawler</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        
        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #phaser-game {
            width: 100%;
            height: 100%;
        }
        
        .hud {
            position: absolute;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 8px;
            user-select: none;
        }
        
        .player-banners {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            gap: 10px;
            z-index: 50;
            flex-wrap: wrap;
        }
        
        .player-banner {
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 12px;
            border-radius: 8px;
            border: 2px solid;
            color: white;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 120px;
        }
        
        .player-color-indicator {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.5);
        }
        
        .player-banner.current-player {
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        
        .top-hud {
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            align-items: center;
        }
        
        .gold {
            background: rgba(255, 215, 0, 0.2);
            padding: 8px 16px;
            border-radius: 20px;
            border: 2px solid #FFD700;
            font-weight: bold;
        }
        
        .phase-info {
            text-align: center;
        }
        
        .shop {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 10px;
            border-radius: 8px;
            display: none;
            max-width: 85vw;
            max-height: 25vh;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 215, 0, 0.3);
        }
        
        .shop.active {
            display: block;
        }
        
        .shop-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .shop-title {
            color: #FFD700;
            font-size: 24px;
            font-weight: bold;
        }
        
        
        .shop-units {
            display: flex;
            gap: 8px;
            flex-wrap: nowrap;
            justify-content: flex-start;
            max-width: 100%;
            overflow-x: auto;
            overflow-y: hidden;
            padding: 5px 0;
        }
        
        /* Custom scrollbar for shop units */
        .shop-units::-webkit-scrollbar {
            height: 6px;
        }
        
        .shop-units::-webkit-scrollbar-track {
            background: rgba(255, 215, 0, 0.1);
            border-radius: 3px;
        }
        
        .shop-units::-webkit-scrollbar-thumb {
            background: rgba(255, 215, 0, 0.3);
            border-radius: 3px;
        }
        
        .shop-units::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 215, 0, 0.5);
        }
        
        .unit-card {
            background: linear-gradient(145deg, rgba(45, 45, 80, 0.9), rgba(30, 30, 60, 0.9));
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 12px;
            padding: 8px;
            width: 120px;
            min-width: 120px;
            flex-shrink: 0;
            cursor: grab;
            transition: all 0.3s ease;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }
        
        .shop-unit-sprite-container {
            width: 60px;
            height: 60px;
            margin: 0 auto 10px auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
        }
        
        .shop-unit-sprite-container canvas {
            display: block;
            margin: 0;
            padding: 0;
        }
        
        .shop-unit-sprite {
            width: 48px;
            height: 48px;
            image-rendering: pixelated;
            animation: idle-bob 2s ease-in-out infinite;
        }
        
        .unit-card:hover {
            transform: translateY(-4px) scale(1.02);
            border-color: #FFD700;
            box-shadow: 0 8px 25px rgba(255, 215, 0, 0.2);
        }
        
        .unit-card.dragging {
            cursor: grabbing;
            opacity: 0.6;
            transform: scale(0.95);
        }
        
        .unit-card.disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .unit-name {
            color: #FFD700;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 12px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            text-transform: capitalize;
        }
        
        .unit-cost {
            color: #FFD700;
            font-weight: bold;
            font-size: 18px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            background: rgba(255, 215, 0, 0.1);
            padding: 4px 8px;
            border-radius: 8px;
            margin: 8px 0;
        }
        
        .unit-stats {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-top: 12px;
            font-size: 14px;
            font-weight: bold;
            color: #fff;
        }
        
        .unit-stats span {
            background: rgba(255, 255, 255, 0.1);
            padding: 4px 6px;
            border-radius: 6px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        .ready-button {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
        }
        
        .ready-button:hover {
            background: #66BB6A;
        }
        
        .ready-button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        #connection-status {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
        }
        
        .connected {
            background: rgba(76, 175, 80, 0.3);
            color: #4CAF50;
            border: 2px solid #4CAF50;
        }
        
        .disconnected {
            background: rgba(244, 67, 54, 0.3);
            color: #F44336;
            border: 2px solid #F44336;
        }
        
        /* Unit Selection Modal */
        .unit-selection-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .unit-selection-content {
            background: #1a1a2e;
            border: 2px solid #FFD700;
            border-radius: 20px;
            padding: 20px;
            width: 90vw;
            height: 90vh;
            max-width: 1400px;
            max-height: 900px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        /* Ensure upgrade modal never scrolls */
        #upgrade-modal .unit-selection-content {
            height: calc(90vh - 100px); /* Account for fixed buttons */
            padding: 15px;
        }
        
        .unit-selection-title {
            color: #FFD700;
            font-size: 28px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 20px;
        }
        
        .unit-selection-subtitle {
            color: white;
            font-size: 18px;
            text-align: center;
            margin-bottom: 30px;
        }
        
        .units-grid {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            padding: 0 20px;
        }
        
        .unit-selection-card {
            background: linear-gradient(145deg, rgba(45, 45, 80, 0.9), rgba(30, 30, 60, 0.9));
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 16px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            width: 200px;
            height: 280px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            position: relative;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }
        
        .unit-selection-card:hover {
            transform: translateY(-4px) scale(1.02);
            border-color: rgba(255, 215, 0, 0.8);
            box-shadow: 0 8px 25px rgba(255, 215, 0, 0.2);
        }
        
        .unit-selection-card.selected {
            border-color: #FFD700;
            background: rgba(255, 215, 0, 0.2);
        }
        
        .unit-selection-card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .unit-selection-name {
            color: #FFD700;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            text-transform: capitalize;
        }
        
        .unit-sprite-container {
            width: 80px;
            height: 80px;
            margin: 0 auto 15px auto;
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.05));
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .unit-sprite-canvas {
            width: 64px;
            height: 64px;
            image-rendering: pixelated;
        }
        
        @keyframes idle-bob {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-2px); }
        }
        
        .unit-selection-stats {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin: 15px 0;
            font-size: 14px;
            font-weight: bold;
            color: #fff;
        }
        
        .unit-selection-stats span {
            background: rgba(255, 255, 255, 0.1);
            padding: 6px 8px;
            border-radius: 8px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        .start-game-btn {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            display: block;
            margin: 0 auto;
        }
        
        .start-game-btn:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .hidden {
            display: none !important;
        }
        
        /* Tooltip Styles */
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #FFD700;
            z-index: 2000;
            max-width: 300px;
            font-size: 12px;
            line-height: 1.4;
            pointer-events: none;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.2s, transform 0.2s;
        }
        
        .tooltip.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        .tooltip-header {
            color: #FFD700;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 8px;
            text-align: center;
        }
        
        .tooltip-section {
            margin-bottom: 8px;
        }
        
        .tooltip-section:last-child {
            margin-bottom: 0;
        }
        
        .tooltip-label {
            color: #ccc;
            font-weight: bold;
        }
        
        .tooltip-value {
            color: #fff;
        }
        
        .tooltip-passive {
            color: #4CAF50;
            font-style: italic;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 215, 0, 0.3);
        }
        
        /* In-game tooltip for units on grid */
        .game-tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 12px;
            border-radius: 6px;
            border: 2px solid #FFD700;
            z-index: 2500;
            max-width: 250px;
            font-size: 11px;
            line-height: 1.4;
            pointer-events: auto;
            display: none;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }
        
        .game-tooltip.show {
            display: block;
        }
        
        .game-tooltip-header {
            color: #FFD700;
            font-size: 13px;
            font-weight: bold;
            margin-bottom: 6px;
            text-align: center;
        }
        
        .game-tooltip-owner {
            color: #4CAF50;
            font-size: 11px;
            margin-bottom: 6px;
            text-align: center;
        }
        
        .game-tooltip-stats {
            font-size: 11px;
            line-height: 1.5;
        }
        
        .game-tooltip-upgrades {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 215, 0, 0.3);
        }
        
        .game-tooltip-upgrade-item {
            display: flex;
            align-items: center;
            gap: 6px;
            margin: 4px 0;
        }
        
        .game-tooltip-upgrade-item img {
            width: 16px;
            height: 16px;
            border-radius: 3px;
        }
        
        /* Upgrade Modal Styles */
        .upgrade-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            margin-bottom: 15px;
        }
        
        .upgrade-section h3 {
            flex-shrink: 0;
            color: #FFD700;
            text-align: center;
            margin: 0 0 10px 0;
            font-size: clamp(16px, 2vw, 20px);
        }
        
        .upgrade-cards-container {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
            flex: 1;
            overflow: hidden; /* No scrolling allowed */
            padding: 5px;
            align-items: flex-start;
            align-content: flex-start;
        }
        
        /* Scrollbar styles removed - no scrolling allowed in upgrade panel */
        
        .upgrade-card {
            background: linear-gradient(145deg, rgba(45, 45, 80, 0.9), rgba(30, 30, 60, 0.9));
            border: 3px solid rgba(255, 215, 0, 0.3);
            border-radius: 16px;
            padding: clamp(8px, 1.5vh, 15px); /* Responsive padding */
            width: clamp(180px, 22vw, 240px); /* Responsive width */
            max-width: calc(50% - 15px);
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            position: relative;
            display: flex;
            flex-direction: column;
            max-height: clamp(200px, 35vh, 400px); /* Ensure cards fit on screen */
            overflow: hidden; /* Prevent card content overflow */
        }
        
        /* Responsive card size for different screen heights */
        @media (max-height: 700px) {
            .upgrade-card {
                padding: clamp(6px, 1vh, 10px);
                width: clamp(180px, 20vw, 220px);
                max-height: clamp(150px, 28vh, 280px);
            }
            
            .unit-selection-content {
                padding: clamp(10px, 2vh, 15px);
            }
            
            .unit-selection-title {
                font-size: clamp(18px, 3vh, 22px);
                margin-bottom: clamp(8px, 1.5vh, 10px);
            }
            
            .unit-selection-subtitle {
                font-size: clamp(14px, 2.5vh, 16px);
                margin-bottom: clamp(10px, 2vh, 15px);
            }
            
            .upgrade-card.high-potency::before {
                top: clamp(-6px, -0.5vh, -4px);
                font-size: clamp(7px, 0.8vw, 9px);
                padding: clamp(1px, 0.3vh, 3px) clamp(3px, 0.8vw, 6px);
            }
        }
        
        @media (max-height: 500px) {
            .upgrade-card {
                max-height: clamp(120px, 22vh, 200px);
                padding: clamp(4px, 0.8vh, 8px);
            }
            
            #upgrade-modal .unit-selection-content {
                height: calc(95vh - 60px); /* More space on very small screens */
                padding: clamp(8px, 1.5vh, 12px);
            }
        }
        
        .upgrade-card.high-potency {
            border-color: #FF6B6B;
            background: linear-gradient(145deg, rgba(80, 45, 45, 0.9), rgba(60, 30, 30, 0.9));
        }
        
        .upgrade-card.high-potency::before {
            content: "√ó3 EFFECT";
            position: absolute;
            top: clamp(-8px, -1vh, -4px); /* Responsive positioning to prevent cutoff */
            right: clamp(5px, 1vw, 10px);
            background: #FF6B6B;
            color: white;
            padding: clamp(2px, 0.5vh, 4px) clamp(4px, 1vw, 8px);
            border-radius: clamp(6px, 1.5vw, 12px);
            font-size: clamp(8px, 1vw, 10px);
            font-weight: bold;
            z-index: 1;
            white-space: nowrap;
        }
        
        .upgrade-card:hover {
            transform: translateY(-4px) scale(1.02);
            border-color: #FFD700;
            box-shadow: 0 8px 25px rgba(255, 215, 0, 0.3);
        }
        
        .upgrade-card.selected {
            border: 3px solid #FFD700;
            background: rgba(255, 215, 0, 0.15);
            transform: translateY(-5px) scale(1.02);
            box-shadow: 0 10px 30px rgba(255, 215, 0, 0.4);
        }
        
        .upgrade-card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .upgrade-icon {
            width: 40px;
            height: 40px;
            margin: 0 auto 8px auto;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid rgba(255, 215, 0, 0.3);
            flex-shrink: 0;
        }
        
        .upgrade-icon img {
            width: 32px;
            height: 32px;
            border-radius: 4px;
        }
        
        .upgrade-name {
            color: #FFD700;
            font-size: clamp(14px, 1.5vw, 18px);
            font-weight: bold;
            margin-bottom: 8px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            line-height: 1.2;
        }
        
        .upgrade-description {
            color: #fff;
            font-size: clamp(11px, 1.2vw, 14px);
            margin-bottom: 10px;
            line-height: 1.3;
            flex: 1;
        }
        
        .upgrade-target {
            color: #4CAF50;
            font-size: clamp(10px, 1vw, 12px);
            font-weight: bold;
            margin-bottom: 8px;
            flex-shrink: 0;
        }
        
        .unit-type-selector {
            display: flex;
            gap: 8px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        
        .unit-type-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 215, 0, 0.3);
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }
        
        .unit-type-btn:hover {
            border-color: #FFD700;
            background: rgba(255, 215, 0, 0.1);
        }
        
        .unit-type-btn.selected {
            background: #4CAF50;
            border-color: #4CAF50;
        }
        
        .unit-type-option {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 5px 0;
            cursor: pointer;
            padding: 8px 12px;
            border-radius: 8px;
            transition: background-color 0.2s ease;
        }
        
        .unit-type-option:hover {
            background: rgba(255, 215, 0, 0.1);
        }
        
        .unit-type-option input[type="radio"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }
        
        .unit-type-option span {
            color: #FFD700;
            font-size: 14px;
            font-weight: bold;
        }
        
        .unit-sprite-selector {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
            margin: 8px 0;
        }
        
        .unit-selection-sprite {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 6px;
            border: 2px solid transparent;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.05);
        }
        
        .unit-selection-sprite:hover {
            background: rgba(255, 215, 0, 0.1);
            border-color: rgba(255, 215, 0, 0.3);
        }
        
        .unit-selection-sprite.selected {
            background: rgba(76, 175, 80, 0.2);
            border-color: #4CAF50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }
        
        .unit-sprite-container {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 2px;
        }
        
        .unit-selection-name {
            color: #FFD700;
            font-size: clamp(10px, 1vw, 12px);
            font-weight: bold;
            text-align: center;
            line-height: 1;
        }
        
        .upgrade-actions {
            margin-top: 10px;
            border-top: 1px solid rgba(255, 215, 0, 0.2);
            padding-top: 10px;
            flex-shrink: 0;
        }
        
        .confirm-upgrade-btn {
            background: linear-gradient(145deg, #4CAF50, #45a049);
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: clamp(12px, 1.2vw, 14px);
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 10px rgba(76, 175, 80, 0.3);
            width: 100%;
        }
        
        .confirm-upgrade-btn:hover:not(:disabled) {
            background: linear-gradient(145deg, #5CBF60, #4CAF50);
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
        }
        
        .confirm-upgrade-btn:disabled {
            background: #666;
            cursor: not-allowed;
            opacity: 0.6;
            transform: none;
            box-shadow: none;
        }
        
        /* Fixed position upgrade interface buttons */
        .reroll-upgrades-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(145deg, #FF6B35, #FF5722);
            border: none;
            color: white;
            padding: 12px 20px;
            border-radius: 15px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            z-index: 1001;
            box-shadow: 0 4px 15px rgba(255, 87, 34, 0.3);
            transition: all 0.2s ease;
        }
        
        .reroll-upgrades-btn:hover:not(:disabled) {
            background: linear-gradient(145deg, #FF7043, #FF6B35);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 87, 34, 0.4);
        }
        
        .reroll-upgrades-btn:disabled {
            background: #666;
            cursor: not-allowed;
            opacity: 0.6;
            transform: none;
            box-shadow: none;
        }
        
        .select-upgrade-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(145deg, #4CAF50, #388E3C);
            border: none;
            color: white;
            padding: 15px 25px;
            border-radius: 20px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            z-index: 1001;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
            transition: all 0.2s ease;
        }
        
        .select-upgrade-btn:hover:not(:disabled) {
            background: linear-gradient(145deg, #5CBF60, #4CAF50);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }
        
        .select-upgrade-btn:disabled {
            background: #666;
            cursor: not-allowed;
            opacity: 0.6;
            transform: none;
            box-shadow: none;
        }
        
        /* Additional responsive styles for mobile and Electron */
        @media (max-width: 768px) {
            .shop-panel {
                font-size: 12px;
            }
            
            .unit-card {
                padding: 6px;
                width: 100px;
                min-width: 100px;
            }
            
            .shop-units {
                gap: 6px;
            }
            
            .unit-name {
                font-size: 12px;
            }
            
            .unit-stats {
                font-size: 10px;
            }
            
            .hud {
                padding: 8px;
            }
            
            .player-banner {
                padding: 6px 10px;
                font-size: 12px;
            }
        }
        
        /* Portrait mode adjustments */
        @media (orientation: portrait) and (max-height: 1000px) {
            .shop-panel {
                max-height: 30vh;
            }
            
            .unit-panel {
                max-height: 100px;
            }
            
            .unit-selection-content {
                height: 95vh;
                width: 95vw;
            }
        }
        
        /* High DPI screens (React Native) */
        @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
            .game-tooltip {
                font-size: 13px;
            }
            
            .tooltip {
                font-size: 14px;
            }
        }
        
        /* Electron app window size detection */
        @media (min-width: 1200px) and (min-height: 800px) {
            #game-container {
                max-width: 1920px;
                max-height: 1080px;
                margin: 0 auto;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="phaser-game"></div>
        
        <!-- Player Banners -->
        <div id="player-banners" class="player-banners">
            <!-- Player banners will be dynamically added here -->
        </div>
        
        <div class="hud top-hud">
            <div class="gold">
                üí∞ <span id="gold-amount">50</span>
            </div>
            <div class="phase-info">
                <div id="phase-text">Preparation Phase</div>
                <div id="floor-text">Floor 1/10</div>
                <div id="timer-text" style="color: #FFD700; font-weight: bold; margin: 5px 0;">‚è±Ô∏è 60s</div>
                <button class="ready-button" id="ready-btn" onclick="setReady()">READY</button>
            </div>
        </div>
        
        <div id="connection-status" class="disconnected">
            Connecting...
        </div>
        
        
        <div class="shop" id="shop-panel">
            <div class="shop-header">
                <div class="shop-title">YOUR SELECTED UNITS</div>
            </div>
            <div class="shop-units" id="shop-units">
                <!-- Units will be populated here -->
            </div>
        </div>
    </div>

    <!-- Lobby Modal -->
    <div id="lobby-modal" class="unit-selection-modal">
        <div class="unit-selection-content">
            <h2 class="unit-selection-title">Dungeon Crawler Lobby</h2>
            <p class="unit-selection-subtitle">Choose how to play</p>
            
            <div style="display: flex; gap: 20px; justify-content: center; margin: 30px 0;">
                <button class="start-game-btn" onclick="findMatch()">
                    Find Match (1-4 Players)
                </button>
                <button class="start-game-btn" onclick="createPrivateMatch()">
                    Create Private Match
                </button>
            </div>
            
            <div id="lobby-status" style="text-align: center; color: #ccc; margin: 20px 0;">
                Choose an option to start playing
            </div>
            
            <div id="player-list" style="display: none;">
                <h3 style="color: #FFD700; text-align: center;">Players in Match</h3>
                <div id="players-container"></div>
                <button class="start-game-btn" id="lobby-ready-btn" onclick="setLobbyReady()" style="margin-top: 20px;">
                    Ready
                </button>
            </div>
        </div>
    </div>

    <!-- Unit Selection Modal -->
    <div id="unit-selection-modal" class="unit-selection-modal hidden">
        <div class="unit-selection-content">
            <h2 class="unit-selection-title">Choose Your Starting Units</h2>
            <p class="unit-selection-subtitle">Select 5 units (<span id="selected-count">0</span>/5)</p>
            <div class="units-grid" id="unit-selection-grid">
                <!-- Units will be populated here -->
            </div>
            <button class="start-game-btn" id="start-game-btn" onclick="startGame()" disabled>
                Start Game
            </button>
        </div>
    </div>

    <!-- Tooltip Container -->
    <div id="tooltip" class="tooltip"></div>
    
    <!-- In-game tooltip for hovering units on grid -->
    <div id="game-tooltip" class="game-tooltip"></div>

    <!-- Upgrade Selection Modal -->
    <div id="upgrade-modal" class="unit-selection-modal hidden">
        <!-- Fixed position reroll button - top right -->
        <button class="reroll-upgrades-btn" onclick="rerollUpgrades()" id="reroll-btn">
            üé≤ Reroll Upgrades (üí∞ 10)
        </button>
        
        <!-- Fixed position select upgrade button - bottom right -->
        <button class="select-upgrade-btn hidden" id="select-upgrade-btn" onclick="confirmSelectedUpgrade()">
            ‚úÖ Select This Upgrade
        </button>
        
        <div class="unit-selection-content">
            <h2 class="unit-selection-title">Choose Your Upgrades</h2>
            <p class="unit-selection-subtitle">Floor <span id="upgrade-floor">1</span> Complete!</p>
            
            <div class="upgrade-section">
                <h3>High-Potency Upgrade (√ó3 Effect)</h3>
                <div id="high-potency-upgrade" class="upgrade-cards-container">
                    <!-- High-potency upgrade will be populated here -->
                </div>
            </div>
            
            <div class="upgrade-section">
                <h3>Normal Upgrades (Choose Unit Type)</h3>
                <div id="normal-upgrades" class="upgrade-cards-container">
                    <!-- Normal upgrades will be populated here -->
                </div>
            </div>
            
            <p style="color: #FFD700; margin-top: 20px; font-style: italic; font-size: 14px; text-align: center;">
                Click any upgrade card to select it and continue to the next floor
            </p>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
    <script src="https://cdn.socket.io/4.8.1/socket.io.min.js"></script>
    <script>
        // Game configuration
        const SERVER_URL = 'http://localhost:3001';
        let socket = null;
        let game = null;
        let gameState = null;
        let playerId = null;
        let selectedUnits = [];
        let hasSelectedStartingUnits = false;
        let playerStartingUnits = [];
        let isInLobby = false;
        
        // Available units for selection (detailed stats per Game Requirements)
        const AVAILABLE_UNITS = {
            knight: { 
                cost: 20, 
                damage: 2, 
                health: 38, // Reduced by another 50% for much faster combat
                attackSpeed: 1.0,
                movementSpeed: 38, // Reduced by 50% for slower tactical movement 
                range: 8, // Increased from 3 to 8 to prevent collision circling
                priority: 1,
                attackType: 'Physical', 
                armorType: 'Heavy',
                innatePassive: 'Gains √ó2 effectiveness from heals',
                description: 'Heavily armored melee unit with high survivability'
            },
            priest: { 
                cost: 12, 
                damage: 1, 
                health: 20, // Reduced by another 50% for much faster combat
                attackSpeed: 3.0,
                movementSpeed: 30, // Reduced by 50% for slower tactical movement
                range: 50,
                priority: 4,
                attackType: 'Magical', 
                armorType: 'Unarmored',
                innatePassive: 'Heals a nearby damaged friendly Unit for 1 HP/sec',
                description: 'Support unit that heals allies continuously'
            },
            fighter: { 
                cost: 10, 
                damage: 3, 
                health: 30, // Reduced by another 50% for much faster combat
                attackSpeed: 1.0,
                movementSpeed: 40, // Reduced by 50% for slower tactical movement 
                range: 8, // Increased from 3 to 8 to prevent collision circling
                priority: 3,
                attackType: 'Physical', 
                armorType: 'Light',
                innatePassive: 'None',
                description: 'Balanced melee unit with good damage and speed'
            },
            wizard: { 
                cost: 12, 
                damage: 4, 
                health: 18, // Reduced by another 50% for much faster combat
                attackSpeed: 1.0,
                movementSpeed: 30, // Reduced by 50% for slower tactical movement
                range: 50,
                priority: 3,
                attackType: 'Magical', 
                armorType: 'Unarmored',
                innatePassive: 'None',
                description: 'High damage ranged caster with low survivability'
            },
            goblin: { 
                cost: 7, 
                damage: 3, 
                health: 20, // Reduced by another 50% for much faster combat
                attackSpeed: 1.0,
                movementSpeed: 35, // Reduced by 50% for slower tactical movement 
                range: 8, // Increased from 3 to 8 to prevent collision circling
                priority: 3,
                attackType: 'Physical', 
                armorType: 'Unarmored',
                innatePassive: 'None',
                description: 'Cheap, fast melee unit - good for early game'
            }
        };
        
        // Initialize socket connection
        function initSocket() {
            socket = io(SERVER_URL);
            
            socket.on('connect', () => {
                console.log('Connected to server');
                document.getElementById('connection-status').className = 'connected';
                document.getElementById('connection-status').textContent = 'Connected';
                
                // Don't auto-join match, let player choose
            });
            
            socket.on('disconnect', () => {
                console.log('Disconnected from server');
                document.getElementById('connection-status').className = 'disconnected';
                document.getElementById('connection-status').textContent = 'Disconnected';
            });
            
            socket.on('matchFound', (data) => {
                console.log('Match found:', data);
                playerId = data.playerId;
                
                // Show unit selection if it's floor 1 and haven't selected yet
                if (data.gameState.currentFloor === 1 && !hasSelectedStartingUnits) {
                    document.getElementById('lobby-modal').classList.add('hidden');
                    showUnitSelection();
                } else {
                    updateGameState(data.gameState);
                }
            });
            
            socket.on('lobbyUpdate', (lobbyData) => {
                console.log('Lobby update:', lobbyData);
                updateLobby(lobbyData);
                isInLobby = true;
                
                // Set playerId from lobby data
                if (!playerId && lobbyData.players) {
                    const currentPlayer = lobbyData.players.find(p => p.id === socket.id);
                    if (currentPlayer) {
                        playerId = currentPlayer.id;
                        console.log('Set playerId from lobby:', playerId);
                    }
                }
            });
            
            socket.on('lobbyReady', () => {
                console.log('All players ready, starting unit selection');
                document.getElementById('lobby-modal').classList.add('hidden');
                showUnitSelection();
            });
            
            
            socket.on('game-state', (state) => {
                console.log('Received game state:', state);
                
                // Ensure playerId is set if we can find ourselves in the players
                if (!playerId && state.players) {
                    const currentPlayer = state.players.find(p => p.id === socket.id);
                    if (currentPlayer) {
                        playerId = currentPlayer.id;
                        console.log('Set playerId from game state:', playerId);
                    }
                }
                
                console.log('Current player:', state.players?.find(p => p.id === playerId));
                updateGameState(state);
            });
            
            socket.on('timer-update', (timeLeft) => {
                updateTimer(timeLeft);
            });
            
            socket.on('combat-update', (playerUnits, enemyUnits) => {
                if (window.gameScene) {
                    window.gameScene.updateCombatState(playerUnits, enemyUnits);
                }
            });
            
            socket.on('matchStarted', (matchId) => {
                console.log('Match started:', matchId);
                // Match has been created, game state updates will follow
                
                // Ensure playerId is set (fallback to socket.id)
                if (!playerId) {
                    playerId = socket.id;
                    console.log('Set playerId from socket.id:', playerId);
                }
            });
            
            socket.on('error', (error) => {
                console.error('Socket error:', error);
                alert('Error: ' + error.message);
            });
        }
        
        // Lobby Functions
        function findMatch() {
            console.log('findMatch clicked');
            document.getElementById('lobby-status').textContent = 'Finding match...';
            if (socket) {
                const playerName = 'Player' + Math.floor(Math.random() * 1000);
                console.log('Emitting findMatch with:', { playerName });
                socket.emit('findMatch', { playerName });
            } else {
                console.error('Socket not connected!');
                document.getElementById('lobby-status').textContent = 'Connection error - refresh page';
            }
        }
        
        function createPrivateMatch() {
            console.log('createPrivateMatch clicked');
            document.getElementById('lobby-status').textContent = 'Creating private match...';
            if (socket) {
                const playerName = 'Host' + Math.floor(Math.random() * 1000);
                console.log('Emitting createPrivateMatch with:', { playerName });
                socket.emit('createPrivateMatch', { playerName });
            } else {
                console.error('Socket not connected!');
                document.getElementById('lobby-status').textContent = 'Connection error - refresh page';
            }
        }
        
        function setLobbyReady() {
            console.log('setLobbyReady clicked');
            if (socket) {
                console.log('Emitting setLobbyReady');
                socket.emit('setLobbyReady');
            } else {
                console.error('Socket not connected!');
            }
        }
        
        function updateLobby(lobbyData) {
            const playerList = document.getElementById('player-list');
            const playersContainer = document.getElementById('players-container');
            const lobbyStatus = document.getElementById('lobby-status');
            
            playerList.style.display = 'block';
            playersContainer.innerHTML = '';
            
            lobbyData.players.forEach(player => {
                const playerDiv = document.createElement('div');
                playerDiv.style.cssText = 'padding: 10px; margin: 5px; background: rgba(255,255,255,0.1); border-radius: 8px; display: flex; justify-content: space-between;';
                playerDiv.innerHTML = `
                    <span style="color: white;">${player.name}</span>
                    <span style="color: ${player.isReady ? '#4CAF50' : '#ccc'};">${player.isReady ? 'READY' : 'Not Ready'}</span>
                `;
                playersContainer.appendChild(playerDiv);
            });
            
            lobbyStatus.textContent = `${lobbyData.players.length}/4 players in lobby`;
        }
        
        // Tooltip Functions
        function showTooltip(event, unitName, unitData = null) {
            // If unitData is provided (from shop), use it directly, otherwise lookup in AVAILABLE_UNITS
            let unit = unitData;
            
            if (!unit) {
                // Normalize unit name to lowercase for lookup
                const normalizedName = unitName.toLowerCase();
                unit = AVAILABLE_UNITS[normalizedName];
                if (!unit) {
                    console.warn(`Tooltip: Unit ${unitName} (${normalizedName}) not found in AVAILABLE_UNITS`);
                    return;
                }
            }
            
            const tooltip = document.getElementById('tooltip');
            tooltip.innerHTML = `
                <div class="tooltip-header">${unitName.toUpperCase()}</div>
                ${unit.owner ? `<div class="tooltip-section">
                    <span class="tooltip-label">Owner:</span> <span class="tooltip-value">üë§ ${unit.owner}</span>
                </div>` : ''}
                <div class="tooltip-section">
                    <span class="tooltip-label">Cost:</span> <span class="tooltip-value">üí∞ ${unit.cost}</span>
                </div>
                <div class="tooltip-section">
                    <span class="tooltip-label">Combat Stats:</span><br>
                    ‚öîÔ∏è Damage: <span class="tooltip-value">${unit.damage}</span><br>
                    ‚ù§Ô∏è Health: <span class="tooltip-value">${unit.health}</span><br>
                    ‚ö° Attack Speed: <span class="tooltip-value">${unit.attackSpeed}</span><br>
                    üèÉ Movement Speed: <span class="tooltip-value">${unit.movementSpeed}</span><br>
                    üéØ Range: <span class="tooltip-value">${unit.range}</span><br>
                    üìç Priority: <span class="tooltip-value">${unit.priority}</span>
                </div>
                <div class="tooltip-section">
                    <span class="tooltip-label">Type:</span> <span class="tooltip-value">${unit.attackType}</span><br>
                    <span class="tooltip-label">Armor:</span> <span class="tooltip-value">${unit.armorType}</span>
                </div>
                <div class="tooltip-section">
                    <span class="tooltip-label">Description:</span><br>
                    <span class="tooltip-value">${unit.description || 'Tactical unit for combat'}</span>
                </div>
                ${(unit.innatePassive && unit.innatePassive !== 'None' && unit.innatePassive !== null) ? `
                <div class="tooltip-passive">
                    <strong>Passive:</strong> ${unit.innatePassive}
                </div>
                ` : ''}
                ${getUpgradeTooltipSection(unit)}
            `;
            
            // Position tooltip with smart positioning
            const rect = event.currentTarget.getBoundingClientRect();
            const tooltipMargin = 10;
            
            // Temporarily show tooltip to get dimensions
            tooltip.style.visibility = 'hidden';
            tooltip.classList.add('show');
            
            const tooltipRect = tooltip.getBoundingClientRect();
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            
            // Calculate positions
            let left = rect.left + rect.width + tooltipMargin;
            let top = rect.top;
            
            // Check if tooltip would go off the right edge
            if (left + tooltipRect.width > windowWidth) {
                // Position to the left of the element
                left = rect.left - tooltipRect.width - tooltipMargin;
            }
            
            // Check if tooltip would go off the left edge
            if (left < 0) {
                // Center horizontally if no good position
                left = Math.max(tooltipMargin, (windowWidth - tooltipRect.width) / 2);
            }
            
            // Check if tooltip would go off the bottom
            if (top + tooltipRect.height > windowHeight - tooltipMargin) {
                // Position above the cursor/element
                top = Math.max(tooltipMargin, rect.bottom - tooltipRect.height - rect.height - tooltipMargin);
            }
            
            // Check if tooltip would go off the top
            if (top < tooltipMargin) {
                top = tooltipMargin;
            }
            
            // Apply final position
            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
            tooltip.style.visibility = 'visible';
        }
        
        function hideTooltip() {
            const tooltip = document.getElementById('tooltip');
            tooltip.classList.remove('show');
        }
        
        // Game tooltip functions for in-game unit hovering
        function showGameTooltip(unit, ownerName, mouseX, mouseY) {
            const tooltip = document.getElementById('game-tooltip');
            
            // Build tooltip HTML
            let tooltipHTML = `
                <div class="game-tooltip-header">${unit.name.toUpperCase()}</div>
                <div class="game-tooltip-owner">üë§ ${ownerName}</div>
                <div class="game-tooltip-stats">
                    ‚ù§Ô∏è ${unit.health}/${unit.maxHealth} | ‚öîÔ∏è ${unit.damage} | ‚ö° ${unit.attackSpeed}
                </div>
            `;
            
            // Add upgrades if any
            if (unit.buffs && unit.buffs.length > 0) {
                tooltipHTML += '<div class="game-tooltip-upgrades">';
                unit.buffs.forEach(buff => {
                    let upgradeName = '';
                    let description = '';
                    
                    switch (buff.type) {
                        case 'lifesteal':
                            upgradeName = 'vampiric_strike';
                            description = `${Math.round(buff.value * 100)}% lifesteal`;
                            break;
                        case 'poison':
                            upgradeName = 'poison_blade';
                            description = `${buff.value} poison DPS`;
                            break;
                        case 'deathHeal':
                            upgradeName = 'final_gift';
                            description = `Heals ${Math.round(buff.value * 100)}% on death`;
                            break;
                        case 'deathExplosion':
                            upgradeName = 'explosive_end';
                            description = `Explodes for ${Math.round(buff.value * 100)}%`;
                            break;
                        case 'slowAura':
                            upgradeName = 'slowing_aura';
                            description = `-${Math.round(buff.value * 100)}% enemy AS`;
                            break;
                        default:
                            upgradeName = buff.type.toLowerCase().replace(/\s+/g, '_');
                            description = `${buff.type}: ${buff.value}`;
                    }
                    
                    tooltipHTML += `
                        <div class="game-tooltip-upgrade-item">
                            <img src="assets/upgradeicons/${upgradeName}.png" 
                                 onerror="this.style.display='none'"
                                 alt="${upgradeName}">
                            <span>${description}</span>
                        </div>
                    `;
                });
                tooltipHTML += '</div>';
            }
            
            tooltip.innerHTML = tooltipHTML;
            tooltip.classList.add('show');
            
            // Position tooltip
            updateGameTooltipPosition(mouseX, mouseY);
            
            // Add hover support for the tooltip itself
            tooltip.onmouseenter = () => {
                cancelGameTooltipHide();
            };
            
            tooltip.onmouseleave = () => {
                hideGameTooltipDelayed();
            };
        }
        
        function updateGameTooltipPosition(mouseX, mouseY) {
            const tooltip = document.getElementById('game-tooltip');
            if (!tooltip.classList.contains('show')) return;
            
            const margin = 15;
            const tooltipRect = tooltip.getBoundingClientRect();
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            
            // Default position: to the right and slightly above cursor
            let left = mouseX + margin;
            let top = mouseY - tooltipRect.height / 2;
            
            // Adjust if tooltip goes off right edge
            if (left + tooltipRect.width > windowWidth - margin) {
                left = mouseX - tooltipRect.width - margin;
            }
            
            // Adjust if tooltip goes off top edge
            if (top < margin) {
                top = margin;
            }
            
            // Adjust if tooltip goes off bottom edge
            if (top + tooltipRect.height > windowHeight - margin) {
                top = windowHeight - tooltipRect.height - margin;
            }
            
            // Ensure tooltip doesn't go off left edge
            if (left < margin) {
                left = margin;
            }
            
            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
        }
        
        let gameTooltipHideTimeout;
        
        function hideGameTooltip() {
            const tooltip = document.getElementById('game-tooltip');
            tooltip.classList.remove('show');
        }
        
        function hideGameTooltipDelayed() {
            // Clear any existing timeout
            clearTimeout(gameTooltipHideTimeout);
            
            // Set a delay before hiding to allow mouse movement between units
            gameTooltipHideTimeout = setTimeout(() => {
                hideGameTooltip();
            }, 100); // 100ms delay for better desktop responsiveness
        }
        
        function cancelGameTooltipHide() {
            clearTimeout(gameTooltipHideTimeout);
        }
        
        function getUpgradeTooltipSection(unit) {
            // Check if this unit has any applied upgrades (buffs)
            if (!unit.buffs || unit.buffs.length === 0) {
                return '';
            }
            
            const upgradeItems = [];
            unit.buffs.forEach(buff => {
                let description = '';
                let upgradeName = '';
                
                switch (buff.type) {
                    case 'lifesteal':
                        description = `${Math.round(buff.value * 100)}% damage becomes health`;
                        upgradeName = 'vampiric_strike';
                        break;
                    case 'poison':
                        description = `${buff.value} poison damage per second`;
                        upgradeName = 'poison_blade';
                        break;
                    case 'deathHeal':
                        description = `Heal nearby units ${Math.round(buff.value * 100)}% on death`;
                        upgradeName = 'final_gift';
                        break;
                    case 'deathExplosion':
                        description = `Explode for ${Math.round(buff.value * 100)}% damage on death`;
                        upgradeName = 'explosive_end';
                        break;
                    case 'slowAura':
                        description = `Reduce enemy attack speed by ${Math.round(buff.value * 100)}%`;
                        upgradeName = 'slowing_aura';
                        break;
                    default:
                        description = `${buff.type}: ${buff.value}`;
                        upgradeName = buff.type.toLowerCase().replace(/\s+/g, '_');
                }
                
                if (description) {
                    const iconPath = `assets/upgradeicons/${upgradeName}.png`;
                    upgradeItems.push(`
                        <div style="display: flex; align-items: center; gap: 8px; margin: 4px 0;">
                            <img src="${iconPath}" alt="${upgradeName}" style="width: 20px; height: 20px; border-radius: 4px;" onerror="this.style.display='none'">
                            <span>${description}</span>
                        </div>
                    `);
                }
            });
            
            if (upgradeItems.length === 0) {
                return '';
            }
            
            return `
                <div class="tooltip-passive" style="border-top: 1px solid rgba(76, 175, 80, 0.3); color: #4CAF50; padding-top: 8px;">
                    <strong>Applied Upgrades:</strong><br>
                    ${upgradeItems.join('')}
                </div>
            `;
        }
        
        // Unit Selection Functions
        function showUnitSelection() {
            console.log('Showing unit selection modal');
            const modal = document.getElementById('unit-selection-modal');
            const grid = document.getElementById('unit-selection-grid');
            
            grid.innerHTML = '';
            selectedUnits = [];
            updateSelectedCount();
            
            Object.entries(AVAILABLE_UNITS).forEach(([unitName, stats]) => {
                const card = document.createElement('div');
                card.className = 'unit-selection-card';
                card.onclick = () => toggleUnitSelection(unitName, card);
                
                card.innerHTML = `
                    <div class="unit-selection-name">${unitName}</div>
                    <div class="unit-sprite-container" id="unit-select-${unitName}">
                        <!-- Animated sprite will be added here -->
                    </div>
                    <div class="unit-selection-stats">
                        <span>‚öîÔ∏è ${Math.round(stats.damage * stats.attackSpeed * 10) / 10 % 1 === 0 ? Math.round(stats.damage * stats.attackSpeed) : (stats.damage * stats.attackSpeed).toFixed(1)} DPS</span>
                        <span>‚ù§Ô∏è ${stats.health}</span>
                        <span>üèÉ ${stats.movementSpeed}</span>
                    </div>
                    <div style="font-size: 10px; color: #aaa; margin-top: 5px;">
                        ${stats.attackType} | ${stats.armorType}
                    </div>
                `;
                
                // Add animated sprite using our universal function
                setTimeout(() => {
                    const container = document.getElementById(`unit-select-${unitName}`);
                    if (container) {
                        createAnimatedUnitSprite(container, unitName, 64, 64, 400);
                    }
                }, 100);
                
                // Add tooltip event handlers
                card.addEventListener('mouseenter', (e) => showTooltip(e, unitName));
                card.addEventListener('mouseleave', hideTooltip);
                
                grid.appendChild(card);
            });
            
            modal.classList.remove('hidden');
        }
        
        function toggleUnitSelection(unitName, cardElement) {
            console.log('Toggling unit selection for:', unitName);
            const index = selectedUnits.indexOf(unitName);
            
            if (index > -1) {
                // Deselect
                selectedUnits.splice(index, 1);
                cardElement.classList.remove('selected');
                console.log('Deselected:', unitName);
            } else {
                // Select (if under limit)
                if (selectedUnits.length < 5) {
                    selectedUnits.push(unitName);
                    cardElement.classList.add('selected');
                    console.log('Selected:', unitName);
                } else {
                    console.log('Cannot select more units, limit reached');
                }
            }
            
            console.log('Currently selected units:', selectedUnits);
            updateSelectedCount();
            updateStartButton();
        }
        
        function updateSelectedCount() {
            document.getElementById('selected-count').textContent = selectedUnits.length;
        }
        
        function updateStartButton() {
            const startBtn = document.getElementById('start-game-btn');
            startBtn.disabled = selectedUnits.length !== 5;
        }
        
        function startGame() {
            if (selectedUnits.length === 5) {
                hasSelectedStartingUnits = true;
                playerStartingUnits = [...selectedUnits]; // Store selected units
                document.getElementById('unit-selection-modal').classList.add('hidden');
                
                console.log('Player selected starting units:', playerStartingUnits);
                
                // Send selected units to server
                if (socket && socket.connected) {
                    socket.emit('selectStartingUnits', selectedUnits);
                }
                
                // Show the game with shop containing selected units
                showGameWithStartingUnits();
            }
        }
        
        function showGameWithStartingUnits() {
            // Only create mock game state if we don't have a real server connection
            // or if we haven't received a real game state yet
            if (!socket || !socket.connected || !gameState) {
                console.log('Creating mock game state for unit selection preview');
                
                // Create mock game state to show shop with starting units
                const mockGameState = {
                    matchId: 'preview-match',
                    phase: 'preparation',
                    currentFloor: 1,
                    preparationTimeLeft: 60,
                    shopUnits: playerStartingUnits.map(unitName => ({
                        name: unitName,
                        ...AVAILABLE_UNITS[unitName]
                    })),
                    players: [{
                        id: playerId || 'preview-player',
                        name: 'Player',
                        gold: 50,
                        units: [],
                        isReady: false
                    }],
                    enemyUnits: [],
                    grid: createEmptyGrid(12, 12)
                };
                
                // Store as the current game state
                gameState = mockGameState;
                
                const mockPlayer = {
                    id: playerId || 'preview-player',
                    gold: 50,
                    units: [],
                    isReady: false
                };
                
                // Manually show the game UI
                updateGameStateUI(mockGameState, mockPlayer);
            } else {
                console.log('Server connected, waiting for real game state...');
            }
        }
        
        function createEmptyGrid(width, height) {
            const grid = [];
            for (let y = 0; y < height; y++) {
                grid[y] = [];
                for (let x = 0; x < width; x++) {
                    grid[y][x] = {
                        x,
                        y,
                        occupied: false,
                        unitId: null
                    };
                }
            }
            return grid;
        }
        
        // Update game state
        function updateGameState(state) {
            console.log('=== updateGameState called ===');
            console.log('New state received:', state);
            console.log('Current playerId:', playerId);
            console.log('Phase:', state.phase);
            console.log('Players in state:', state.players);
            
            gameState = state;
            window.gameState = state; // Make accessible to Phaser scene
            
            // Update HUD
            const player = state.players.find(p => p.id === playerId);
            console.log('Found current player:', player);
            updateGameStateUI(state, player);
            
            // Force Phaser scene update
            if (window.gameScene && window.gameScene.updateGameState) {
                console.log('Calling Phaser scene updateGameState...');
                window.gameScene.updateGameState(state);
            } else {
                console.error('Phaser scene or updateGameState method not available!');
            }
        }
        
        function updateGameStateUI(state, player) {
            if (player) {
                document.getElementById('gold-amount').textContent = player.gold;
                
                // Update ready button
                const readyBtn = document.getElementById('ready-btn');
                if (player.isReady) {
                    readyBtn.textContent = 'READY!';
                    readyBtn.disabled = true;
                } else {
                    readyBtn.textContent = 'READY';
                    readyBtn.disabled = false;
                }
            }
            
            // Update phase info
            document.getElementById('phase-text').textContent = 
                state.phase === 'preparation' ? 'Preparation Phase' :
                state.phase === 'combat' ? 'Combat Phase' : 
                state.phase === 'post-combat' ? 'Victory! Choose Upgrades' :
                'Game Over';
            document.getElementById('floor-text').textContent = `Floor ${state.currentFloor}/10`;
            
            // Update player banners
            if (state.players) {
                updatePlayerBanners(state.players);
            }
            
            // Update timer (show during preparation phase)
            if (state.phase === 'preparation' && state.preparationTimeLeft !== undefined) {
                updateTimer(state.preparationTimeLeft);
                document.getElementById('timer-text').style.display = 'block';
            } else {
                // Hide timer during combat
                document.getElementById('timer-text').style.display = 'none';
            }
            
            // Show/hide shop
            const shopPanel = document.getElementById('shop-panel');
            if (state.phase === 'preparation') {
                shopPanel.classList.add('active');
                // Use shopUnits from state, or fallback to default units for testing
                const shopUnits = state.shopUnits || Object.entries(AVAILABLE_UNITS).slice(0, 4).map(([name, stats]) => ({
                    name,
                    ...stats
                }));
                updateShop(shopUnits, player?.gold || 50);
            } else {
                shopPanel.classList.remove('active');
            }
            
            // Show/hide upgrade modal
            const upgradeModal = document.getElementById('upgrade-modal');
            const currentPlayer = state.players.find(p => p.id === playerId);
            
            if (state.phase === 'post-combat' && currentPlayer && currentPlayer.upgradeCards && currentPlayer.upgradeCards.length > 0 && !currentPlayer.hasSelectedUpgrade) {
                upgradeModal.classList.remove('hidden');
                showUpgradeSelection(currentPlayer.upgradeCards, state.currentFloor, currentPlayer.gold);
            } else {
                upgradeModal.classList.add('hidden');
                
                // Show waiting message if player has selected but others haven't
                if (state.phase === 'post-combat' && currentPlayer && currentPlayer.hasSelectedUpgrade) {
                    const waitingCount = state.players.filter(p => !p.hasSelectedUpgrade).length;
                    if (waitingCount > 0) {
                        console.log(`Waiting for ${waitingCount} other player(s) to select upgrades...`);
                        // Could show a waiting overlay here
                    }
                }
            }
            
            // Update Phaser game - try multiple ways to get the scene
            if (window.gameScene && window.gameScene.updateGameState) {
                console.log('Updating Phaser scene via window.gameScene');
                window.gameScene.updateGameState(state);
            } else if (game && game.scene.getScene('MainScene')) {
                console.log('Updating Phaser scene via game.scene.getScene');
                game.scene.getScene('MainScene').updateGameState(state);
            } else {
                console.error('No Phaser scene available for update!');
                console.log('window.gameScene:', !!window.gameScene);
                console.log('game:', !!game);
                console.log('game.scene:', game?.scene);
            }
        }
        
        // Player color management
        const PLAYER_COLORS = [
            { primary: '#4CAF50', rgb: [76, 175, 80] },   // Green
            { primary: '#2196F3', rgb: [33, 150, 243] },  // Blue  
            { primary: '#FF9800', rgb: [255, 152, 0] },   // Orange
            { primary: '#9C27B0', rgb: [156, 39, 176] }   // Purple
        ];
        
        let playerColorMap = new Map(); // playerId -> colorIndex
        let usedColors = new Set(); // Track which colors are in use
        
        function getPlayerColor(playerId, allPlayers) {
            if (!playerColorMap.has(playerId)) {
                // Deterministic color assignment: sort all players by ID and assign colors in order
                // This ensures all clients assign the same colors to the same players
                const sortedPlayerIds = allPlayers.map(p => p.id).sort();
                const playerIndex = sortedPlayerIds.indexOf(playerId);
                const colorIndex = playerIndex % PLAYER_COLORS.length;
                
                playerColorMap.set(playerId, colorIndex);
                usedColors.add(colorIndex);
            }
            return PLAYER_COLORS[playerColorMap.get(playerId)];
        }
        
        function cleanupPlayerColors(currentPlayers) {
            // For deterministic color assignment, we need to rebuild the color mappings
            // to ensure consistency when players leave and rejoin
            const currentPlayerIds = new Set(currentPlayers.map(p => p.id));
            
            // Clean up mappings for departed players
            for (const [playerId, colorIndex] of playerColorMap) {
                if (!currentPlayerIds.has(playerId)) {
                    playerColorMap.delete(playerId);
                    usedColors.delete(colorIndex);
                }
            }
            
            // Rebuild mappings for consistency
            const sortedPlayerIds = currentPlayers.map(p => p.id).sort();
            playerColorMap.clear();
            usedColors.clear();
            
            sortedPlayerIds.forEach((playerId, index) => {
                const colorIndex = index % PLAYER_COLORS.length;
                playerColorMap.set(playerId, colorIndex);
                usedColors.add(colorIndex);
            });
        }
        
        function updatePlayerBanners(players) {
            const bannerContainer = document.getElementById('player-banners');
            if (!bannerContainer) return;
            
            // Clean up departed players and maintain unique colors
            cleanupPlayerColors(players);
            
            bannerContainer.innerHTML = '';
            
            // Sort players to show current player first
            const sortedPlayers = [...players].sort((a, b) => {
                if (a.id === playerId) return -1;
                if (b.id === playerId) return 1;
                return 0;
            });
            
            sortedPlayers.forEach((player, index) => {
                const color = getPlayerColor(player.id, players);
                const isCurrentPlayer = player.id === playerId;
                
                const banner = document.createElement('div');
                banner.className = `player-banner ${isCurrentPlayer ? 'current-player' : ''}`;
                banner.style.borderColor = color.primary;
                
                banner.innerHTML = `
                    <div class="player-color-indicator" style="background-color: ${color.primary}"></div>
                    <span>${player.name}</span>
                    <span style="color: #FFD700;">üí∞${player.gold}</span>
                    ${player.isReady ? '<span style="color: #4CAF50;">‚úì</span>' : ''}
                `;
                
                bannerContainer.appendChild(banner);
            });
        }
        
        // Update timer display
        function updateTimer(timeLeft) {
            const timerElement = document.getElementById('timer-text');
            if (timerElement) {
                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                timerElement.textContent = `‚è±Ô∏è ${timeString}`;
                
                // Change color based on time remaining
                if (timeLeft <= 10) {
                    timerElement.style.color = '#FF4444'; // Red for urgency
                } else if (timeLeft <= 30) {
                    timerElement.style.color = '#FFA500'; // Orange for warning
                } else {
                    timerElement.style.color = '#FFD700'; // Gold for normal
                }
            }
        }

        // Update shop display
        function updateShop(units, playerGold) {
            console.log('Updating shop with units:', units, 'Gold:', playerGold);
            const shopUnitsDiv = document.getElementById('shop-units');
            shopUnitsDiv.innerHTML = '';
            
            units.forEach((unit, index) => {
                // Ensure proper number comparison for 0 gold edge case
                const playerGoldNum = Number(playerGold) || 0;
                const unitCostNum = Number(unit.cost) || 0;
                const canAfford = playerGoldNum >= unitCostNum;
                const unitCard = document.createElement('div');
                unitCard.className = `unit-card ${!canAfford ? 'disabled' : ''}`;
                
                unitCard.innerHTML = `
                    <div class="unit-name">${unit.name}</div>
                    <div class="shop-unit-sprite-container" id="shop-sprite-${unit.name.toLowerCase()}-${index}">
                        <!-- Animated sprite will be added here -->
                    </div>
                    <div class="unit-cost">üí∞ ${unit.cost}</div>
                    <div class="unit-stats">
                        <span>‚öîÔ∏è ${Math.round(unit.damage * unit.attackSpeed * 10) / 10 % 1 === 0 ? Math.round(unit.damage * unit.attackSpeed) : (unit.damage * unit.attackSpeed).toFixed(1)} DPS</span>
                        <span>‚ù§Ô∏è ${unit.health}</span>
                        <span>üèÉ ${unit.movementSpeed}</span>
                    </div>
                `;
                
                // Add tooltip event handlers with unit data
                unitCard.addEventListener('mouseenter', (e) => {
                    console.log('Tooltip hover on unit:', unit.name, 'Full unit object:', unit);
                    showTooltip(e, unit.name, unit);
                });
                unitCard.addEventListener('mouseleave', hideTooltip);
                
                if (canAfford) {
                    // Universal drag system for desktop and mobile
                    setupUniversalDrag(unitCard, unit.name.toLowerCase());
                }
                
                shopUnitsDiv.appendChild(unitCard);
            });
            
            // Create animated sprites for shop units with proper delay for Phaser to be ready
            setTimeout(() => {
                units.forEach((unit, index) => {
                    // Use index to prevent ID conflicts for duplicate units
                    const containerId = `shop-sprite-${unit.name.toLowerCase()}-${index}`;
                    const container = document.getElementById(containerId);
                    if (container) {
                        // Match the container size for proper centering
                        createAnimatedUnitSprite(container, unit.name.toLowerCase(), 60, 60, 400);
                    }
                });
            }, 200); // Increased delay to ensure Phaser is ready
        }
        
        // Universal drag system for desktop and mobile
        function setupUniversalDrag(element, unitName) {
            let isDragging = false;
            let dragClone = null;
            let startX, startY;
            
            // Mouse events for desktop
            element.addEventListener('mousedown', startDrag);
            
            // Touch events for mobile
            element.addEventListener('touchstart', startDrag, { passive: false });
            
            function startDrag(e) {
                e.preventDefault();
                isDragging = true;
                
                const touch = e.touches ? e.touches[0] : e;
                startX = touch.clientX;
                startY = touch.clientY;
                
                // Create a sprite-only visual for dragging
                dragClone = document.createElement('div');
                dragClone.style.position = 'fixed';
                dragClone.style.pointerEvents = 'none';
                dragClone.style.zIndex = '9999';
                dragClone.style.opacity = '0.8';
                dragClone.style.width = '48px';
                dragClone.style.height = '48px';
                dragClone.style.borderRadius = '8px';
                dragClone.style.left = (startX - 24) + 'px';
                dragClone.style.top = (startY - 24) + 'px';
                
                // Create canvas for the drag sprite
                const dragCanvas = document.createElement('canvas');
                dragCanvas.width = 48;
                dragCanvas.height = 48;
                dragCanvas.setAttribute('data-unit', unitName.toLowerCase());
                dragCanvas.style.width = '100%';
                dragCanvas.style.height = '100%';
                dragCanvas.style.imageRendering = 'pixelated';
                
                dragClone.appendChild(dragCanvas);
                document.body.appendChild(dragClone);
                
                // Update the drag canvas immediately
                if (window.gameScene && window.gameScene.updateUnitCanvases) {
                    setTimeout(() => window.gameScene.updateUnitCanvases(), 10);
                }
                
                element.classList.add('dragging');
                
                // Add move and end listeners
                document.addEventListener('mousemove', handleDrag);
                document.addEventListener('mouseup', endDrag);
                document.addEventListener('touchmove', handleDrag, { passive: false });
                document.addEventListener('touchend', endDrag);
            }
            
            function handleDrag(e) {
                if (!isDragging || !dragClone) return;
                e.preventDefault();
                
                const touch = e.touches ? e.touches[0] : e;
                
                dragClone.style.left = (touch.clientX - 24) + 'px';
                dragClone.style.top = (touch.clientY - 24) + 'px';
            }
            
            function endDrag(e) {
                if (!isDragging) return;
                
                const touch = e.changedTouches ? e.changedTouches[0] : e;
                const dropX = touch.clientX;
                const dropY = touch.clientY;
                
                
                // Check if dropped on the Phaser game canvas
                const gameCanvas = document.querySelector('#phaser-game canvas');
                if (gameCanvas) {
                    const rect = gameCanvas.getBoundingClientRect();
                    console.log(`Drop coordinates: (${dropX}, ${dropY}), Canvas rect:`, rect);
                    
                    if (dropX >= rect.left && dropX <= rect.right && 
                        dropY >= rect.top && dropY <= rect.bottom) {
                        
                        // Calculate grid position
                        const localX = dropX - rect.left;
                        const localY = dropY - rect.top;
                        console.log(`Local coordinates: (${localX}, ${localY})`);
                        
                        if (window.gameScene && window.gameScene.worldToGrid) {
                            const gridPos = window.gameScene.worldToGrid(localX, localY);
                            const gridWidth = window.gameScene.gridWidth || 20;
                            const gridHeight = window.gameScene.gridHeight || 8;
                            
                            console.log(`Grid position: (${gridPos.x}, ${gridPos.y}), Grid size: ${gridWidth}x${gridHeight}`);
                            
                            if (gridPos.x >= 0 && gridPos.x < gridWidth && 
                                gridPos.y >= 0 && gridPos.y < gridHeight) {
                                console.log(`Valid position! Placing ${unitName} at grid position:`, gridPos);
                                purchaseAndPlaceUnit(unitName, gridPos);
                            } else {
                                console.log(`Invalid grid position: (${gridPos.x}, ${gridPos.y})`);
                            }
                        } else {
                            console.error('gameScene or worldToGrid not available');
                        }
                    } else {
                        console.log('Drop outside canvas bounds');
                    }
                } else {
                    console.error('Game canvas not found!');
                }
                
                // Cleanup
                if (dragClone) {
                    document.body.removeChild(dragClone);
                    dragClone = null;
                }
                
                element.classList.remove('dragging');
                isDragging = false;
                
                // Remove event listeners
                document.removeEventListener('mousemove', handleDrag);
                document.removeEventListener('mouseup', endDrag);
                document.removeEventListener('touchmove', handleDrag);
                document.removeEventListener('touchend', endDrag);
            }
        }
        
        // Game actions
        function setReady() {
            console.log('setReady clicked, socket:', !!socket);
            if (socket && socket.connected) {
                socket.emit('setReady');
                console.log('Emitted setReady event');
            } else {
                console.error('No socket connection!');
            }
        }
        
        
        function purchaseAndPlaceUnit(unitType, position) {
            console.log(`Purchasing and placing ${unitType} at`, position);
            console.log('Current playerId:', playerId);
            console.log('Current socket.id:', socket?.id);
            
            // Ensure unitType is lowercase
            unitType = unitType.toLowerCase();
            
            // Check if we have a valid playerId
            if (!playerId) {
                console.error('No player ID! Not in a match yet.');
                // Try to set it from socket.id as fallback
                if (socket && socket.id) {
                    playerId = socket.id;
                    console.log('Emergency fallback: set playerId to socket.id:', playerId);
                } else {
                    alert('You must join a match first!');
                    return;
                }
            }
            
            // Check if socket is connected
            if (!socket || !socket.connected) {
                console.error('Socket not connected! Cannot purchase unit.');
                alert('Connection lost! Please refresh the page.');
                return;
            }
            
            // Try to find unit data from game state first (has server costs), then fall back to local data
            let unitData = null;
            let unitCost = 0;
            
            if (gameState && gameState.shopUnits) {
                const shopUnit = gameState.shopUnits.find(u => u.name.toLowerCase() === unitType);
                if (shopUnit) {
                    unitData = shopUnit;
                    unitCost = shopUnit.cost;
                    console.log(`Found unit in shop with cost ${unitCost}`);
                }
            }
            
            // Fallback to local unit data
            if (!unitData) {
                unitData = AVAILABLE_UNITS[unitType];
                if (unitData) {
                    unitCost = unitData.cost;
                    console.log(`Using local unit data with cost ${unitCost}`);
                }
            }
            
            if (!unitData) {
                console.error(`Unit data not found for ${unitType}`);
                return;
            }
            
            const currentGold = parseInt(document.getElementById('gold-amount').textContent);
            if (currentGold < unitCost) {
                console.warn(`Not enough gold! Need ${unitCost}, have ${currentGold}`);
                return;
            }
            
            // Send to server - the server will handle validation, gold deduction, and unit placement
            console.log('Sending to server: purchaseAndPlaceUnit', { unitType, position });
            socket.emit('purchaseAndPlaceUnit', { unitType, position });
            console.log('Purchase request sent to server, waiting for game state update...');
        }
        
        // Initialize Phaser game
        function initPhaser() {
            const config = {
                type: Phaser.AUTO,
                parent: 'phaser-game',
                width: window.innerWidth,
                height: window.innerHeight,
                scale: {
                    mode: Phaser.Scale.RESIZE,
                    autoCenter: Phaser.Scale.CENTER_BOTH,
                },
                backgroundColor: '#1a1a2e',
                scene: {
                    preload: preload,
                    create: create,
                    update: update
                }
            };
            
            game = new Phaser.Game(config);
        }
        
        // Store animations for each unit
        const animationsStore = {};

        // Unit list from our game
        const unitList = ["knight", "priest", "fighter", "wizard", "goblin"];

        function preload() {
            console.log('Preloading assets...');
            
            // Load assets
            this.load.setBaseURL('/assets/');
            
            // Load backgrounds
            this.load.image('battle1', 'backgrounds/battle1.png');
            this.load.image('battle2', 'backgrounds/battle2.png');
            this.load.image('battle3', 'backgrounds/battle3.png');
            this.load.image('battle4', 'backgrounds/battle4.png');
            
            // Load unit atlases with simplified approach
            unitList.forEach(unit => {
                console.log(`Loading atlas for ${unit}`);
                this.load.atlas(
                    unit,
                    `units/${unit}/${unit}.png`,
                    `units/${unit}/${unit}.json`
                );
                
                // Load sound (optional)
                this.load.audio(`${unit}Sound`, `units/${unit}/${unit}Sound.mp3`);
            });
        }
        
        function create() {
            console.log('Create function called');
            
            // Store scene reference for resize handling
            window.gameScene = this;
            
            // Set up the game scene
            this.cameras.main.setBackgroundColor('#1a1a2e');
            
            // Create grid first - wider and shorter to avoid UI overlap
            this.gridGraphics = this.add.graphics();
            this.gridWidth = 20;
            this.gridHeight = 8;
            this.gridSize = 12; // Keep for backwards compatibility
            this.drawGrid();
            this.gridGraphics.setVisible(true);
            
            // Initialize containers for tracking sprites
            this.unitSprites = [];
            this.combatUnits = {};
            this.unitPreviews = {};
            this.battleBackground = null;
            
            // Fix TexturePacker atlases before creating animations
            console.log('Fixing texture atlases...');
            unitList.forEach(unit => {
                fixTextureAtlas(this, unit);
            });
            
            // Create animations for all loaded units
            console.log('Creating animations for all units...');
            unitList.forEach(unit => {
                if (this.textures.exists(unit)) {
                    console.log(`Creating animations for ${unit}`);
                    createAnimationsForUnit(this, unit);
                } else {
                    console.error(`Texture ${unit} not found!`);
                }
            });
            
            // Debug: Test creating a unit sprite to verify assets are working
            this.testUnitRendering();
            
            // Create unit previews after animations are set up
            setTimeout(() => {
                console.log('Creating unit previews...');
                this.createUnitPreviews();
            }, 500);
        }
        
        Phaser.Scene.prototype.testUnitRendering = function() {
            console.log('Testing unit rendering...');
            
            // Try to create a test sprite for debugging
            if (this.textures.exists('knight')) {
                console.log('Knight texture exists, creating test sprite');
                const testSprite = this.add.sprite(200, 200, 'knight');
                testSprite.setScale(0.5);
                
                // Try to play animation
                const idleAnimKey = 'knight_idle';
                if (this.anims.exists(idleAnimKey)) {
                    testSprite.play(idleAnimKey);
                    console.log('Playing knight idle animation');
                } else {
                    console.log('Knight idle animation not found, using first frame');
                    const frames = this.textures.get('knight').getFrameNames();
                    console.log('Available knight frames:', frames.slice(0, 5));
                    if (frames.length > 0) {
                        testSprite.setFrame(frames[0]);
                    }
                }
                
                // Remove test sprite after 3 seconds
                setTimeout(() => {
                    if (testSprite && testSprite.scene) {
                        testSprite.destroy();
                        console.log('Test sprite removed');
                    }
                }, 3000);
            } else {
                console.error('Knight texture not found! Available textures:', Object.keys(this.textures.list));
            }
        };
        
        /**
         * Fix TexturePacker format atlases
         */
        function fixTextureAtlas(scene, atlasKey) {
            const texture = scene.textures.get(atlasKey);
            if (!texture) return;
            
            // Check if we need to fix the frame names
            const frames = texture.getFrameNames();
            console.log(`Checking ${atlasKey} atlas, found ${frames.length} frames`);
            
            // If we have frames with .png extension, we might need to fix them
            if (frames.length > 0 && frames[0].includes('.png')) {
                console.log(`Fixing frame names for ${atlasKey}`);
                
                // Get the atlas data
                const atlasData = texture.customData;
                if (atlasData && atlasData.textures) {
                    // This is TexturePacker format, already handled by Phaser
                    console.log(`${atlasKey} is already in correct format`);
                }
            }
        }
        
        /**
         * Helper function to create animations for a specific unit.
         * @param {Phaser.Scene} scene - The Phaser scene.
         * @param {string} atlasKey - The unit's atlas key.
         */
        function createAnimationsForUnit(scene, atlasKey) {
            try {
                const textureFrames = scene.textures.get(atlasKey).getFrameNames();
                console.log(`Creating animations for ${atlasKey}, found ${textureFrames.length} frames:`, textureFrames.slice(0, 5));

                // Find different animation frames
                const idleFrames = textureFrames.filter(frame => {
                    return frame.startsWith("Idle_") || frame.toLowerCase().includes("idle");
                });
                
                const walkFrames = textureFrames.filter(frame => {
                    return frame.startsWith("Walk_") || //frame.startsWith("Run_") || 
                           frame.toLowerCase().includes("walk") //|| frame.toLowerCase().includes("run");
                });
                
                const attackFrames = textureFrames.filter(frame => {
                    return frame.startsWith("Attack_") || frame.toLowerCase().includes("attack");
                });
                
                const deathFrames = textureFrames.filter(frame => {
                    return frame.startsWith("Death_") || frame.startsWith("Die_") || 
                           frame.toLowerCase().includes("death") || frame.toLowerCase().includes("die");
                });
                
                console.log(`Found frames for ${atlasKey}: ${idleFrames.length} idle, ${walkFrames.length} walk, ${attackFrames.length} attack, ${deathFrames.length} death`);

                // Create idle animation
                if (idleFrames.length > 0) {
                    const animKey = `${atlasKey}_idle`;
                    if (!scene.anims.exists(animKey)) {
                        scene.anims.create({
                            key: animKey,
                            frames: idleFrames.map(frame => ({ key: atlasKey, frame: frame })),
                            frameRate: 4, // Reduced from 6 to 4 for slower animations
                            repeat: -1,
                        });
                        console.log(`‚úì Created idle animation: ${animKey}`);
                    }
                }
                
                // Create walk animation
                if (walkFrames.length > 0) {
                    const animKey = `${atlasKey}_walk`;
                    if (!scene.anims.exists(animKey)) {
                        scene.anims.create({
                            key: animKey,
                            frames: walkFrames.map(frame => ({ key: atlasKey, frame: frame })),
                            frameRate: 7.5, // Increased from 6 to 7.5 (25% faster)
                            repeat: -1,
                        });
                        console.log(`‚úì Created walk animation: ${animKey}`);
                    }
                } else if (idleFrames.length > 0) {
                    // Fallback: use idle frames for walking if no walk frames
                    const animKey = `${atlasKey}_walk`;
                    if (!scene.anims.exists(animKey)) {
                        scene.anims.create({
                            key: animKey,
                            frames: idleFrames.map(frame => ({ key: atlasKey, frame: frame })),
                            frameRate: 7.5, // Increased from 6 to 7.5 (25% faster)
                            repeat: -1,
                        });
                        console.log(`‚úì Created walk animation (using idle frames): ${animKey}`);
                    }
                }
                
                // Create attack animation
                if (attackFrames.length > 0) {
                    const animKey = `${atlasKey}_attack`;
                    if (!scene.anims.exists(animKey)) {
                        scene.anims.create({
                            key: animKey,
                            frames: attackFrames.map(frame => ({ key: atlasKey, frame: frame })),
                            frameRate: 8, // Reduced from 10 to 8 for slower animations
                            repeat: 0, // Play once
                        });
                        console.log(`‚úì Created attack animation: ${animKey}`);
                    }
                } else if (idleFrames.length > 0) {
                    // Fallback: use idle frames for attacking if no attack frames
                    const animKey = `${atlasKey}_attack`;
                    if (!scene.anims.exists(animKey)) {
                        scene.anims.create({
                            key: animKey,
                            frames: idleFrames.map(frame => ({ key: atlasKey, frame: frame })),
                            frameRate: 8, // Reduced from 12 to 8 for slower animations
                            repeat: 0,
                        });
                        console.log(`‚úì Created attack animation (using idle frames): ${animKey}`);
                    }
                }
                
                // Create death animation
                if (deathFrames.length > 0) {
                    const animKey = `${atlasKey}_death`;
                    if (!scene.anims.exists(animKey)) {
                        scene.anims.create({
                            key: animKey,
                            frames: deathFrames.map(frame => ({ key: atlasKey, frame: frame })),
                            frameRate: 6, // Reduced from 8 to 6 for slower animations
                            repeat: 0, // Play once and stop on last frame
                        });
                        console.log(`‚úì Created death animation: ${animKey}`);
                    }
                } else if (idleFrames.length > 0) {
                    // Fallback: use idle frames for death if no death frames
                    const animKey = `${atlasKey}_death`;
                    if (!scene.anims.exists(animKey)) {
                        scene.anims.create({
                            key: animKey,
                            frames: [idleFrames[idleFrames.length - 1]].map(frame => ({ key: atlasKey, frame: frame })),
                            frameRate: 1,
                            repeat: 0,
                        });
                        console.log(`‚úì Created death animation (using last idle frame): ${animKey}`);
                    }
                }

                // Store the animation references
                animationsStore[atlasKey] = {
                    idle: `${atlasKey}_idle`,
                    walk: `${atlasKey}_walk`,
                    attack: `${atlasKey}_attack`,
                    death: `${atlasKey}_death`
                };

                console.log(`Stored animations for ${atlasKey}:`, animationsStore[atlasKey]);
                
            } catch (error) {
                console.error(`Error creating animations for ${atlasKey}:`, error);
            }
        }

        /**
         * Helper function to add a unit to the scene.
         * @param {Phaser.Scene} scene - The Phaser scene.
         * @param {string} unitName - The unit's name (atlas key).
         * @param {number} x - X position.
         * @param {number} y - Y position.
         */
        function addUnitToScene(scene, unitName, x, y) {
            console.log(`Adding ${unitName} to scene at (${x}, ${y})`);
            
            try {
                // Check if texture exists
                if (!scene.textures.exists(unitName)) {
                    console.error(`Texture ${unitName} does not exist!`);
                    // Create a colored placeholder sprite
                    const graphics = scene.add.graphics();
                    const colors = {
                        knight: 0x4CAF50, priest: 0x2196F3, fighter: 0xFF5722, 
                        wizard: 0x9C27B0, goblin: 0x8BC34A
                    };
                    graphics.fillStyle(colors[unitName] || 0xFF0000);
                    graphics.fillRect(-20, -20, 40, 40);
                    graphics.setPosition(x, y);
                    console.log(`Created placeholder for ${unitName}`);
                    return graphics;
                }
                
                const sprite = scene.add.sprite(x, y, unitName);
                sprite.setScale(0.75);
                
                // Try to play idle animation
                const idleAnimKey = `${unitName}_idle`;
                if (scene.anims.exists(idleAnimKey)) {
                    sprite.play(idleAnimKey);
                    console.log(`‚úì Playing ${idleAnimKey} animation`);
                } else {
                    console.warn(`Animation ${idleAnimKey} not found, trying first frame`);
                    const texture = scene.textures.get(unitName);
                    const frames = texture.getFrameNames();
                    console.log(`Available frames for ${unitName}:`, frames.slice(0, 3));
                    
                    if (frames.length > 0) {
                        sprite.setFrame(frames[0]);
                        console.log(`Set ${unitName} to frame: ${frames[0]}`);
                    }
                }
                
                // Make sprite more visible for debugging
                sprite.setDepth(10);
                console.log(`‚úì Successfully created sprite for ${unitName} at (${x}, ${y})`);
                
                return sprite;
                
            } catch (error) {
                console.error(`Error adding ${unitName} to scene:`, error);
                
                // Create emergency fallback sprite
                const graphics = scene.add.graphics();
                graphics.fillStyle(0xFF0000);
                graphics.fillRect(-15, -15, 30, 30);
                graphics.setPosition(x, y);
                console.log(`Created emergency fallback for ${unitName}`);
                return graphics;
            }
        }
        
        Phaser.Scene.prototype.createUnitPreviews = function() {
            console.log('Creating unit previews...');
            
            // Store sprites globally for HTML access
            window.unitPreviewSprites = window.unitPreviewSprites || {};
            
            unitList.forEach((unit, index) => {
                if (this.textures.exists(unit)) {
                    console.log(`Creating preview sprite for ${unit}`);
                    
                    // Create sprite off-screen for canvas rendering only
                    const sprite = addUnitToScene(this, unit, -1000, -1000); // Position off-screen
                    if (sprite) {
                        sprite.setScale(0.75); // Normal scale
                        sprite.setVisible(false); // Keep invisible - only for canvas rendering
                        
                        // Store sprite globally for HTML canvas rendering
                        window.unitPreviewSprites[unit] = sprite;
                        this.unitPreviews[unit] = sprite;
                        
                        console.log(`‚úì Created off-screen preview for ${unit}`);
                    }
                } else {
                    console.error(`‚ùå Texture ${unit} does not exist!`);
                }
            });
            
            // Force canvas updates with multiple attempts
            for (let i = 1; i <= 3; i++) {
                setTimeout(() => {
                    this.updateUnitCanvases();
                    console.log(`Canvas update attempt ${i}`);
                }, i * 200);
            }
        };
        
        Phaser.Scene.prototype.updateUnitCanvases = function() {
            if (!window.unitPreviewSprites) return;
            
            Object.entries(window.unitPreviewSprites).forEach(([unitName, sprite]) => {
                // Find all canvas elements for this unit
                const canvases = document.querySelectorAll(`[data-unit="${unitName}"]`);
                canvases.forEach(canvas => {
                    if (canvas.tagName === 'CANVAS') {
                        const ctx = canvas.getContext('2d');
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        // Get current frame from Phaser sprite
                        if (sprite && sprite.texture && sprite.frame) {
                            const frame = sprite.frame;
                            const texture = sprite.texture.getSourceImage();
                            
                            try {
                                // Draw the current frame with proper scaling
                                const sourceX = frame.cutX || frame.x || 0;
                                const sourceY = frame.cutY || frame.y || 0;
                                const sourceWidth = frame.cutWidth || frame.width || frame.realWidth || 50;
                                const sourceHeight = frame.cutHeight || frame.height || frame.realHeight || 50;
                                
                                ctx.drawImage(
                                    texture,
                                    sourceX, sourceY, sourceWidth, sourceHeight,
                                    0, 0, canvas.width, canvas.height
                                );
                                
                                // Debug: add a border to show canvas is working
                                ctx.strokeStyle = '#00ff00';
                                ctx.lineWidth = 1;
                                ctx.strokeRect(0, 0, canvas.width, canvas.height);
                                
                            } catch (e) {
                                console.warn(`Failed to draw ${unitName}:`, e);
                                // Fallback: draw colored rectangle with unit name
                                const colors = {
                                    knight: '#4CAF50', priest: '#2196F3', fighter: '#FF5722', 
                                    wizard: '#9C27B0', goblin: '#8BC34A'
                                };
                                ctx.fillStyle = colors[unitName] || '#666';
                                ctx.fillRect(0, 0, canvas.width, canvas.height);
                                ctx.fillStyle = '#fff';
                                ctx.font = '10px Arial';
                                ctx.textAlign = 'center';
                                ctx.fillText(unitName.toUpperCase(), canvas.width/2, canvas.height/2);
                            }
                        } else {
                            // No sprite/frame available, draw colored placeholder
                            const colors = {
                                knight: '#4CAF50', priest: '#2196F3', fighter: '#FF5722', 
                                wizard: '#9C27B0', goblin: '#8BC34A'
                            };
                            ctx.fillStyle = colors[unitName] || '#444';
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                            ctx.fillStyle = '#fff';
                            ctx.font = '10px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText(unitName.toUpperCase(), canvas.width/2, canvas.height/2);
                        }
                    }
                });
            });
        };
        
        Phaser.Scene.prototype.setupGridUnitDrag = function(sprite, unit) {
            // Make sprite draggable
            sprite.setInteractive({ draggable: true });
            
            let dragData = {
                startGridPos: { x: unit.position.x, y: unit.position.y },
                startWorldPos: { x: sprite.x, y: sprite.y },
                isDragging: false
            };
            
            // Drag start
            sprite.on('dragstart', (pointer, dragX, dragY) => {
                console.log(`Started dragging unit ${unit.name} from grid (${unit.position.x}, ${unit.position.y})`);
                dragData.isDragging = true;
                sprite.setTint(0xffff00); // Yellow tint when dragging
                sprite.setDepth(1000); // Bring to front
                hideGameTooltipDelayed(); // Hide tooltip when dragging
            });
            
            // Drag
            sprite.on('drag', (pointer, dragX, dragY) => {
                sprite.x = dragX;
                sprite.y = dragY;
                
                // Update ownership indicators to follow
                if (sprite.ownershipIndicators) {
                    sprite.ownershipIndicators.forEach(indicator => {
                        if (indicator && indicator.setPosition) {
                            indicator.setPosition(dragX, dragY);
                        }
                    });
                }
            });
            
            // Drag end
            sprite.on('dragend', (pointer) => {
                console.log(`Dropped unit ${unit.name} at world (${sprite.x}, ${sprite.y})`);
                dragData.isDragging = false;
                sprite.clearTint(); // Remove drag tint
                sprite.setDepth(10); // Reset depth
                
                // Calculate grid position from world position
                const gridX = Math.floor((sprite.x - this.gridX) / this.cellSize);
                const gridY = Math.floor((sprite.y - this.gridY) / this.cellSize);
                
                console.log(`Calculated grid position: (${gridX}, ${gridY})`);
                
                // Check if drop position is valid
                if (gridX >= 0 && gridX < this.gridWidth && gridY >= 0 && gridY < this.gridHeight) {
                    // Check if position is free or occupied by same player
                    const targetCell = gameState?.grid?.[gridY]?.[gridX];
                    const isValidDrop = !targetCell?.occupied || targetCell?.playerId === playerId;
                    
                    if (isValidDrop) {
                        // Valid drop - send move request to server
                        console.log(`Valid drop at grid (${gridX}, ${gridY}), sending move request`);
                        if (socket && socket.connected) {
                            socket.emit('moveUnit', unit.id, { x: gridX, y: gridY });
                        }
                    } else {
                        // Invalid drop - snap back to original position
                        console.log(`Invalid drop at grid (${gridX}, ${gridY}), snapping back`);
                        this.snapUnitBack(sprite, unit, dragData);
                    }
                } else {
                    // Out of bounds - snap back
                    console.log(`Out of bounds drop, snapping back`);
                    this.snapUnitBack(sprite, unit, dragData);
                }
            });
        };
        
        Phaser.Scene.prototype.snapUnitBack = function(sprite, unit, dragData) {
            // Snap back to original position
            const originalWorldX = this.gridX + (dragData.startGridPos.x * this.cellSize) + (this.cellSize / 2);
            const originalWorldY = this.gridY + (dragData.startGridPos.y * this.cellSize) + (this.cellSize / 2);
            
            sprite.x = originalWorldX;
            sprite.y = originalWorldY;
            
            // Update ownership indicators
            if (sprite.ownershipIndicators) {
                sprite.ownershipIndicators.forEach(indicator => {
                    if (indicator && indicator.setPosition) {
                        indicator.setPosition(originalWorldX, originalWorldY);
                    }
                });
            }
        };
        
        Phaser.Scene.prototype.drawGrid = function() {
            if (!this.gridGraphics) return;
            
            this.gridGraphics.clear();
            
            // Draw grid cell highlights first (behind grid lines)
            this.drawGridHighlights();
            
            this.gridGraphics.lineStyle(2, 0x888888, 0.8); // Make grid more visible
            
            // Use actual grid dimensions
            const gridWidth = this.gridWidth || 20;
            const gridHeight = this.gridHeight || 8;
            
            // Get screen dimensions
            const screenWidth = this.cameras.main.width;
            const screenHeight = this.cameras.main.height;
            
            // Detect if we're in a small screen (mobile/small electron window)
            const isSmallScreen = screenWidth < 768 || screenHeight < 600;
            const isPortrait = screenHeight > screenWidth;
            
            // Calculate responsive grid size with better spacing for UI
            let widthMultiplier = 0.95;
            let heightMultiplier = 0.65;
            let gridOffsetY = 80;
            
            if (isSmallScreen) {
                widthMultiplier = 0.98;
                heightMultiplier = 0.55;
                gridOffsetY = 60;
            }
            
            if (isPortrait) {
                widthMultiplier = 0.98;
                heightMultiplier = 0.45;
                gridOffsetY = 40;
            }
            
            const availableWidth = screenWidth * widthMultiplier;
            const availableHeight = screenHeight * heightMultiplier;
            
            this.cellSize = Math.min(
                availableWidth / gridWidth,
                availableHeight / gridHeight,
                60 // Maximum cell size to prevent grid from being too large
            );
            
            // Minimum cell size for usability
            this.cellSize = Math.max(this.cellSize, 20);
            
            this.gridX = this.cameras.main.centerX - (gridWidth * this.cellSize) / 2;
            // Position grid higher up to avoid shop panel overlap
            this.gridY = this.cameras.main.centerY - (gridHeight * this.cellSize) / 2 - gridOffsetY;
            
            // Ensure grid doesn't go off screen
            const minMargin = 10;
            if (this.gridX < minMargin) {
                this.gridX = minMargin;
            }
            if (this.gridY < minMargin) {
                this.gridY = minMargin;
            }
            
            // Draw grid lines with adaptive thickness
            const lineThickness = isSmallScreen ? 1 : 2;
            this.gridGraphics.lineStyle(lineThickness, 0x888888, 0.8);
            
            for (let i = 0; i <= gridWidth; i++) {
                // Vertical lines
                this.gridGraphics.moveTo(this.gridX + i * this.cellSize, this.gridY);
                this.gridGraphics.lineTo(this.gridX + i * this.cellSize, this.gridY + gridHeight * this.cellSize);
            }
            for (let i = 0; i <= gridHeight; i++) {
                // Horizontal lines
                this.gridGraphics.moveTo(this.gridX, this.gridY + i * this.cellSize);
                this.gridGraphics.lineTo(this.gridX + gridWidth * this.cellSize, this.gridY + i * this.cellSize);
            }
            this.gridGraphics.strokePath();
            
            // Setup grid cell interaction for highlighting
            this.setupGridCellInteraction();
        };
        
        // Track highlighted cells
        let highlightedCells = new Map(); // playerId -> {x, y}
        
        Phaser.Scene.prototype.drawGridHighlights = function() {
            // Draw highlights for each player's hovered cell
            highlightedCells.forEach((cellPos, playerId) => {
                if (cellPos && cellPos.x >= 0 && cellPos.y >= 0) {
                    const playerColor = this.getPlayerColor(playerId);
                    this.gridGraphics.fillStyle(playerColor, 0.3); // Semi-transparent
                    this.gridGraphics.fillRect(
                        this.gridX + (cellPos.x * this.cellSize),
                        this.gridY + (cellPos.y * this.cellSize),
                        this.cellSize,
                        this.cellSize
                    );
                }
            });
        };
        
        Phaser.Scene.prototype.getPlayerColor = function(playerId) {
            // Find player index based on game state
            if (gameState && gameState.players) {
                const playerIndex = gameState.players.findIndex(p => p.id === playerId);
                const colorValues = [0x00ff00, 0xff0000, 0x0000ff, 0xffff00]; // Green, Red, Blue, Yellow
                return colorValues[playerIndex] || 0x00ff00;
            }
            
            return 0x00ff00; // Default green
        };
        
        Phaser.Scene.prototype.setupGridCellInteraction = function() {
            // Remove existing interaction zones
            if (this.gridInteractionZones) {
                this.gridInteractionZones.forEach(zone => zone.destroy());
            }
            this.gridInteractionZones = [];
            
            const gridWidth = this.gridWidth || 20;
            const gridHeight = this.gridHeight || 8;
            
            // Create invisible interaction zones for each grid cell
            for (let x = 0; x < gridWidth; x++) {
                for (let y = 0; y < gridHeight; y++) {
                    const zone = this.add.zone(
                        this.gridX + (x * this.cellSize) + (this.cellSize / 2),
                        this.gridY + (y * this.cellSize) + (this.cellSize / 2),
                        this.cellSize,
                        this.cellSize
                    );
                    
                    zone.setInteractive();
                    zone.gridX = x;
                    zone.gridY = y;
                    
                    // Mouse enter - highlight cell
                    zone.on('pointerover', () => {
                        highlightedCells.set(playerId, { x: x, y: y });
                        this.drawGrid(); // Redraw to show highlight
                    });
                    
                    // Mouse leave - remove highlight
                    zone.on('pointerout', () => {
                        highlightedCells.delete(playerId);
                        this.drawGrid(); // Redraw to remove highlight
                    });
                    
                    this.gridInteractionZones.push(zone);
                }
            }
        };
        
        Phaser.Scene.prototype.worldToGrid = function(x, y) {
            const gridWidth = this.gridWidth || 20;
            const gridHeight = this.gridHeight || 8;
            
            const gridX = Math.floor((x - this.gridX) / this.cellSize);
            const gridY = Math.floor((y - this.gridY) / this.cellSize);
            
            return {
                x: Math.max(0, Math.min(gridX, gridWidth - 1)),
                y: Math.max(0, Math.min(gridY, gridHeight - 1))
            };
        };
        
        Phaser.Scene.prototype.updateGameState = function(state) {
            // Handle game state updates in Phaser
            if (state.phase === 'combat') {
                this.startCombatPhase(state);
            } else {
                this.startPreparationPhase(state);
            }
        };
        
        Phaser.Scene.prototype.startPreparationPhase = function(state) {
            console.log('=== Starting Preparation Phase ===');
            console.log('Game state:', state);
            console.log('Player ID:', playerId);
            
            // Hide and destroy background during preparation
            if (this.battleBackground) {
                this.battleBackground.destroy();
                this.battleBackground = null;
                console.log('Destroyed battle background');
            }
            
            // Show grid during preparation
            this.gridGraphics.setVisible(true);
            console.log('Grid made visible');
            
            // Clear existing unit sprites
            if (this.unitSprites) {
                console.log(`Destroying ${this.unitSprites.length} existing unit sprites`);
                this.unitSprites.forEach(sprite => {
                    if (sprite) {
                        // Clean up ownership indicators
                        if (sprite.ownershipIndicators) {
                            sprite.ownershipIndicators.forEach(indicator => {
                                if (indicator && indicator.destroy) indicator.destroy();
                            });
                        }
                        if (sprite.destroy) sprite.destroy();
                    }
                });
                this.unitSprites = [];
            }
            
            if (this.combatUnits) {
                const combatCount = Object.keys(this.combatUnits).length;
                console.log(`Destroying ${combatCount} existing combat units`);
                Object.values(this.combatUnits).forEach(unitData => {
                    if (unitData.sprite) {
                        // Clean up ownership indicators
                        if (unitData.sprite.ownershipIndicators) {
                            unitData.sprite.ownershipIndicators.forEach(indicator => {
                                if (indicator && indicator.destroy) indicator.destroy();
                            });
                        }
                        if (unitData.sprite.destroy) unitData.sprite.destroy();
                    }
                    if (unitData.healthBar && unitData.healthBar.container && unitData.healthBar.container.destroy) {
                        unitData.healthBar.container.destroy();
                    }
                });
                this.combatUnits = {};
            }
            
            // Additional cleanup: destroy any remaining sprites that might be lingering
            if (this.children) {
                this.children.list.forEach(child => {
                    // Don't destroy the grid graphics or permanent UI elements
                    if (child !== this.gridGraphics && child.texture && 
                        (child.texture.key.includes('knight') || child.texture.key.includes('priest') || 
                         child.texture.key.includes('fighter') || child.texture.key.includes('wizard') || 
                         child.texture.key.includes('goblin'))) {
                        console.log('Destroying lingering sprite:', child.texture.key);
                        child.destroy();
                    }
                });
            }
            
            // Add ALL player units to the grid during preparation and post-combat
            if (state.players && (state.phase === 'preparation' || state.phase === 'post-combat')) {
                console.log('Looking for ALL player units...');
                
                // Render units from ALL players, not just current player
                const allPlayerUnits = [];
                state.players.forEach(player => {
                    if (player.units && player.units.length > 0) {
                        allPlayerUnits.push(...player.units);
                    }
                });
                
                console.log(`Found ${allPlayerUnits.length} total units from all players`);
                
                if (allPlayerUnits.length > 0) {
                    console.log(`Rendering ${allPlayerUnits.length} units from all players:`, allPlayerUnits);
                    
                    // Ensure grid is properly drawn before positioning units
                    if (!this.gridX || !this.gridY || !this.cellSize) {
                        console.log('Grid not properly initialized, redrawing...');
                        this.drawGrid();
                    }
                    
                    allPlayerUnits.forEach((unit, index) => {
                        console.log(`Processing unit ${index + 1}/${allPlayerUnits.length}:`, unit);
                        
                        if (unit.position) {
                            const worldX = this.gridX + (unit.position.x * this.cellSize) + (this.cellSize / 2);
                            const worldY = this.gridY + (unit.position.y * this.cellSize) + (this.cellSize / 2);
                            
                            console.log(`Calculated world position: (${worldX}, ${worldY}) from grid (${unit.position.x}, ${unit.position.y})`);
                            console.log(`Grid bounds: X=${this.gridX}, Y=${this.gridY}, CellSize=${this.cellSize}`);
                            
                            const unitName = unit.name.toLowerCase();
                            const sprite = addUnitToScene(this, unitName, worldX, worldY);
                            
                            if (sprite) {
                                const scale = Math.min(this.cellSize / 80, 0.8);
                                sprite.setScale(scale);
                                
                                // Add colored border to indicate ownership
                                const color = getPlayerColor(unit.playerId, state.players);
                                
                                // Create border circle around unit
                                const borderGraphics = this.add.graphics();
                                borderGraphics.lineStyle(3, parseInt(color.primary.replace('#', '0x')), 1);
                                borderGraphics.strokeCircle(worldX, worldY, this.cellSize * 0.4);
                                borderGraphics.setDepth(worldY - 1); // Behind unit but visible
                                
                                // Store unit data for tooltip
                                sprite.unitData = unit;
                                sprite.ownerData = state.players.find(p => p.id === unit.playerId);
                                
                                // Make sprite interactive for tooltips with a slightly larger hit area for better responsiveness
                                sprite.setInteractive({ 
                                    useHandCursor: true,
                                    hitArea: new Phaser.Geom.Rectangle(-this.cellSize * 0.6, -this.cellSize * 0.6, this.cellSize * 1.2, this.cellSize * 1.2),
                                    hitAreaCallback: Phaser.Geom.Rectangle.Contains
                                });
                                
                                // Add tooltip handling - use full tooltip during preparation, game tooltip during combat
                                if (state.phase === 'preparation' || state.phase === 'post-combat') {
                                    // Use full detailed tooltip during preparation/post-combat
                                    sprite.on('pointerover', (pointer) => {
                                        const ownerName = sprite.ownerData?.name || 'Unknown';
                                        const tooltipData = {
                                            ...unit,
                                            owner: isOwnUnit ? 'You' : ownerName
                                        };
                                        
                                        // Create fake event for tooltip positioning
                                        const fakeEvent = {
                                            currentTarget: { getBoundingClientRect: () => ({ 
                                                left: worldX, 
                                                top: worldY, 
                                                width: this.cellSize, 
                                                height: this.cellSize,
                                                right: worldX + this.cellSize,
                                                bottom: worldY + this.cellSize
                                            }) },
                                            clientX: this.input.x,
                                            clientY: this.input.y
                                        };
                                        
                                        showTooltip(fakeEvent, unit.name, tooltipData);
                                    });
                                    
                                    sprite.on('pointerout', () => {
                                        hideTooltip();
                                    });
                                } else {
                                    // Use simplified game tooltip during combat
                                    sprite.on('pointerover', () => {
                                        cancelGameTooltipHide(); // Cancel any pending hide
                                        showGameTooltip(unit, sprite.ownerData?.name || 'Unknown', this.input.x, this.input.y);
                                    });
                                    
                                    sprite.on('pointermove', () => {
                                        updateGameTooltipPosition(this.input.x, this.input.y);
                                    });
                                    
                                    sprite.on('pointerout', () => {
                                        hideGameTooltipDelayed(); // Use delayed hide
                                    });
                                }
                                
                                // Store border reference for cleanup
                                if (!sprite.ownershipIndicators) {
                                    sprite.ownershipIndicators = [];
                                }
                                sprite.ownershipIndicators.push(borderGraphics);
                                
                                const isOwnUnit = unit.playerId === playerId;
                                console.log(`${isOwnUnit ? 'üë§ OWN' : 'üë• OTHER'} UNIT: ${unitName} (Player: ${unit.playerId}, Color: ${color.primary})`);
                                
                                // Add drag functionality for own units only
                                if (isOwnUnit && (state.phase === 'preparation' || state.phase === 'post-combat')) {
                                    this.setupGridUnitDrag(sprite, unit);
                                }
                                
                                // Tooltip functionality is already handled above
                                
                                this.unitSprites.push(sprite);
                                console.log(`‚úì SUCCESS: Placed ${unitName} at grid (${unit.position.x}, ${unit.position.y}) world (${worldX}, ${worldY})`);
                            } else {
                                console.error(`‚ùå FAILED: Could not create sprite for ${unitName}`);
                            }
                        } else {
                            console.warn(`Unit ${unit.name} has no position:`, unit);
                        }
                    });
                    
                    console.log(`Preparation phase complete. Total sprites created: ${this.unitSprites.length}`);
                } else {
                    console.log('No units to render - player has no units or units array is empty');
                }
            } else {
                console.log('No players found in state or not in preparation phase');
            }
        };
        
        Phaser.Scene.prototype.startCombatPhase = function(state) {
            console.log('=== Starting Combat Phase ===');
            console.log('Game state:', state);
            console.log('Current floor:', state.currentFloor);
            
            // Hide grid during combat
            this.gridGraphics.setVisible(false);
            console.log('Grid hidden for combat');
            
            // Show battle background based on floor
            this.setBattleBackground(state.currentFloor);
            
            // Clear existing unit sprites from preparation
            if (this.unitSprites && this.unitSprites.length > 0) {
                console.log(`Clearing ${this.unitSprites.length} preparation sprites`);
                this.unitSprites.forEach(sprite => {
                    if (sprite) {
                        // Clean up ownership indicators before destroying sprite
                        if (sprite.ownershipIndicators) {
                            sprite.ownershipIndicators.forEach(indicator => {
                                if (indicator && indicator.destroy) indicator.destroy();
                            });
                        }
                        if (sprite.destroy) sprite.destroy();
                    }
                });
                this.unitSprites = [];
            }
            
            // Initialize combat units container
            if (!this.combatUnits) {
                this.combatUnits = {};
            }
            
            let totalPlayerUnits = 0;
            let totalEnemyUnits = 0;
            
            // Add all player units to combat scene
            if (state.players) {
                console.log(`Processing ${state.players.length} players for combat`);
                state.players.forEach((player, playerIndex) => {
                    console.log(`Player ${playerIndex + 1}:`, player);
                    if (player.units && player.units.length > 0) {
                        console.log(`Adding ${player.units.length} units for player ${player.name}`);
                        player.units.forEach((unit, unitIndex) => {
                            console.log(`  Unit ${unitIndex + 1}: ${unit.name} at position`, unit.position, 'status:', unit.status);
                            if (unit.position) { // Add all units with position, including dead ones
                                this.addUnitToCombat(unit, false); // false = not enemy
                                if (unit.status !== 'dead') totalPlayerUnits++;
                            }
                        });
                    }
                });
            }
            
            // Add enemy units to combat scene
            if (state.enemyUnits && state.enemyUnits.length > 0) {
                console.log(`Adding ${state.enemyUnits.length} enemy units to combat`);
                state.enemyUnits.forEach((unit, index) => {
                    console.log(`  Enemy ${index + 1}: ${unit.name} at position`, unit.position, 'status:', unit.status);
                    if (unit.position) { // Add all units with position, including dead ones
                        this.addUnitToCombat(unit, true); // true = enemy
                        if (unit.status !== 'dead') totalEnemyUnits++;
                    }
                });
            } else {
                console.log('No enemy units found in game state');
            }
            
            console.log(`Combat phase setup complete: ${totalPlayerUnits} player units, ${totalEnemyUnits} enemy units`);
            console.log('Total combat sprites:', Object.keys(this.combatUnits).length);
        };
        
        Phaser.Scene.prototype.setBattleBackground = function(floor) {
            // Determine which background to use based on floor
            let backgroundKey;
            if (floor <= 3) {
                backgroundKey = 'battle1';
            } else if (floor <= 6) {
                backgroundKey = 'battle2';
            } else if (floor <= 8) {
                backgroundKey = 'battle3';
            } else {
                backgroundKey = 'battle4';
            }
            
            // Remove existing background
            if (this.battleBackground) {
                this.battleBackground.destroy();
            }
            
            // Add new background
            this.battleBackground = this.add.image(this.cameras.main.centerX, this.cameras.main.centerY, backgroundKey);
            this.battleBackground.setDisplaySize(this.cameras.main.width, this.cameras.main.height);
            this.battleBackground.setDepth(-1); // Behind everything else
            console.log(`Set battle background: ${backgroundKey} for floor ${floor}`);
        };
        
        Phaser.Scene.prototype.addUnitToCombat = function(unit, isEnemy) {
            if (this.combatUnits[unit.id]) {
                // Unit already exists, just update position and health bar
                const unitData = this.combatUnits[unit.id];
                const worldPos = this.getBattlePosition(unit.position);
                unitData.sprite.setPosition(worldPos.x, worldPos.y);
                
                // No ownership circles in combat - using health bar colors instead
                
                this.updateHealthBar(unitData, unit);
                return;
            }
            
            // Create new unit sprite
            const worldPos = this.getBattlePosition(unit.position);
            
            const unitName = unit.name.toLowerCase();
            const sprite = addUnitToScene(this, unitName, worldPos.x, worldPos.y);
            
            if (sprite) {
                const scale = Math.min(this.cellSize / 80, 0.8); // Slightly larger in combat
                sprite.setScale(scale);
                
                // Handle coloring for enemies vs players
                if (isEnemy) {
                    // Tint enemies red
                    sprite.setTint(0xff8888);
                } else {
                    // During combat, we don't show ownership circles
                    // Player ownership will be indicated by health bar colors instead
                }
                
                // Create health bar with enemy/friendly distinction and player color
                const healthBar = this.createHealthBar(worldPos.x, worldPos.y - 25, isEnemy, unit.playerId);
                
                // Store unit data
                this.combatUnits[unit.id] = {
                    sprite: sprite,
                    healthBar: healthBar,
                    maxHealth: unit.maxHealth
                };
                
                // Update health bar
                this.updateHealthBar(this.combatUnits[unit.id], unit);
                
                console.log(`Added ${isEnemy ? 'enemy' : 'player'} unit ${unitName} to combat at (${unit.position.x}, ${unit.position.y})`);
            } else {
                console.error(`Failed to create combat sprite for ${unitName}`);
            }
        };
        
        Phaser.Scene.prototype.getBattlePosition = function(gridPosition) {
            // Shift the battle area down so the bottom row aligns with screen bottom
            const gridBottom = this.cameras.main.height - 50; // Leave 50px margin
            const battleGridHeight = this.gridHeight * this.cellSize;
            const battleGridY = gridBottom - battleGridHeight;
            
            const worldX = this.gridX + (gridPosition.x * this.cellSize) + (this.cellSize / 2);
            const worldY = battleGridY + (gridPosition.y * this.cellSize) + (this.cellSize / 2);
            
            return { x: worldX, y: worldY };
        };
        
        Phaser.Scene.prototype.createHealthBar = function(x, y, isEnemy = false, playerId = null) {
            const barWidth = 50;
            const barHeight = 8;
            
            // Create container for the health bar
            const container = this.add.container(x, y);
            
            // Semi-transparent black background for visibility
            const background = this.add.graphics();
            background.fillStyle(0x000000, 0.6); // Semi-transparent black
            background.fillRoundedRect(-barWidth/2 - 2, -barHeight/2 - 2, barWidth + 4, barHeight + 4, 2);
            container.add(background);
            
            // Health bar border
            const border = this.add.graphics();
            border.lineStyle(1, 0xffffff, 0.8);
            border.strokeRoundedRect(-barWidth/2, -barHeight/2, barWidth, barHeight, 2);
            container.add(border);
            
            // Health bar fill
            const fill = this.add.graphics();
            container.add(fill);
            
            return {
                container: container,
                background: background,
                border: border,
                fill: fill,
                width: barWidth,
                height: barHeight,
                isEnemy: isEnemy,
                playerId: playerId
            };
        };
        
        Phaser.Scene.prototype.updateHealthBar = function(unitData, unit) {
            if (!unitData.healthBar || unit.health == null || !unit.maxHealth) return;
            
            const healthPercent = Math.max(0, Math.min(1, unit.health / unit.maxHealth));
            const fillWidth = unitData.healthBar.width * healthPercent;
            
            // Update health bar position to follow sprite
            const spritePos = { x: unitData.sprite.x, y: unitData.sprite.y - 30 };
            unitData.healthBar.container.setPosition(spritePos.x, spritePos.y);
            
            // Clear and redraw health bar fill with gradient effect
            unitData.healthBar.fill.clear();
            
            if (healthPercent > 0) {
                // Choose colors based on enemy/friendly and health percentage
                let fillColor;
                if (unitData.healthBar.isEnemy) {
                    // Red gradient for enemies
                    if (healthPercent > 0.6) {
                        fillColor = 0xff6666; // Light red
                    } else if (healthPercent > 0.3) {
                        fillColor = 0xff3333; // Medium red
                    } else {
                        fillColor = 0xff0000; // Dark red
                    }
                } else {
                    // Use player color for friendlies
                    let players = [];
                    if (window.gameState && window.gameState.players) {
                        players = window.gameState.players;
                    }
                    const playerColor = getPlayerColor(unitData.healthBar.playerId, players);
                    const baseColor = parseInt(playerColor.primary.replace('#', '0x'));
                    
                    // Create health-based variations of the player color
                    if (healthPercent > 0.6) {
                        fillColor = baseColor; // Full player color
                    } else if (healthPercent > 0.3) {
                        // Darker version for medium health
                        const r = Math.floor(((baseColor >> 16) & 0xFF) * 0.7);
                        const g = Math.floor(((baseColor >> 8) & 0xFF) * 0.7);
                        const b = Math.floor((baseColor & 0xFF) * 0.7);
                        fillColor = (r << 16) | (g << 8) | b;
                    } else {
                        // Even darker for low health
                        const r = Math.floor(((baseColor >> 16) & 0xFF) * 0.5);
                        const g = Math.floor(((baseColor >> 8) & 0xFF) * 0.5);
                        const b = Math.floor((baseColor & 0xFF) * 0.5);
                        fillColor = (r << 16) | (g << 8) | b;
                    }
                }
                
                // Draw the health bar fill with rounded corners
                unitData.healthBar.fill.fillStyle(fillColor);
                unitData.healthBar.fill.fillRoundedRect(
                    -unitData.healthBar.width/2, 
                    -unitData.healthBar.height/2, 
                    fillWidth, 
                    unitData.healthBar.height, 
                    2
                );
            }
        };
        
        Phaser.Scene.prototype.updateCombatState = function(playerUnits, enemyUnits) {
            // Update unit positions during combat
            [...playerUnits, ...enemyUnits].forEach(unit => {
                if (unit.position && this.combatUnits && this.combatUnits[unit.id]) {
                    const unitData = this.combatUnits[unit.id];
                    
                    // Convert grid position to battle world position
                    const worldPos = this.getBattlePosition(unit.position);
                    unitData.sprite.setPosition(worldPos.x, worldPos.y);
                    
                    // Update health bar
                    this.updateHealthBar(unitData, unit);
                    
                    // Update sprite based on unit status
                    if (unit.status === 'dead') {
                        unitData.sprite.setTint(0x666666);
                        unitData.sprite.setAlpha(0.5);
                        // Hide health bar for dead units
                        unitData.healthBar.container.setVisible(false);
                        
                        // Play death animation for dead units
                        const unitName = unit.name.toLowerCase();
                        const deathAnimKey = `${unitName}_death`;
                        
                        if (!unitData.hasPlayedDeath) {
                            // Mark that we've started the death animation
                            unitData.hasPlayedDeath = true;
                            
                            if (this.anims.exists(deathAnimKey)) {
                                console.log(`Playing death animation: ${deathAnimKey} for unit ${unit.id}`);
                                unitData.sprite.play(deathAnimKey);
                                
                                // After death animation completes, remove unit from battlefield  
                                unitData.sprite.once('animationcomplete', () => {
                                    console.log(`Death animation complete for unit ${unit.id}, removing from battlefield`);
                                    // Remove the sprite completely after death animation
                                    this.time.delayedCall(500, () => {
                                        if (unitData.sprite && unitData.sprite.scene) {
                                            unitData.sprite.setVisible(false);
                                            unitData.sprite.destroy();
                                        }
                                        if (unitData.healthBar && unitData.healthBar.container && unitData.healthBar.container.scene) {
                                            unitData.healthBar.container.destroy();
                                        }
                                        // Remove from tracking
                                        this.unitSprites = this.unitSprites.filter(s => s !== unitData.sprite);
                                        delete this.unitSpriteMap[unit.id];
                                    });
                                });
                            } else {
                                // Fallback: immediately remove if no death animation
                                console.log(`No death animation for ${unitName}, removing immediately`);
                                this.time.delayedCall(1000, () => {
                                    if (unitData.sprite && unitData.sprite.scene) {
                                        unitData.sprite.setVisible(false);
                                        unitData.sprite.destroy();
                                    }
                                    if (unitData.healthBar && unitData.healthBar.container && unitData.healthBar.container.scene) {
                                        unitData.healthBar.container.destroy();
                                    }
                                    this.unitSprites = this.unitSprites.filter(s => s !== unitData.sprite);
                                    delete this.unitSpriteMap[unit.id];
                                });
                            }
                        }
                    } else {
                        // Show health bar for living units
                        unitData.healthBar.container.setVisible(true);
                        
                        // Determine if enemy or player for coloring
                        const isEnemy = unit.id.startsWith('enemy-');
                        const unitName = unit.name.toLowerCase();
                        
                        // Handle facing direction based on movement
                        if (unit.movementDirection && (unit.movementDirection.x !== 0 || unit.movementDirection.y !== 0)) {
                            // Face the direction of movement
                            if (unit.movementDirection.x > 0) {
                                unitData.sprite.setFlipX(false); // Face right
                            } else if (unit.movementDirection.x < 0) {
                                unitData.sprite.setFlipX(true); // Face left
                            }
                        }
                        
                        // Handle animations and tinting based on status
                        if (unit.status === 'attacking') {
                            // Remove tints from all units - health bar colors are sufficient
                            unitData.sprite.setTint(0xffffff);
                            
                            // Handle facing direction for attacks
                            if (unit.targetId) {
                                // Find the target unit to determine facing direction
                                const allUnits = [...playerUnits, ...enemyUnits];
                                const target = allUnits.find(u => u.id === unit.targetId);
                                if (target && target.position) {
                                    // Calculate direction to target
                                    const dx = target.position.x - unit.position.x;
                                    // Face the target: flip sprite if target is to the left
                                    if (dx < 0) {
                                        unitData.sprite.setFlipX(true); // Face left
                                    } else if (dx > 0) {
                                        unitData.sprite.setFlipX(false); // Face right
                                    }
                                    // If dx === 0 (same x position), keep current facing
                                }
                            }
                            
                            // Play attack animation
                            const attackAnimKey = `${unitName}_attack`;
                            if (this.anims.exists(attackAnimKey)) {
                                if (!unitData.sprite.anims.isPlaying || unitData.sprite.anims.currentAnim.key !== attackAnimKey) {
                                    console.log(`Playing attack animation: ${attackAnimKey} for unit ${unit.id}`);
                                    unitData.sprite.play(attackAnimKey);
                                    
                                    // Chain back to idle after attack
                                    unitData.sprite.once('animationcomplete', () => {
                                        const idleAnimKey = `${unitName}_idle`;
                                        if (this.anims.exists(idleAnimKey)) {
                                            console.log(`Attack complete, playing idle: ${idleAnimKey} for unit ${unit.id}`);
                                            unitData.sprite.play(idleAnimKey);
                                        }
                                    });
                                }
                            } else {
                                console.log(`No attack animation found for ${unitName}, using idle`);
                                // Fallback to idle if no attack animation
                                const idleAnimKey = `${unitName}_idle`;
                                if (this.anims.exists(idleAnimKey)) {
                                    if (!unitData.sprite.anims.isPlaying || unitData.sprite.anims.currentAnim.key !== idleAnimKey) {
                                        unitData.sprite.play(idleAnimKey, true);
                                    }
                                }
                            }
                        } else if (unit.status === 'moving') {
                            unitData.sprite.setTint(0xffffff); // Remove red tint from enemies
                            
                            // Play walk animation
                            const walkAnimKey = `${unitName}_walk`;
                            if (this.anims.exists(walkAnimKey)) {
                                if (!unitData.sprite.anims.isPlaying || unitData.sprite.anims.currentAnim.key !== walkAnimKey) {
                                    unitData.sprite.play(walkAnimKey, true);
                                }
                            } else {
                                // Fallback to idle if no walk animation
                                const idleAnimKey = `${unitName}_idle`;
                                if (this.anims.exists(idleAnimKey)) {
                                    if (!unitData.sprite.anims.isPlaying || unitData.sprite.anims.currentAnim.key !== idleAnimKey) {
                                        unitData.sprite.play(idleAnimKey, true);
                                    }
                                }
                            }
                        } else {
                            unitData.sprite.setTint(0xffffff); // Remove red tint from enemies
                            
                            // Play idle animation
                            const idleAnimKey = `${unitName}_idle`;
                            if (this.anims.exists(idleAnimKey)) {
                                if (!unitData.sprite.anims.isPlaying || unitData.sprite.anims.currentAnim.key !== idleAnimKey) {
                                    unitData.sprite.play(idleAnimKey, true);
                                }
                            }
                        }
                        
                        unitData.sprite.setAlpha(1);
                    }
                }
            });
        };
        
        
        function update() {
            // Update game logic - canvas rendering now handled by individual animated sprites
            // No longer need to update canvas manually since each sprite manages its own animation
        }
        
        // Upgrade system functions
        let selectedUpgrades = new Map(); // Map of upgradeId -> targetUnitType
        
        function showUpgradeSelection(upgradeCards, currentFloor, playerGold) {
            console.log('Showing upgrade selection:', upgradeCards);
            
            // Clear upgrade selections when showing new upgrades
            upgradeSelections.clear();
            selectedUpgrade = null;
            
            // Hide the global select button initially
            const selectBtn = document.getElementById('select-upgrade-btn');
            selectBtn.classList.add('hidden');
            selectBtn.disabled = true;
            
            // Update floor display
            document.getElementById('upgrade-floor').textContent = currentFloor;
            
            // Clear previous selections
            selectedUpgrades.clear();
            
            // Separate high-potency and normal upgrades
            const highPotencyUpgrades = upgradeCards.filter(u => u.isHighPotency);
            const normalUpgrades = upgradeCards.filter(u => !u.isHighPotency);
            
            // Display high-potency upgrade
            const highPotencyContainer = document.getElementById('high-potency-upgrade');
            highPotencyContainer.innerHTML = '';
            
            if (highPotencyUpgrades.length > 0) {
                const upgrade = highPotencyUpgrades[0];
                const upgradeCard = createUpgradeCard(upgrade, true);
                highPotencyContainer.appendChild(upgradeCard);
            }
            
            // Display normal upgrades
            const normalContainer = document.getElementById('normal-upgrades');
            normalContainer.innerHTML = '';
            
            normalUpgrades.forEach(upgrade => {
                const upgradeCard = createUpgradeCard(upgrade, false);
                normalContainer.appendChild(upgradeCard);
            });
            
            // Initialize unit sprites for all upgrade cards
            setTimeout(() => {
                initializeUpgradeSprites();
            }, 100);
            
            // Update reroll button
            const rerollBtn = document.getElementById('reroll-btn');
            rerollBtn.disabled = playerGold < 10;
            rerollBtn.textContent = `Reroll Upgrades (üí∞ 10)${playerGold < 10 ? ' - Not enough gold' : ''}`;
        }
        
        function createUpgradeCard(upgrade, isHighPotency) {
            const card = document.createElement('div');
            card.className = `upgrade-card ${isHighPotency ? 'high-potency' : ''}`;
            card.setAttribute('data-upgrade-id', upgrade.id);
            
            const effectValue = isHighPotency ? (upgrade.value * 3) : upgrade.value;
            const displayValue = upgrade.effect === 'priority' ? 
                (effectValue > 0 ? `+${effectValue}` : effectValue.toString()) :
                `${Math.round(effectValue * 100)}%`;
            
            let description = upgrade.description;
            if (isHighPotency) {
                // Replace percentages with 3x values
                description = description.replace(/(\d+)%/g, (match, num) => `${parseInt(num) * 3}%`);
                // Replace flat values (like HP/sec) with 3x values  
                description = description.replace(/(\d+)\s*(HP\/sec|damage)/g, (match, num, unit) => `${parseInt(num) * 3} ${unit}`);
                // Replace +/- priority values
                description = description.replace(/([+-])(\d+)\s*Priority/g, (match, sign, num) => `${sign}${parseInt(num) * 3} Priority`);
            }
            
            // Create icon filename from upgrade name
            const iconName = upgrade.name.toLowerCase().replace(/\s+/g, '_');
            const iconPath = `assets/upgradeicons/${iconName}.png`;
            
            card.innerHTML = `
                <div class="upgrade-icon">
                    <img src="${iconPath}" alt="${upgrade.name}" onerror="this.style.display='none'">
                </div>
                <div class="upgrade-name">${upgrade.name}</div>
                <div class="upgrade-description">${description}</div>
                ${isHighPotency ? 
                    `<div class="upgrade-target">Applied to: ${upgrade.targetUnitType}</div>` :
                    '<div class="upgrade-target">Select units to upgrade:</div>'
                }
                ${createUnitTypeSelector(upgrade.id, isHighPotency, upgrade.targetUnitType)}
                <div class="upgrade-actions">
                    <!-- Individual card buttons removed - using global fixed position button -->
                </div>
            `;
            
            // Add click handler to select this upgrade card
            card.addEventListener('click', () => {
                selectUpgradeCard(upgrade, isHighPotency);
            });
            
            return card;
        }
        
        function createUnitTypeSelector(upgradeId, isHighPotency, targetUnitType = null) {
            // Get owned unit types from current game state
            const ownedUnitTypes = new Set();
            if (gameState && gameState.players) {
                const currentPlayer = gameState.players.find(p => p.id === playerId);
                if (currentPlayer && currentPlayer.units) {
                    currentPlayer.units.forEach(unit => {
                        if (unit.status !== 'dead') {
                            ownedUnitTypes.add(unit.name);
                        }
                    });
                }
            }
            
            // Fallback to common unit types if no game state
            if (ownedUnitTypes.size === 0) {
                ['Knight', 'Priest', 'Fighter', 'Wizard', 'Goblin'].forEach(type => ownedUnitTypes.add(type));
            }
            
            const unitTypes = Array.from(ownedUnitTypes);
            
            if (isHighPotency && targetUnitType) {
                // For high potency upgrades, show the target unit sprite
                const unitKey = targetUnitType.toLowerCase();
                return `
                    <div class="unit-type-selector high-potency-target">
                        <div class="unit-selection-sprite selected" data-unit-type="${targetUnitType}">
                            <div class="unit-sprite-container" id="sprite-${upgradeId}-${unitKey}">
                                <!-- Target unit sprite will be added here -->
                            </div>
                            <div class="unit-selection-name">${targetUnitType}</div>
                        </div>
                    </div>
                `;
            } else {
                // For normal upgrades, show all available unit types as animated sprites
                const unitSprites = unitTypes.map(unitType => {
                    const unitKey = unitType.toLowerCase();
                    return `
                        <div class="unit-selection-sprite" 
                             data-unit-type="${unitType}" 
                             data-upgrade-id="${upgradeId}"
                             onclick="selectUnitForUpgrade('${upgradeId}', '${unitType}')">
                            <div class="unit-sprite-container" id="sprite-${upgradeId}-${unitKey}">
                                <!-- Sprite will be added here by JavaScript -->
                            </div>
                            <div class="unit-selection-name">${unitType}</div>
                        </div>
                    `;
                }).join('');
                
                return `<div class="unit-type-selector unit-sprite-selector">${unitSprites}</div>`;
            }
        }
        
        // Track selected units for each upgrade
        let upgradeSelections = new Map(); // upgradeId -> selectedUnitType
        
        // Track currently selected upgrade for global button
        let selectedUpgrade = null;
        
        function selectUpgradeCard(upgrade, isHighPotency) {
            // Clear previous selection
            document.querySelectorAll('.upgrade-card').forEach(card => {
                card.classList.remove('selected');
            });
            
            // Mark this card as selected
            const card = document.querySelector(`[data-upgrade-id="${upgrade.id}"]`);
            if (card) {
                card.classList.add('selected');
            }
            
            // Store the selected upgrade
            selectedUpgrade = { upgrade, isHighPotency };
            
            // Show the global select button
            const selectBtn = document.getElementById('select-upgrade-btn');
            selectBtn.classList.remove('hidden');
            
            // For normal upgrades, check if a unit type is selected
            if (!isHighPotency) {
                const hasUnitSelection = upgradeSelections.has(upgrade.id);
                selectBtn.disabled = !hasUnitSelection;
            } else {
                selectBtn.disabled = false;
            }
        }
        
        function confirmSelectedUpgrade() {
            if (!selectedUpgrade) return;
            
            const { upgrade, isHighPotency } = selectedUpgrade;
            
            if (isHighPotency) {
                confirmUpgrade(upgrade.id, upgrade.targetUnitType);
            } else {
                confirmUpgradeWithSelection(upgrade.id);
            }
        }
        
        function selectUnitForUpgrade(upgradeId, unitType) {
            // Clear selections on all other upgrade cards
            upgradeSelections.forEach((selectedUnit, otherUpgradeId) => {
                if (otherUpgradeId !== upgradeId) {
                    // Clear visual selection
                    document.querySelectorAll(`[data-upgrade-id="${otherUpgradeId}"] .unit-selection-sprite`).forEach(sprite => {
                        sprite.classList.remove('selected');
                    });
                    // Disable confirm button
                    const otherConfirmBtn = document.querySelector(`[data-upgrade-id="${otherUpgradeId}"] .confirm-upgrade-btn`);
                    if (otherConfirmBtn) {
                        otherConfirmBtn.disabled = true;
                    }
                }
            });
            
            // Clear all selections except this one
            upgradeSelections.clear();
            upgradeSelections.set(upgradeId, unitType);
            
            // Update visual selection for this upgrade
            document.querySelectorAll(`[data-upgrade-id="${upgradeId}"] .unit-selection-sprite`).forEach(sprite => {
                sprite.classList.remove('selected');
            });
            
            const selectedSprite = document.querySelector(`[data-upgrade-id="${upgradeId}"][data-unit-type="${unitType}"]`);
            if (selectedSprite) {
                selectedSprite.classList.add('selected');
            }
            
            // Update the global select button if this upgrade is currently selected
            if (selectedUpgrade && selectedUpgrade.upgrade.id === upgradeId) {
                const selectBtn = document.getElementById('select-upgrade-btn');
                selectBtn.disabled = false;
            }
        }
        
        function updateUpgradeSelection(upgradeId) {
            // Legacy function - still needed for radio button compatibility
            const selectedRadio = document.querySelector(`input[name="unit-${upgradeId}"]:checked`);
            const confirmBtn = document.querySelector(`[data-upgrade-id="${upgradeId}"] .confirm-upgrade-btn`);
            
            if (confirmBtn) {
                confirmBtn.disabled = !selectedRadio;
            }
        }
        
        function confirmUpgrade(upgradeId, targetUnitType) {
            console.log(`Confirming high potency upgrade ${upgradeId} for ${targetUnitType}`);
            
            if (socket && socket.connected) {
                socket.emit('selectUpgrade', upgradeId, targetUnitType);
            }
        }
        
        function confirmUpgradeWithSelection(upgradeId) {
            // Get the selected unit type from our tracking system
            const selectedType = upgradeSelections.get(upgradeId);
            
            if (!selectedType) {
                console.log('No unit type selected');
                return;
            }
            
            console.log(`Confirming upgrade ${upgradeId} for unit type: ${selectedType}`);
            
            // Apply upgrade to the selected unit type
            if (socket && socket.connected) {
                socket.emit('selectUpgrade', upgradeId, selectedType);
            }
        }
        
        function initializeUpgradeSprites() {
            // Find all unit sprite containers in upgrade cards
            document.querySelectorAll('.unit-sprite-container').forEach(container => {
                const id = container.id;
                const match = id.match(/sprite-(.+)-(.+)/);
                if (match) {
                    const upgradeId = match[1];
                    const unitKey = match[2];
                    
                    // Create a mini canvas for this unit
                    createUpgradeUnitSprite(container, unitKey);
                }
            });
        }
        
        // Track active animations to prevent duplicates
        const activeAnimations = new Map();
        
        // Universal animated sprite creator - EXACTLY matches grid sprite behavior
        function createAnimatedUnitSprite(container, unitKey, width = 48, height = 48, animSpeed = 300) {
            // Clear any existing animation for this container
            const containerId = container.id || Math.random().toString();
            if (activeAnimations.has(containerId)) {
                clearTimeout(activeAnimations.get(containerId));
                activeAnimations.delete(containerId);
            }
            
            // Clear any existing content
            container.innerHTML = '';
            
            // Create canvas for unit animation
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            canvas.style.imageRendering = 'pixelated';
            container.appendChild(canvas);
            
            const ctx = canvas.getContext('2d');
            
            // Try to create a Phaser sprite exactly like grid sprites if scene is available
            if (window.gameScene && window.gameScene.textures && window.gameScene.textures.exists(unitKey)) {
                // Create an off-screen Phaser sprite EXACTLY like addUnitToScene does
                const offScreenSprite = window.gameScene.add.sprite(-2000, -2000, unitKey);
                offScreenSprite.setScale(0.75); // Initial scale from addUnitToScene
                offScreenSprite.setVisible(false); // Keep it invisible
                
                // Apply the SAME secondary scale as grid sprites
                // This is the key missing piece! Grid sprites get scaled again
                // Use the actual grid cellSize if available, otherwise estimate from container
                const actualCellSize = window.gameScene?.cellSize || Math.min(width, height);
                const gridScale = Math.min(actualCellSize / 80, 0.8); // EXACT same formula as grid
                offScreenSprite.setScale(gridScale); // This overwrites 0.75 just like grid sprites
                
                // Try to play idle animation exactly like grid sprites
                const idleAnimKey = `${unitKey}_idle`;
                if (window.gameScene.anims.exists(idleAnimKey)) {
                    offScreenSprite.play(idleAnimKey);
                    console.log(`UI Sprite: Playing ${idleAnimKey} animation like grid`);
                } else {
                    // Fallback to first frame like grid sprites
                    console.warn(`UI Sprite: Animation ${idleAnimKey} not found, trying first frame`);
                    const texture = window.gameScene.textures.get(unitKey);
                    const frames = texture.getFrameNames();
                    if (frames.length > 0) {
                        offScreenSprite.setFrame(frames[0]);
                        console.log(`UI Sprite: Set ${unitKey} to frame: ${frames[0]}`);
                    }
                }
                
                // Set depth like grid sprites
                offScreenSprite.setDepth(10);
                
                // Render the Phaser sprite to our canvas
                const renderSprite = () => {
                    if (!container.parentNode) {
                        // Clean up sprite when container is removed
                        if (offScreenSprite) {
                            offScreenSprite.destroy();
                        }
                        if (activeAnimations.has(containerId)) {
                            clearTimeout(activeAnimations.get(containerId));
                            activeAnimations.delete(containerId);
                        }
                        return;
                    }
                    
                    ctx.clearRect(0, 0, width, height);
                    
                    // Get the current frame from the Phaser sprite
                    const frame = offScreenSprite.frame;
                    if (frame && frame.source && frame.source.image) {
                        // Calculate positioning to center the sprite in canvas
                        const spriteWidth = frame.width * offScreenSprite.scaleX;
                        const spriteHeight = frame.height * offScreenSprite.scaleY;
                        const x = (width - spriteWidth) / 2;
                        const y = (height - spriteHeight) / 2;
                        
                        // Draw the sprite frame exactly as Phaser would
                        ctx.save();
                        ctx.translate(x + spriteWidth / 2, y + spriteHeight / 2);
                        if (offScreenSprite.flipX) ctx.scale(-1, 1);
                        if (offScreenSprite.flipY) ctx.scale(1, -1);
                        ctx.globalAlpha = offScreenSprite.alpha;
                        
                        ctx.drawImage(
                            frame.source.image,
                            frame.x, frame.y, frame.width, frame.height,
                            -spriteWidth / 2, -spriteHeight / 2, spriteWidth, spriteHeight
                        );
                        ctx.restore();
                    }
                    
                    // Continue animation loop
                    const animationId = setTimeout(renderSprite, animSpeed);
                    activeAnimations.set(containerId, animationId);
                };
                
                renderSprite();
            } else {
                // Fallback to text sprite if Phaser not available
                drawTextSprite(ctx, unitKey.toUpperCase(), width, height);
            }
        }
        
        // Maintain backward compatibility
        function createUpgradeUnitSprite(container, unitKey) {
            createAnimatedUnitSprite(container, unitKey, 48, 48, 300);
        }
        
        function drawTextSprite(ctx, text, width, height) {
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(0, 0, width, height);
            
            ctx.fillStyle = '#FFD700';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(text, width/2, height/2 + 3);
        }
        
        function selectUnitType(upgradeId, unitType) {
            console.log(`Selected unit type ${unitType} for upgrade ${upgradeId}`);
            
            // This function is kept for backward compatibility but no longer used
            // The new UI uses sprite selection
        }
        
        function rerollUpgrades() {
            console.log('Rerolling upgrades');
            if (socket && socket.connected) {
                socket.emit('rerollUpgrades');
            }
        }
        
        // Initialize everything when page loads
        window.addEventListener('load', () => {
            initSocket();
            initPhaser();
            
            // Show lobby on start
            document.getElementById('lobby-modal').classList.remove('hidden');
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            handleResize();
        });
        
        // Debounced resize handler for better performance
        let resizeTimeout;
        function handleResize() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (game) {
                    game.scale.resize(window.innerWidth, window.innerHeight);
                    
                    // Redraw grid after resize
                    if (window.gameScene && window.gameScene.drawGrid) {
                        window.gameScene.drawGrid();
                        
                        // Update unit positions if in preparation phase
                        if (gameState && (gameState.phase === 'preparation' || gameState.phase === 'post-combat')) {
                            window.gameScene.updateGameState(gameState);
                        }
                    }
                }
                
                // Update HUD positions for mobile/electron
                updateHUDPositions();
            }, 150);
        }
        
        // Update HUD positions based on screen size
        function updateHUDPositions() {
            const isSmallScreen = window.innerWidth < 768 || window.innerHeight < 600;
            const shopPanel = document.getElementById('shop-panel');
            const unitPanel = document.getElementById('unit-panel');
            
            if (isSmallScreen) {
                // Compact mode for small screens
                if (shopPanel) {
                    shopPanel.style.padding = '10px';
                    shopPanel.style.gap = '8px';
                }
                if (unitPanel) {
                    unitPanel.style.maxHeight = '120px';
                }
            } else {
                // Normal mode
                if (shopPanel) {
                    shopPanel.style.padding = '15px';
                    shopPanel.style.gap = '10px';
                }
                if (unitPanel) {
                    unitPanel.style.maxHeight = '150px';
                }
            }
        }
        
        // Handle orientation change for mobile
        window.addEventListener('orientationchange', () => {
            setTimeout(handleResize, 100);
        });
        
        // React Native WebView message handling
        if (window.ReactNativeWebView) {
            window.addEventListener('message', (event) => {
                if (event.data && event.data.type === 'resize') {
                    handleResize();
                }
            });
        }
        
        // Electron IPC handling
        if (window.electron && window.electron.ipcRenderer) {
            window.electron.ipcRenderer.on('window-resize', handleResize);
        }
    </script>
</body>
</html>